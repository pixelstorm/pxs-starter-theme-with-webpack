/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/customizer.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.5.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2020-05-04T22:49Z\n */\n(function (global, factory) {\n  \"use strict\";\n\n  if ( true && typeof module.exports === \"object\") {\n    // For CommonJS and CommonJS-like environments where a proper `window`\n    // is present, execute the factory and get jQuery.\n    // For environments that do not have a `window` with a `document`\n    // (such as Node.js), expose a factory as module.exports.\n    // This accentuates the need for the creation of a real `window`.\n    // e.g. var jQuery = require(\"jquery\")(window);\n    // See ticket #14549 for more info.\n    module.exports = global.document ? factory(global, true) : function (w) {\n      if (!w.document) {\n        throw new Error(\"jQuery requires a window with a document\");\n      }\n\n      return factory(w);\n    };\n  } else {\n    factory(global);\n  } // Pass this if window is not defined yet\n\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n  // enough that all such attempts are guarded in a try block.\n  \"use strict\";\n\n  var arr = [];\n  var getProto = Object.getPrototypeOf;\n  var slice = arr.slice;\n  var flat = arr.flat ? function (array) {\n    return arr.flat.call(array);\n  } : function (array) {\n    return arr.concat.apply([], array);\n  };\n  var push = arr.push;\n  var indexOf = arr.indexOf;\n  var class2type = {};\n  var toString = class2type.toString;\n  var hasOwn = class2type.hasOwnProperty;\n  var fnToString = hasOwn.toString;\n  var ObjectFunctionString = fnToString.call(Object);\n  var support = {};\n\n  var isFunction = function isFunction(obj) {\n    // Support: Chrome <=57, Firefox <=52\n    // In some browsers, typeof returns \"function\" for HTML <object> elements\n    // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n    // We don't want to classify *any* DOM node as a function.\n    return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n  var isWindow = function isWindow(obj) {\n    return obj != null && obj === obj.window;\n  };\n\n  var document = window.document;\n  var preservedScriptAttributes = {\n    type: true,\n    src: true,\n    nonce: true,\n    noModule: true\n  };\n\n  function DOMEval(code, node, doc) {\n    doc = doc || document;\n    var i,\n        val,\n        script = doc.createElement(\"script\");\n    script.text = code;\n\n    if (node) {\n      for (i in preservedScriptAttributes) {\n        // Support: Firefox 64+, Edge 18+\n        // Some browsers don't support the \"nonce\" property on scripts.\n        // On the other hand, just using `getAttribute` is not enough as\n        // the `nonce` attribute is reset to an empty string whenever it\n        // becomes browsing-context connected.\n        // See https://github.com/whatwg/html/issues/2369\n        // See https://html.spec.whatwg.org/#nonce-attributes\n        // The `node.getAttribute` check was added for the sake of\n        // `jQuery.globalEval` so that it can fake a nonce-containing node\n        // via an object.\n        val = node[i] || node.getAttribute && node.getAttribute(i);\n\n        if (val) {\n          script.setAttribute(i, val);\n        }\n      }\n    }\n\n    doc.head.appendChild(script).parentNode.removeChild(script);\n  }\n\n  function toType(obj) {\n    if (obj == null) {\n      return obj + \"\";\n    } // Support: Android <=2.3 only (functionish RegExp)\n\n\n    return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : typeof obj;\n  }\n  /* global Symbol */\n  // Defining this global in .eslintrc.json would create a danger of using the global\n  // unguarded in another place, it seems safer to define global only for this module\n\n\n  var version = \"3.5.1\",\n      // Define a local copy of jQuery\n  jQuery = function (selector, context) {\n    // The jQuery object is actually just the init constructor 'enhanced'\n    // Need init if jQuery is called (just allow error to be thrown if not included)\n    return new jQuery.fn.init(selector, context);\n  };\n\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: version,\n    constructor: jQuery,\n    // The default length of a jQuery object is 0\n    length: 0,\n    toArray: function () {\n      return slice.call(this);\n    },\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function (num) {\n      // Return all the elements in a clean array\n      if (num == null) {\n        return slice.call(this);\n      } // Return just the one element from the set\n\n\n      return num < 0 ? this[num + this.length] : this[num];\n    },\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function (elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)\n\n      ret.prevObject = this; // Return the newly-formed element set\n\n      return ret;\n    },\n    // Execute a callback for every element in the matched set.\n    each: function (callback) {\n      return jQuery.each(this, callback);\n    },\n    map: function (callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n    slice: function () {\n      return this.pushStack(slice.apply(this, arguments));\n    },\n    first: function () {\n      return this.eq(0);\n    },\n    last: function () {\n      return this.eq(-1);\n    },\n    even: function () {\n      return this.pushStack(jQuery.grep(this, function (_elem, i) {\n        return (i + 1) % 2;\n      }));\n    },\n    odd: function () {\n      return this.pushStack(jQuery.grep(this, function (_elem, i) {\n        return i % 2;\n      }));\n    },\n    eq: function (i) {\n      var len = this.length,\n          j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    end: function () {\n      return this.prevObject || this.constructor();\n    },\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: arr.sort,\n    splice: arr.splice\n  };\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var options,\n        name,\n        src,\n        copy,\n        copyIsArray,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target; // Skip the boolean and the target\n\n      target = arguments[i] || {};\n      i++;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (typeof target !== \"object\" && !isFunction(target)) {\n      target = {};\n    } // Extend jQuery itself if only one argument is passed\n\n\n    if (i === length) {\n      target = this;\n      i--;\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          copy = options[name]; // Prevent Object.prototype pollution\n          // Prevent never-ending loop\n\n          if (name === \"__proto__\" || target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n            src = target[name]; // Ensure proper type for the source value\n\n            if (copyIsArray && !Array.isArray(src)) {\n              clone = [];\n            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {\n              clone = {};\n            } else {\n              clone = src;\n            }\n\n            copyIsArray = false; // Never move original objects, clone them\n\n            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  jQuery.extend({\n    // Unique for each copy of jQuery on the page\n    expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n    error: function (msg) {\n      throw new Error(msg);\n    },\n    noop: function () {},\n    isPlainObject: function (obj) {\n      var proto, Ctor; // Detect obvious negatives\n      // Use toString instead of jQuery.type to catch host objects\n\n      if (!obj || toString.call(obj) !== \"[object Object]\") {\n        return false;\n      }\n\n      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain\n\n      if (!proto) {\n        return true;\n      } // Objects with prototype are plain iff they were constructed by a global Object function\n\n\n      Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n      return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n    },\n    isEmptyObject: function (obj) {\n      var name;\n\n      for (name in obj) {\n        return false;\n      }\n\n      return true;\n    },\n    // Evaluates a script in a provided context; falls back to the global one\n    // if not specified.\n    globalEval: function (code, options, doc) {\n      DOMEval(code, {\n        nonce: options && options.nonce\n      }, doc);\n    },\n    each: function (obj, callback) {\n      var length,\n          i = 0;\n\n      if (isArrayLike(obj)) {\n        length = obj.length;\n\n        for (; i < length; i++) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      } else {\n        for (i in obj) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      }\n\n      return obj;\n    },\n    // results is for internal usage only\n    makeArray: function (arr, results) {\n      var ret = results || [];\n\n      if (arr != null) {\n        if (isArrayLike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n        } else {\n          push.call(ret, arr);\n        }\n      }\n\n      return ret;\n    },\n    inArray: function (elem, arr, i) {\n      return arr == null ? -1 : indexOf.call(arr, elem, i);\n    },\n    // Support: Android <=4.0 only, PhantomJS 1 only\n    // push.apply(_, arraylike) throws on ancient WebKit\n    merge: function (first, second) {\n      var len = +second.length,\n          j = 0,\n          i = first.length;\n\n      for (; j < len; j++) {\n        first[i++] = second[j];\n      }\n\n      first.length = i;\n      return first;\n    },\n    grep: function (elems, callback, invert) {\n      var callbackInverse,\n          matches = [],\n          i = 0,\n          length = elems.length,\n          callbackExpect = !invert; // Go through the array, only saving the items\n      // that pass the validator function\n\n      for (; i < length; i++) {\n        callbackInverse = !callback(elems[i], i);\n\n        if (callbackInverse !== callbackExpect) {\n          matches.push(elems[i]);\n        }\n      }\n\n      return matches;\n    },\n    // arg is for internal usage only\n    map: function (elems, callback, arg) {\n      var length,\n          value,\n          i = 0,\n          ret = []; // Go through the array, translating each of the items to their new values\n\n      if (isArrayLike(elems)) {\n        length = elems.length;\n\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        } // Go through every key on the object,\n\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n      } // Flatten any nested arrays\n\n\n      return flat(ret);\n    },\n    // A global GUID counter for objects\n    guid: 1,\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n  });\n\n  if (typeof Symbol === \"function\") {\n    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n  } // Populate the class2type map\n\n\n  jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (_i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  function isArrayLike(obj) {\n    // Support: real iOS 8.2 only (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn't used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = !!obj && \"length\" in obj && obj.length,\n        type = toType(obj);\n\n    if (isFunction(obj) || isWindow(obj)) {\n      return false;\n    }\n\n    return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n  }\n\n  var Sizzle =\n  /*!\n   * Sizzle CSS Selector Engine v2.3.5\n   * https://sizzlejs.com/\n   *\n   * Copyright JS Foundation and other contributors\n   * Released under the MIT license\n   * https://js.foundation/\n   *\n   * Date: 2020-03-14\n   */\n  function (window) {\n    var i,\n        support,\n        Expr,\n        getText,\n        isXML,\n        tokenize,\n        compile,\n        select,\n        outermostContext,\n        sortInput,\n        hasDuplicate,\n        // Local document vars\n    setDocument,\n        document,\n        docElem,\n        documentIsHTML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n        // Instance-specific data\n    expando = \"sizzle\" + 1 * new Date(),\n        preferredDoc = window.document,\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        nonnativeSelectorCache = createCache(),\n        sortOrder = function (a, b) {\n      if (a === b) {\n        hasDuplicate = true;\n      }\n\n      return 0;\n    },\n        // Instance methods\n    hasOwn = {}.hasOwnProperty,\n        arr = [],\n        pop = arr.pop,\n        pushNative = arr.push,\n        push = arr.push,\n        slice = arr.slice,\n        // Use a stripped-down indexOf as it's faster than native\n    // https://jsperf.com/thor-indexof-vs-for/5\n    indexOf = function (list, elem) {\n      var i = 0,\n          len = list.length;\n\n      for (; i < len; i++) {\n        if (list[i] === elem) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n        booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" + \"ismap|loop|multiple|open|readonly|required|scoped\",\n        // Regular expressions\n    // http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n    identifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n    attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n    \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5]\n    // or strings [capture 3 or capture 4]\"\n    \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n        pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n    // 1. quoted (capture 3; capture 4 or capture 5)\n    \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n    \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n    \".*\" + \")\\\\)|)\",\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n        rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n        rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n        rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n        rdescend = new RegExp(whitespace + \"|>\"),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n        matchExpr = {\n      \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n      \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n      \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n      \"ATTR\": new RegExp(\"^\" + attributes),\n      \"PSEUDO\": new RegExp(\"^\" + pseudos),\n      \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n      \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n      // For use in libraries implementing .is()\n      // We use this for POS matching in `select`\n      \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n    },\n        rhtml = /HTML$/i,\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rsibling = /[+~]/,\n        // CSS escapes\n    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\"),\n        funescape = function (escape, nonHex) {\n      var high = \"0x\" + escape.slice(1) - 0x10000;\n      return nonHex ? // Strip the backslash prefix from a non-hex escape sequence\n      nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point\n      // Support: IE <=11+\n      // For values outside the Basic Multilingual Plane (BMP), manually construct a\n      // surrogate pair\n      high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n    },\n        // CSS string/identifier serialization\n    // https://drafts.csswg.org/cssom/#common-serializing-idioms\n    rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n        fcssescape = function (ch, asCodePoint) {\n      if (asCodePoint) {\n        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n        if (ch === \"\\0\") {\n          return \"\\uFFFD\";\n        } // Control characters and (dependent upon position) numbers get escaped as code points\n\n\n        return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n      } // Other potentially-special ASCII characters get backslash-escaped\n\n\n      return \"\\\\\" + ch;\n    },\n        // Used for iframes\n    // See setDocument()\n    // Removing the function wrapper causes a \"Permission Denied\"\n    // error in IE\n    unloadHandler = function () {\n      setDocument();\n    },\n        inDisabledFieldset = addCombinator(function (elem) {\n      return elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n    }, {\n      dir: \"parentNode\",\n      next: \"legend\"\n    }); // Optimize for push.apply( _, NodeList )\n\n\n    try {\n      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n      // Detect silently failing push.apply\n      // eslint-disable-next-line no-unused-expressions\n\n      arr[preferredDoc.childNodes.length].nodeType;\n    } catch (e) {\n      push = {\n        apply: arr.length ? // Leverage slice if possible\n        function (target, els) {\n          pushNative.apply(target, slice.call(els));\n        } : // Support: IE<9\n        // Otherwise append directly\n        function (target, els) {\n          var j = target.length,\n              i = 0; // Can't trust NodeList.length\n\n          while (target[j++] = els[i++]) {}\n\n          target.length = j - 1;\n        }\n      };\n    }\n\n    function Sizzle(selector, context, results, seed) {\n      var m,\n          i,\n          elem,\n          nid,\n          match,\n          groups,\n          newSelector,\n          newContext = context && context.ownerDocument,\n          // nodeType defaults to 9, since context defaults to document\n      nodeType = context ? context.nodeType : 9;\n      results = results || []; // Return early from calls with invalid selector or context\n\n      if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return results;\n      } // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n      if (!seed) {\n        setDocument(context);\n        context = context || document;\n\n        if (documentIsHTML) {\n          // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n          // (excepting DocumentFragment context, where the methods don't exist)\n          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n            // ID selector\n            if (m = match[1]) {\n              // Document context\n              if (nodeType === 9) {\n                if (elem = context.getElementById(m)) {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } else {\n                  return results;\n                } // Element context\n\n              } else {\n                // Support: IE, Opera, Webkit\n                // TODO: identify versions\n                // getElementById can match elements by name instead of ID\n                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              } // Type selector\n\n            } else if (match[2]) {\n              push.apply(results, context.getElementsByTagName(selector));\n              return results; // Class selector\n            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n              push.apply(results, context.getElementsByClassName(m));\n              return results;\n            }\n          } // Take advantage of querySelectorAll\n\n\n          if (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only\n          // Exclude object elements\n          nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\")) {\n            newSelector = selector;\n            newContext = context; // qSA considers elements outside a scoping root when evaluating child or\n            // descendant combinators, which is not what we want.\n            // In such cases, we work around the behavior by prefixing every selector in the\n            // list with an ID selector referencing the scope context.\n            // The technique has to be used as well when a leading combinator is used\n            // as such selectors are not recognized by querySelectorAll.\n            // Thanks to Andrew Dupont for this technique.\n\n            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {\n              // Expand context for sibling selectors\n              newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser\n              // supports it & if we're not changing the context.\n\n              if (newContext !== context || !support.scope) {\n                // Capture the context ID, setting it first if necessary\n                if (nid = context.getAttribute(\"id\")) {\n                  nid = nid.replace(rcssescape, fcssescape);\n                } else {\n                  context.setAttribute(\"id\", nid = expando);\n                }\n              } // Prefix every selector in the list\n\n\n              groups = tokenize(selector);\n              i = groups.length;\n\n              while (i--) {\n                groups[i] = (nid ? \"#\" + nid : \":scope\") + \" \" + toSelector(groups[i]);\n              }\n\n              newSelector = groups.join(\",\");\n            }\n\n            try {\n              push.apply(results, newContext.querySelectorAll(newSelector));\n              return results;\n            } catch (qsaError) {\n              nonnativeSelectorCache(selector, true);\n            } finally {\n              if (nid === expando) {\n                context.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n      } // All others\n\n\n      return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n    }\n    /**\n     * Create key-value caches of limited size\n     * @returns {function(string, object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n\n\n    function createCache() {\n      var keys = [];\n\n      function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key + \" \") > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete cache[keys.shift()];\n        }\n\n        return cache[key + \" \"] = value;\n      }\n\n      return cache;\n    }\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n\n\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created element and returns a boolean result\n     */\n\n\n    function assert(fn) {\n      var el = document.createElement(\"fieldset\");\n\n      try {\n        return !!fn(el);\n      } catch (e) {\n        return false;\n      } finally {\n        // Remove from its parent by default\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        } // release memory in IE\n\n\n        el = null;\n      }\n    }\n    /**\n     * Adds the same handler for all of the specified attrs\n     * @param {String} attrs Pipe-separated list of attributes\n     * @param {Function} handler The method that will be applied\n     */\n\n\n    function addHandle(attrs, handler) {\n      var arr = attrs.split(\"|\"),\n          i = arr.length;\n\n      while (i--) {\n        Expr.attrHandle[arr[i]] = handler;\n      }\n    }\n    /**\n     * Checks document order of two siblings\n     * @param {Element} a\n     * @param {Element} b\n     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n     */\n\n\n    function siblingCheck(a, b) {\n      var cur = b && a,\n          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes\n\n      if (diff) {\n        return diff;\n      } // Check if b follows a\n\n\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n\n      return a ? 1 : -1;\n    }\n    /**\n     * Returns a function to use in pseudos for input types\n     * @param {String} type\n     */\n\n\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for buttons\n     * @param {String} type\n     */\n\n\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for :enabled/:disabled\n     * @param {Boolean} disabled true for :disabled; false for :enabled\n     */\n\n\n    function createDisabledPseudo(disabled) {\n      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n      return function (elem) {\n        // Only certain elements can match :enabled or :disabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n        if (\"form\" in elem) {\n          // Check for inherited disabledness on relevant non-disabled elements:\n          // * listed form-associated elements in a disabled fieldset\n          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n          // * option elements in a disabled optgroup\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n          // All such elements have a \"form\" property.\n          if (elem.parentNode && elem.disabled === false) {\n            // Option elements defer to a parent optgroup if present\n            if (\"label\" in elem) {\n              if (\"label\" in elem.parentNode) {\n                return elem.parentNode.disabled === disabled;\n              } else {\n                return elem.disabled === disabled;\n              }\n            } // Support: IE 6 - 11\n            // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\n\n            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n\n            /* jshint -W018 */\n            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n          }\n\n          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.\n          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n          // even exist on them, let alone have a boolean value.\n        } else if (\"label\" in elem) {\n          return elem.disabled === disabled;\n        } // Remaining elements are neither :enabled nor :disabled\n\n\n        return false;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for positionals\n     * @param {Function} fn\n     */\n\n\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length; // Match elements found at the specified indexes\n\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n    /**\n     * Checks a node for validity as a Sizzle context\n     * @param {Element|Object=} context\n     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n     */\n\n\n    function testContext(context) {\n      return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n    } // Expose support vars for convenience\n\n\n    support = Sizzle.support = {};\n    /**\n     * Detects XML nodes\n     * @param {Element|Object} elem An element or a document\n     * @returns {Boolean} True iff elem is a non-HTML XML node\n     */\n\n    isXML = Sizzle.isXML = function (elem) {\n      var namespace = elem.namespaceURI,\n          docElem = (elem.ownerDocument || elem).documentElement; // Support: IE <=8\n      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n      // https://bugs.jquery.com/ticket/4833\n\n      return !rhtml.test(namespace || docElem && docElem.nodeName || \"HTML\");\n    };\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n\n\n    setDocument = Sizzle.setDocument = function (node) {\n      var hasCompare,\n          subWindow,\n          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n\n      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      } // Update global variables\n\n\n      document = doc;\n      docElem = document.documentElement;\n      documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+\n      // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n\n      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n        // Support: IE 11, Edge\n        if (subWindow.addEventListener) {\n          subWindow.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n        } else if (subWindow.attachEvent) {\n          subWindow.attachEvent(\"onunload\", unloadHandler);\n        }\n      } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n      // Safari 4 - 5 only, Opera <=11.6 - 12.x only\n      // IE/Edge & older browsers don't support the :scope pseudo-class.\n      // Support: Safari 6.0 only\n      // Safari 6.0 supports :scope but it's an alias of :root there.\n\n\n      support.scope = assert(function (el) {\n        docElem.appendChild(el).appendChild(document.createElement(\"div\"));\n        return typeof el.querySelectorAll !== \"undefined\" && !el.querySelectorAll(\":scope fieldset div\").length;\n      });\n      /* Attributes\n      ---------------------------------------------------------------------- */\n      // Support: IE<8\n      // Verify that getAttribute really returns attributes and not properties\n      // (excepting IE8 booleans)\n\n      support.attributes = assert(function (el) {\n        el.className = \"i\";\n        return !el.getAttribute(\"className\");\n      });\n      /* getElement(s)By*\n      ---------------------------------------------------------------------- */\n      // Check if getElementsByTagName(\"*\") returns only elements\n\n      support.getElementsByTagName = assert(function (el) {\n        el.appendChild(document.createComment(\"\"));\n        return !el.getElementsByTagName(\"*\").length;\n      }); // Support: IE<9\n\n      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n      // Check if getElementById returns elements by name\n      // The broken getElementById methods don't pick up programmatically-set names,\n      // so use a roundabout getElementsByName test\n\n      support.getById = assert(function (el) {\n        docElem.appendChild(el).id = expando;\n        return !document.getElementsByName || !document.getElementsByName(expando).length;\n      }); // ID filter and find\n\n      if (support.getById) {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute(\"id\") === attrId;\n          };\n        };\n\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var elem = context.getElementById(id);\n            return elem ? [elem] : [];\n          }\n        };\n      } else {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n            return node && node.value === attrId;\n          };\n        }; // Support: IE 6 - 7 only\n        // getElementById is not reliable as a find shortcut\n\n\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var node,\n                i,\n                elems,\n                elem = context.getElementById(id);\n\n            if (elem) {\n              // Verify the id attribute\n              node = elem.getAttributeNode(\"id\");\n\n              if (node && node.value === id) {\n                return [elem];\n              } // Fall back on getElementsByName\n\n\n              elems = context.getElementsByName(id);\n              i = 0;\n\n              while (elem = elems[i++]) {\n                node = elem.getAttributeNode(\"id\");\n\n                if (node && node.value === id) {\n                  return [elem];\n                }\n              }\n            }\n\n            return [];\n          }\n        };\n      } // Tag\n\n\n      Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n        } else if (support.qsa) {\n          return context.querySelectorAll(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n            tmp = [],\n            i = 0,\n            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n        results = context.getElementsByTagName(tag); // Filter out possible comments\n\n        if (tag === \"*\") {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n\n          return tmp;\n        }\n\n        return results;\n      }; // Class\n\n      Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n        if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n          return context.getElementsByClassName(className);\n        }\n      };\n      /* QSA/matchesSelector\n      ---------------------------------------------------------------------- */\n      // QSA and matchesSelector support\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n      // We allow this because of a bug in IE8/9 that throws an error\n      // whenever `document.activeElement` is accessed on an iframe\n      // So, we allow :focus to pass through QSA all the time to avoid the IE error\n      // See https://bugs.jquery.com/ticket/13378\n\n      rbuggyQSA = [];\n\n      if (support.qsa = rnative.test(document.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (el) {\n          var input; // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explicitly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // https://bugs.jquery.com/ticket/12359\n\n          docElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"; // Support: IE8, Opera 11-12.16\n          // Nothing should be selected when empty strings follow ^= or $= or *=\n          // The test attribute must be unknown in Opera but \"safe\" for WinRT\n          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n          if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          } // Support: IE8\n          // Boolean attributes and \"value\" are not treated correctly\n\n\n          if (!el.querySelectorAll(\"[selected]\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n          if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n            rbuggyQSA.push(\"~=\");\n          } // Support: IE 11+, Edge 15 - 18+\n          // IE 11/Edge don't find elements on a `[name='']` query in some cases.\n          // Adding a temporary attribute to the document before the selection works\n          // around the issue.\n          // Interestingly, IE 10 & older don't seem to have the issue.\n\n\n          input = document.createElement(\"input\");\n          input.setAttribute(\"name\", \"\");\n          el.appendChild(input);\n\n          if (!el.querySelectorAll(\"[name='']\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          } // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n\n\n          if (!el.querySelectorAll(\":checked\").length) {\n            rbuggyQSA.push(\":checked\");\n          } // Support: Safari 8+, iOS 8+\n          // https://bugs.webkit.org/show_bug.cgi?id=136851\n          // In-page `selector#id sibling-combinator selector` fails\n\n\n          if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n            rbuggyQSA.push(\".#.+[+~]\");\n          } // Support: Firefox <=3.6 - 5 only\n          // Old Firefox doesn't throw on a badly-escaped identifier.\n\n\n          el.querySelectorAll(\"\\\\\\f\");\n          rbuggyQSA.push(\"[\\\\r\\\\n\\\\f]\");\n        });\n        assert(function (el) {\n          el.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\"; // Support: Windows 8 Native Apps\n          // The type and name attributes are restricted during .innerHTML assignment\n\n          var input = document.createElement(\"input\");\n          input.setAttribute(\"type\", \"hidden\");\n          el.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n          // Enforce case-sensitivity of name attribute\n\n          if (el.querySelectorAll(\"[name=d]\").length) {\n            rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n\n\n          if (el.querySelectorAll(\":enabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Support: IE9-11+\n          // IE's :disabled selector does not pick up the children of disabled fieldsets\n\n\n          docElem.appendChild(el).disabled = true;\n\n          if (el.querySelectorAll(\":disabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Support: Opera 10 - 11 only\n          // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n          el.querySelectorAll(\"*,:x\");\n          rbuggyQSA.push(\",.*:\");\n        });\n      }\n\n      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n        assert(function (el) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(el, \"*\"); // This should fail with an exception\n          // Gecko does not error, returns false instead\n\n          matches.call(el, \"[s!='']:x\");\n          rbuggyMatches.push(\"!=\", pseudos);\n        });\n      }\n\n      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n      /* Contains\n      ---------------------------------------------------------------------- */\n\n      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n      // Purposefully self-exclusive\n      // As in, an element does not contain itself\n\n      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      };\n      /* Sorting\n      ---------------------------------------------------------------------- */\n      // Document order sorting\n\n      sortOrder = hasCompare ? function (a, b) {\n        // Flag for duplicate removal\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        } // Sort on method existence if only one input has compareDocumentPosition\n\n\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n        if (compare) {\n          return compare;\n        } // Calculate position if both inputs belong to the same document\n        // Support: IE 11+, Edge 17 - 18+\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n        // two documents; shallow comparisons work.\n        // eslint-disable-next-line eqeqeq\n\n\n        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n        1; // Disconnected nodes\n\n        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n          // Choose the first element that is related to our preferred document\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {\n            return -1;\n          } // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n\n\n          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {\n            return 1;\n          } // Maintain original order\n\n\n          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n        }\n\n        return compare & 4 ? -1 : 1;\n      } : function (a, b) {\n        // Exit early if the nodes are identical\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [a],\n            bp = [b]; // Parentless nodes are either documents or disconnected\n\n        if (!aup || !bup) {\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n\n          /* eslint-disable eqeqeq */\n          return a == document ? -1 : b == document ? 1 :\n          /* eslint-enable eqeqeq */\n          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        } // Otherwise we need full lists of their ancestors for comparison\n\n\n        cur = a;\n\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n\n        cur = b;\n\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        } // Walk down the tree looking for a discrepancy\n\n\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n\n        return i ? // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n        // Support: IE 11+, Edge 17 - 18+\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n        // two documents; shallow comparisons work.\n\n        /* eslint-disable eqeqeq */\n        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :\n        /* eslint-enable eqeqeq */\n        0;\n      };\n      return document;\n    };\n\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n\n    Sizzle.matchesSelector = function (elem, expr) {\n      setDocument(elem);\n\n      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n        try {\n          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {\n          nonnativeSelectorCache(expr, true);\n        }\n      }\n\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n      if ((context.ownerDocument || context) != document) {\n        setDocument(context);\n      }\n\n      return contains(context, elem);\n    };\n\n    Sizzle.attr = function (elem, name) {\n      // Set document vars if needed\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n      if ((elem.ownerDocument || elem) != document) {\n        setDocument(elem);\n      }\n\n      var fn = Expr.attrHandle[name.toLowerCase()],\n          // Don't get fooled by Object.prototype properties (jQuery #13807)\n      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n    };\n\n    Sizzle.escape = function (sel) {\n      return (sel + \"\").replace(rcssescape, fcssescape);\n    };\n\n    Sizzle.error = function (msg) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n    };\n    /**\n     * Document sorting and removing duplicates\n     * @param {ArrayLike} results\n     */\n\n\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n          duplicates = [],\n          j = 0,\n          i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n      hasDuplicate = !support.detectDuplicates;\n      sortInput = !support.sortStable && results.slice(0);\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        while (elem = results[i++]) {\n          if (elem === results[i]) {\n            j = duplicates.push(i);\n          }\n        }\n\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      } // Clear input after sorting to release objects\n      // See https://github.com/jquery/sizzle/pull/225\n\n\n      sortInput = null;\n      return results;\n    };\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n\n\n    getText = Sizzle.getText = function (elem) {\n      var node,\n          ret = \"\",\n          i = 0,\n          nodeType = elem.nodeType;\n\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        while (node = elem[i++]) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (jQuery #11153)\n        if (typeof elem.textContent === \"string\") {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      } // Do not include comment or processing instruction nodes\n\n\n      return ret;\n    };\n\n    Expr = Sizzle.selectors = {\n      // Can be adjusted by the user\n      cacheLength: 50,\n      createPseudo: markFunction,\n      match: matchExpr,\n      attrHandle: {},\n      find: {},\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: true\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: true\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        \"ATTR\": function (match) {\n          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n          match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n          if (match[2] === \"~=\") {\n            match[3] = \" \" + match[3] + \" \";\n          }\n\n          return match.slice(0, 4);\n        },\n        \"CHILD\": function (match) {\n          /* matches from matchExpr[\"CHILD\"]\n          \t1 type (only|nth|...)\n          \t2 what (child|of-type)\n          \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n          \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n          \t5 sign of xn-component\n          \t6 x of xn-component\n          \t7 sign of y-component\n          \t8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n\n          if (match[1].slice(0, 3) === \"nth\") {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            } // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n\n\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n            match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n\n          return match;\n        },\n        \"PSEUDO\": function (match) {\n          var excess,\n              unquoted = !match[6] && match[2];\n\n          if (matchExpr[\"CHILD\"].test(match[0])) {\n            return null;\n          } // Accept quoted arguments as-is\n\n\n          if (match[3]) {\n            match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n          excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n          return match.slice(0, 3);\n        }\n      },\n      filter: {\n        \"TAG\": function (nodeNameSelector) {\n          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n          return nodeNameSelector === \"*\" ? function () {\n            return true;\n          } : function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n        \"CLASS\": function (className) {\n          var pattern = classCache[className + \" \"];\n          return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n            return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n          });\n        },\n        \"ATTR\": function (name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n\n            if (result == null) {\n              return operator === \"!=\";\n            }\n\n            if (!operator) {\n              return true;\n            }\n\n            result += \"\";\n            /* eslint-disable max-len */\n\n            return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n            /* eslint-enable max-len */\n          };\n        },\n        \"CHILD\": function (type, what, _argument, first, last) {\n          var simple = type.slice(0, 3) !== \"nth\",\n              forward = type.slice(-4) !== \"last\",\n              ofType = what === \"of-type\";\n          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, _context, xml) {\n            var cache,\n                uniqueCache,\n                outerCache,\n                node,\n                nodeIndex,\n                start,\n                dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                parent = elem.parentNode,\n                name = ofType && elem.nodeName.toLowerCase(),\n                useCache = !xml && !ofType,\n                diff = false;\n\n            if (parent) {\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                      return false;\n                    }\n                  } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                  start = dir = type === \"only\" && !start && \"nextSibling\";\n                }\n\n                return true;\n              }\n\n              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n              if (forward && useCache) {\n                // Seek `elem` from a previously-cached index\n                // ...in a gzip-friendly way\n                node = parent;\n                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n\n                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                cache = uniqueCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = nodeIndex && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n\n                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    uniqueCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                }\n              } else {\n                // Use previously-cached element index if available\n                if (useCache) {\n                  // ...in a gzip-friendly way\n                  node = elem;\n                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex;\n                } // xml :nth-child(...)\n                // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n                if (diff === false) {\n                  // Use the same loop as above to seek `elem` from the start\n                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                      // Cache the index of each encountered element\n                      if (useCache) {\n                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                        // Defend against cloned attroperties (jQuery gh-1709)\n\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                        uniqueCache[type] = [dirruns, diff];\n                      }\n\n                      if (node === elem) {\n                        break;\n                      }\n                    }\n                  }\n                }\n              } // Incorporate the offset, then check against cycle size\n\n\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n        \"PSEUDO\": function (pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n\n          if (fn[expando]) {\n            return fn(argument);\n          } // But maintain support for old signatures\n\n\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, \"\", argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                  matched = fn(seed, argument),\n                  i = matched.length;\n\n              while (i--) {\n                idx = indexOf(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n\n          return fn;\n        }\n      },\n      pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, \"$1\"));\n          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {\n            var elem,\n                unmatched = matcher(seed, null, xml, []),\n                i = seed.length; // Match elements unmatched by `matcher`\n\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, _context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n            input[0] = null;\n            return !results.pop();\n          };\n        }),\n        \"has\": markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n        \"contains\": markFunction(function (text) {\n          text = text.replace(runescape, funescape);\n          return function (elem) {\n            return (elem.textContent || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction(function (lang) {\n          // lang value must be a valid identifier\n          if (!ridentifier.test(lang || \"\")) {\n            Sizzle.error(\"unsupported lang: \" + lang);\n          }\n\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n\n            do {\n              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n            return false;\n          };\n        }),\n        // Miscellaneous\n        \"target\": function (elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n        \"root\": function (elem) {\n          return elem === docElem;\n        },\n        \"focus\": function (elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n        // Boolean properties\n        \"enabled\": createDisabledPseudo(false),\n        \"disabled\": createDisabledPseudo(true),\n        \"checked\": function (elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n        },\n        \"selected\": function (elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            // eslint-disable-next-line no-unused-expressions\n            elem.parentNode.selectedIndex;\n          }\n\n          return elem.selected === true;\n        },\n        // Contents\n        \"empty\": function (elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n          //   but not by others (comment: 8; processing instruction: 7; etc.)\n          // nodeType < 6 works because attributes (2) do not appear as children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeType < 6) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        \"parent\": function (elem) {\n          return !Expr.pseudos[\"empty\"](elem);\n        },\n        // Element/input types\n        \"header\": function (elem) {\n          return rheader.test(elem.nodeName);\n        },\n        \"input\": function (elem) {\n          return rinputs.test(elem.nodeName);\n        },\n        \"button\": function (elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n        \"text\": function (elem) {\n          var attr;\n          return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ( // Support: IE<8\n          // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n          (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n        },\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function () {\n          return [0];\n        }),\n        \"last\": createPositionalPseudo(function (_matchIndexes, length) {\n          return [length - 1];\n        }),\n        \"eq\": createPositionalPseudo(function (_matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n        \"even\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument > length ? length : argument;\n\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        })\n      }\n    };\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Add button/input type pseudos\n\n    for (i in {\n      radio: true,\n      checkbox: true,\n      file: true,\n      password: true,\n      image: true\n    }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n\n    for (i in {\n      submit: true,\n      reset: true\n    }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    } // Easy API for creating new setFilters\n\n\n    function setFilters() {}\n\n    setFilters.prototype = Expr.filters = Expr.pseudos;\n    Expr.setFilters = new setFilters();\n\n    tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n      var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + \" \"];\n\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n\n      while (soFar) {\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n\n          groups.push(tokens = []);\n        }\n\n        matched = false; // Combinators\n\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, \" \")\n          });\n          soFar = soFar.slice(matched.length);\n        } // Filters\n\n\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n\n        if (!matched) {\n          break;\n        }\n      } // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n\n\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    };\n\n    function toSelector(tokens) {\n      var i = 0,\n          len = tokens.length,\n          selector = \"\";\n\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n\n      return selector;\n    }\n\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n          skip = combinator.next,\n          key = skip || dir,\n          checkNonElements = base && key === \"parentNode\",\n          doneName = done++;\n      return combinator.first ? // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n\n        return false;\n      } : // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var oldCache,\n            uniqueCache,\n            outerCache,\n            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n              // Defend against cloned attroperties (jQuery gh-1709)\n\n              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n              if (skip && skip === elem.nodeName.toLowerCase()) {\n                elem = elem[dir] || elem;\n              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                // Assign to newCache so results back-propagate to previous elements\n                return newCache[2] = oldCache[2];\n              } else {\n                // Reuse newcache so results back-propagate to previous elements\n                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking\n\n                if (newCache[2] = matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n\n        return false;\n      };\n    }\n\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n\n        return true;\n      } : matchers[0];\n    }\n\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n          len = contexts.length;\n\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n\n      return results;\n    }\n\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null;\n\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n\n      return newUnmatched;\n    }\n\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n            // Get initial elements from seed or context\n        elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n        [] : // ...otherwise use results directly\n        results : matcherIn; // Find primary matches\n\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        } // Apply postFilter\n\n\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n          i = temp.length;\n\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n\n              postFinder(null, matcherOut = [], temp, xml);\n            } // Move matched elements from seed to results to keep them synchronized\n\n\n            i = matcherOut.length;\n\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          } // Add elements to results, through postFinder if defined\n\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n\n    function matcherFromTokens(tokens) {\n      var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[\" \"],\n          i = leadingRelative ? 1 : 0,\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\n      matchContext = addCombinator(function (elem) {\n        return elem === checkContext;\n      }, implicitRelative, true),\n          matchAnyContext = addCombinator(function (elem) {\n        return indexOf(checkContext, elem) > -1;\n      }, implicitRelative, true),\n          matchers = [function (elem, context, xml) {\n        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n        checkContext = null;\n        return ret;\n      }];\n\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n            tokens.slice(0, i - 1).concat({\n              value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n            })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n\n          matchers.push(matcher);\n        }\n      }\n\n      return elementMatcher(matchers);\n    }\n\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      var bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function (seed, context, xml, results, outermost) {\n        var elem,\n            j,\n            matcher,\n            matchedCount = 0,\n            i = \"0\",\n            unmatched = seed && [],\n            setMatched = [],\n            contextBackup = outermostContext,\n            // We must always have either seed elements or outermost context\n        elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n            // Use integer dirruns iff this is the outermost matcher\n        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n            len = elems.length;\n\n        if (outermost) {\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n          outermostContext = context == document || context || outermost;\n        } // Add elements passing elementMatchers directly to results\n        // Support: IE<9, Safari\n        // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n        for (; i !== len && (elem = elems[i]) != null; i++) {\n          if (byElement && elem) {\n            j = 0; // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n\n            if (!context && elem.ownerDocument != document) {\n              setDocument(elem);\n              xml = !documentIsHTML;\n            }\n\n            while (matcher = elementMatchers[j++]) {\n              if (matcher(elem, context || document, xml)) {\n                results.push(elem);\n                break;\n              }\n            }\n\n            if (outermost) {\n              dirruns = dirrunsUnique;\n            }\n          } // Track unmatched elements for set filters\n\n\n          if (bySet) {\n            // They will have gone through all possible matchers\n            if (elem = !matcher && elem) {\n              matchedCount--;\n            } // Lengthen the array for every element, matched or not\n\n\n            if (seed) {\n              unmatched.push(elem);\n            }\n          }\n        } // `i` is now the count of elements visited above, and adding it to `matchedCount`\n        // makes the latter nonnegative.\n\n\n        matchedCount += i; // Apply set filters to unmatched elements\n        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n        // no element matchers and no seed.\n        // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n        // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n        // numerically zero.\n\n        if (bySet && i !== matchedCount) {\n          j = 0;\n\n          while (matcher = setMatchers[j++]) {\n            matcher(unmatched, setMatched, context, xml);\n          }\n\n          if (seed) {\n            // Reintegrate element matches to eliminate the need for sorting\n            if (matchedCount > 0) {\n              while (i--) {\n                if (!(unmatched[i] || setMatched[i])) {\n                  setMatched[i] = pop.call(results);\n                }\n              }\n            } // Discard index placeholder values to get only actual matches\n\n\n            setMatched = condense(setMatched);\n          } // Add matches to results\n\n\n          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n            Sizzle.uniqueSort(results);\n          }\n        } // Override manipulation of globals by nested matchers\n\n\n        if (outermost) {\n          dirruns = dirrunsUnique;\n          outermostContext = contextBackup;\n        }\n\n        return unmatched;\n      };\n\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n\n    compile = Sizzle.compile = function (selector, match\n    /* Internal Use Only */\n    ) {\n      var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + \" \"];\n\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!match) {\n          match = tokenize(selector);\n        }\n\n        i = match.length;\n\n        while (i--) {\n          cached = matcherFromTokens(match[i]);\n\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        } // Cache the compiled function\n\n\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n        cached.selector = selector;\n      }\n\n      return cached;\n    };\n    /**\n     * A low-level selection function that works with Sizzle's compiled\n     *  selector functions\n     * @param {String|Function} selector A selector or a pre-compiled\n     *  selector function built with Sizzle.compile\n     * @param {Element} context\n     * @param {Array} [results]\n     * @param {Array} [seed] A set of elements to match against\n     */\n\n\n    select = Sizzle.select = function (selector, context, results, seed) {\n      var i,\n          tokens,\n          token,\n          type,\n          find,\n          compiled = typeof selector === \"function\" && selector,\n          match = !seed && tokenize(selector = compiled.selector || selector);\n      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n      // (the latter of which guarantees us context)\n\n      if (match.length === 1) {\n        // Reduce context if the leading compound selector is an ID\n        tokens = match[0] = match[0].slice(0);\n\n        if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n          context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n          if (!context) {\n            return results; // Precompiled matchers will still verify ancestry, so step up a level\n          } else if (compiled) {\n            context = context.parentNode;\n          }\n\n          selector = selector.slice(tokens.shift().value.length);\n        } // Fetch a seed set for right-to-left matching\n\n\n        i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n        while (i--) {\n          token = tokens[i]; // Abort if we hit a combinator\n\n          if (Expr.relative[type = token.type]) {\n            break;\n          }\n\n          if (find = Expr.find[type]) {\n            // Search, expanding context for leading sibling combinators\n            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n              // If seed is empty or no tokens remain, we can return early\n              tokens.splice(i, 1);\n              selector = seed.length && toSelector(tokens);\n\n              if (!selector) {\n                push.apply(results, seed);\n                return results;\n              }\n\n              break;\n            }\n          }\n        }\n      } // Compile and execute a filtering function if one is not provided\n      // Provide `match` to avoid retokenization if we modified the selector above\n\n\n      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n      return results;\n    }; // One-time assignments\n    // Sort stability\n\n\n    support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n    // Always assume duplicates if they aren't passed to the comparison function\n\n    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n    // Detached nodes confoundingly follow *each other*\n\n    support.sortDetached = assert(function (el) {\n      // Should return 1, but returns 4 (following)\n      return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n    }); // Support: IE<8\n    // Prevent attribute/property \"interpolation\"\n    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n    if (!assert(function (el) {\n      el.innerHTML = \"<a href='#'></a>\";\n      return el.firstChild.getAttribute(\"href\") === \"#\";\n    })) {\n      addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n        if (!isXML) {\n          return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n        }\n      });\n    } // Support: IE<9\n    // Use defaultValue in place of getAttribute(\"value\")\n\n\n    if (!support.attributes || !assert(function (el) {\n      el.innerHTML = \"<input/>\";\n      el.firstChild.setAttribute(\"value\", \"\");\n      return el.firstChild.getAttribute(\"value\") === \"\";\n    })) {\n      addHandle(\"value\", function (elem, _name, isXML) {\n        if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n          return elem.defaultValue;\n        }\n      });\n    } // Support: IE<9\n    // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n    if (!assert(function (el) {\n      return el.getAttribute(\"disabled\") == null;\n    })) {\n      addHandle(booleans, function (elem, name, isXML) {\n        var val;\n\n        if (!isXML) {\n          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n        }\n      });\n    }\n\n    return Sizzle;\n  }(window);\n\n  jQuery.find = Sizzle;\n  jQuery.expr = Sizzle.selectors; // Deprecated\n\n  jQuery.expr[\":\"] = jQuery.expr.pseudos;\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n  jQuery.text = Sizzle.getText;\n  jQuery.isXMLDoc = Sizzle.isXML;\n  jQuery.contains = Sizzle.contains;\n  jQuery.escapeSelector = Sizzle.escape;\n\n  var dir = function (elem, dir, until) {\n    var matched = [],\n        truncate = until !== undefined;\n\n    while ((elem = elem[dir]) && elem.nodeType !== 9) {\n      if (elem.nodeType === 1) {\n        if (truncate && jQuery(elem).is(until)) {\n          break;\n        }\n\n        matched.push(elem);\n      }\n    }\n\n    return matched;\n  };\n\n  var siblings = function (n, elem) {\n    var matched = [];\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== elem) {\n        matched.push(n);\n      }\n    }\n\n    return matched;\n  };\n\n  var rneedsContext = jQuery.expr.match.needsContext;\n\n  function nodeName(elem, name) {\n    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n  }\n\n  ;\n  var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i; // Implement the identical functionality for filter and not\n\n  function winnow(elements, qualifier, not) {\n    if (isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        return !!qualifier.call(elem, i, elem) !== not;\n      });\n    } // Single element\n\n\n    if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier !== not;\n      });\n    } // Arraylike of elements (jQuery, arguments, Array)\n\n\n    if (typeof qualifier !== \"string\") {\n      return jQuery.grep(elements, function (elem) {\n        return indexOf.call(qualifier, elem) > -1 !== not;\n      });\n    } // Filtered directly for both simple and complex selectors\n\n\n    return jQuery.filter(qualifier, elements, not);\n  }\n\n  jQuery.filter = function (expr, elems, not) {\n    var elem = elems[0];\n\n    if (not) {\n      expr = \":not(\" + expr + \")\";\n    }\n\n    if (elems.length === 1 && elem.nodeType === 1) {\n      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\n    }\n\n    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n      return elem.nodeType === 1;\n    }));\n  };\n\n  jQuery.fn.extend({\n    find: function (selector) {\n      var i,\n          ret,\n          len = this.length,\n          self = this;\n\n      if (typeof selector !== \"string\") {\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n\n      ret = this.pushStack([]);\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, self[i], ret);\n      }\n\n      return len > 1 ? jQuery.uniqueSort(ret) : ret;\n    },\n    filter: function (selector) {\n      return this.pushStack(winnow(this, selector || [], false));\n    },\n    not: function (selector) {\n      return this.pushStack(winnow(this, selector || [], true));\n    },\n    is: function (selector) {\n      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n    }\n  }); // Initialize a jQuery object\n  // A central reference to the root jQuery(document)\n\n  var rootjQuery,\n      // A simple way to check for HTML strings\n  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n  // Strict HTML recognition (#11290: must start with <)\n  // Shortcut simple #id case for speed\n  rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n      init = jQuery.fn.init = function (selector, context, root) {\n    var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\n    if (!selector) {\n      return this;\n    } // Method init() accepts an alternate rootjQuery\n    // so migrate can support jQuery.sub (gh-2101)\n\n\n    root = root || rootjQuery; // Handle HTML strings\n\n    if (typeof selector === \"string\") {\n      if (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n        // Assume that strings that start and end with <> are HTML and skip the regex check\n        match = [null, selector, null];\n      } else {\n        match = rquickExpr.exec(selector);\n      } // Match html or make sure no context is specified for #id\n\n\n      if (match && (match[1] || !context)) {\n        // HANDLE: $(html) -> $(array)\n        if (match[1]) {\n          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat\n          // Intentionally let the error be thrown if parseHTML is not present\n\n          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)\n\n          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n            for (match in context) {\n              // Properties of context are called as methods if possible\n              if (isFunction(this[match])) {\n                this[match](context[match]); // ...and otherwise set as attributes\n              } else {\n                this.attr(match, context[match]);\n              }\n            }\n          }\n\n          return this; // HANDLE: $(#id)\n        } else {\n          elem = document.getElementById(match[2]);\n\n          if (elem) {\n            // Inject the element directly into the jQuery object\n            this[0] = elem;\n            this.length = 1;\n          }\n\n          return this;\n        } // HANDLE: $(expr, $(...))\n\n      } else if (!context || context.jquery) {\n        return (context || root).find(selector); // HANDLE: $(expr, context)\n        // (which is just equivalent to: $(context).find(expr)\n      } else {\n        return this.constructor(context).find(selector);\n      } // HANDLE: $(DOMElement)\n\n    } else if (selector.nodeType) {\n      this[0] = selector;\n      this.length = 1;\n      return this; // HANDLE: $(function)\n      // Shortcut for document ready\n    } else if (isFunction(selector)) {\n      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present\n      selector(jQuery);\n    }\n\n    return jQuery.makeArray(selector, this);\n  }; // Give the init function the jQuery prototype for later instantiation\n\n\n  init.prototype = jQuery.fn; // Initialize central reference\n\n  rootjQuery = jQuery(document);\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n      // Methods guaranteed to produce a unique set when starting from a unique set\n  guaranteedUnique = {\n    children: true,\n    contents: true,\n    next: true,\n    prev: true\n  };\n  jQuery.fn.extend({\n    has: function (target) {\n      var targets = jQuery(target, this),\n          l = targets.length;\n      return this.filter(function () {\n        var i = 0;\n\n        for (; i < l; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n    closest: function (selectors, context) {\n      var cur,\n          i = 0,\n          l = this.length,\n          matched = [],\n          targets = typeof selectors !== \"string\" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context\n\n      if (!rneedsContext.test(selectors)) {\n        for (; i < l; i++) {\n          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n            // Always skip document fragments\n            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle\n            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n              matched.push(cur);\n              break;\n            }\n          }\n        }\n      }\n\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n    },\n    // Determine the position of an element within the set\n    index: function (elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      } // Index in selector\n\n\n      if (typeof elem === \"string\") {\n        return indexOf.call(jQuery(elem), this[0]);\n      } // Locate the position of the desired element\n\n\n      return indexOf.call(this, // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem);\n    },\n    add: function (selector, context) {\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n    },\n    addBack: function (selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n\n  function sibling(cur, dir) {\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\n    return cur;\n  }\n\n  jQuery.each({\n    parent: function (elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function (elem) {\n      return dir(elem, \"parentNode\");\n    },\n    parentsUntil: function (elem, _i, until) {\n      return dir(elem, \"parentNode\", until);\n    },\n    next: function (elem) {\n      return sibling(elem, \"nextSibling\");\n    },\n    prev: function (elem) {\n      return sibling(elem, \"previousSibling\");\n    },\n    nextAll: function (elem) {\n      return dir(elem, \"nextSibling\");\n    },\n    prevAll: function (elem) {\n      return dir(elem, \"previousSibling\");\n    },\n    nextUntil: function (elem, _i, until) {\n      return dir(elem, \"nextSibling\", until);\n    },\n    prevUntil: function (elem, _i, until) {\n      return dir(elem, \"previousSibling\", until);\n    },\n    siblings: function (elem) {\n      return siblings((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function (elem) {\n      return siblings(elem.firstChild);\n    },\n    contents: function (elem) {\n      if (elem.contentDocument != null && // Support: IE 11+\n      // <object> elements with no `data` attribute has an object\n      // `contentDocument` with a `null` prototype.\n      getProto(elem.contentDocument)) {\n        return elem.contentDocument;\n      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n      // Treat the template element as a regular one in browsers that\n      // don't support it.\n\n\n      if (nodeName(elem, \"template\")) {\n        elem = elem.content || elem;\n      }\n\n      return jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var matched = jQuery.map(this, fn, until);\n\n      if (name.slice(-5) !== \"Until\") {\n        selector = until;\n      }\n\n      if (selector && typeof selector === \"string\") {\n        matched = jQuery.filter(selector, matched);\n      }\n\n      if (this.length > 1) {\n        // Remove duplicates\n        if (!guaranteedUnique[name]) {\n          jQuery.uniqueSort(matched);\n        } // Reverse order for parents* and prev-derivatives\n\n\n        if (rparentsprev.test(name)) {\n          matched.reverse();\n        }\n      }\n\n      return this.pushStack(matched);\n    };\n  });\n  var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g; // Convert String-formatted options into Object-formatted ones\n\n  function createOptions(options) {\n    var object = {};\n    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n        // Last fire value for non-forgettable lists\n    memory,\n        // Flag to know if list was already fired\n    fired,\n        // Flag to prevent firing\n    locked,\n        // Actual callback list\n    list = [],\n        // Queue of execution data for repeatable lists\n    queue = [],\n        // Index of currently firing callback (modified by add/remove as needed)\n    firingIndex = -1,\n        // Fire callbacks\n    fire = function () {\n      // Enforce single-firing\n      locked = locked || options.once; // Execute callbacks for all pending executions,\n      // respecting firingIndex overrides and runtime changes\n\n      fired = firing = true;\n\n      for (; queue.length; firingIndex = -1) {\n        memory = queue.shift();\n\n        while (++firingIndex < list.length) {\n          // Run callback and check for early termination\n          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n            // Jump to end and forget the data so .add doesn't re-fire\n            firingIndex = list.length;\n            memory = false;\n          }\n        }\n      } // Forget the data if we're done with it\n\n\n      if (!options.memory) {\n        memory = false;\n      }\n\n      firing = false; // Clean up if we're done firing for good\n\n      if (locked) {\n        // Keep an empty list if we have data for future add calls\n        if (memory) {\n          list = []; // Otherwise, this object is spent\n        } else {\n          list = \"\";\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function () {\n        if (list) {\n          // If we have memory from a past run, we should fire after adding\n          if (memory && !firing) {\n            firingIndex = list.length - 1;\n            queue.push(memory);\n          }\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              if (isFunction(arg)) {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && toType(arg) !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments);\n\n          if (memory && !firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function () {\n        jQuery.each(arguments, function (_, arg) {\n          var index;\n\n          while ((index = jQuery.inArray(arg, list, index)) > -1) {\n            list.splice(index, 1); // Handle firing indexes\n\n            if (index <= firingIndex) {\n              firingIndex--;\n            }\n          }\n        });\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function (fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n      },\n      // Remove all callbacks from the list\n      empty: function () {\n        if (list) {\n          list = [];\n        }\n\n        return this;\n      },\n      // Disable .fire and .add\n      // Abort any current/pending executions\n      // Clear all callbacks and values\n      disable: function () {\n        locked = queue = [];\n        list = memory = \"\";\n        return this;\n      },\n      disabled: function () {\n        return !list;\n      },\n      // Disable .fire\n      // Also disable .add unless we have memory (since it would have no effect)\n      // Abort any pending executions\n      lock: function () {\n        locked = queue = [];\n\n        if (!memory && !firing) {\n          list = memory = \"\";\n        }\n\n        return this;\n      },\n      locked: function () {\n        return !!locked;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function (context, args) {\n        if (!locked) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n          queue.push(args);\n\n          if (!firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function () {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function () {\n        return !!fired;\n      }\n    };\n\n    return self;\n  };\n\n  function Identity(v) {\n    return v;\n  }\n\n  function Thrower(ex) {\n    throw ex;\n  }\n\n  function adoptValue(value, resolve, reject, noValue) {\n    var method;\n\n    try {\n      // Check for promise aspect first to privilege synchronous behavior\n      if (value && isFunction(method = value.promise)) {\n        method.call(value).done(resolve).fail(reject); // Other thenables\n      } else if (value && isFunction(method = value.then)) {\n        method.call(value, resolve, reject); // Other non-thenables\n      } else {\n        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n        // * false: [ value ].slice( 0 ) => resolve( value )\n        // * true: [ value ].slice( 1 ) => resolve()\n        resolve.apply(undefined, [value].slice(noValue));\n      } // For Promises/A+, convert exceptions into rejections\n      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n      // Deferred#then to conditionally suppress rejection.\n\n    } catch (value) {\n      // Support: Android 4.0 only\n      // Strict mode functions invoked without .call/.apply get global-object context\n      reject.apply(undefined, [value]);\n    }\n  }\n\n  jQuery.extend({\n    Deferred: function (func) {\n      var tuples = [// action, add listener, callbacks,\n      // ... .then handlers, argument index, [final state]\n      [\"notify\", \"progress\", jQuery.Callbacks(\"memory\"), jQuery.Callbacks(\"memory\"), 2], [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 0, \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 1, \"rejected\"]],\n          state = \"pending\",\n          promise = {\n        state: function () {\n          return state;\n        },\n        always: function () {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        \"catch\": function (fn) {\n          return promise.then(null, fn);\n        },\n        // Keep pipe for back-compat\n        pipe: function ()\n        /* fnDone, fnFail, fnProgress */\n        {\n          var fns = arguments;\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (_i, tuple) {\n              // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })\n              // deferred.done(function() { bind to newDefer or newDefer.resolve })\n              // deferred.fail(function() { bind to newDefer or newDefer.reject })\n\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n\n                if (returned && isFunction(returned.promise)) {\n                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                } else {\n                  newDefer[tuple[0] + \"With\"](this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        then: function (onFulfilled, onRejected, onProgress) {\n          var maxDepth = 0;\n\n          function resolve(depth, deferred, handler, special) {\n            return function () {\n              var that = this,\n                  args = arguments,\n                  mightThrow = function () {\n                var returned, then; // Support: Promises/A+ section 2.3.3.3.3\n                // https://promisesaplus.com/#point-59\n                // Ignore double-resolution attempts\n\n                if (depth < maxDepth) {\n                  return;\n                }\n\n                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1\n                // https://promisesaplus.com/#point-48\n\n                if (returned === deferred.promise()) {\n                  throw new TypeError(\"Thenable self-resolution\");\n                } // Support: Promises/A+ sections 2.3.3.1, 3.5\n                // https://promisesaplus.com/#point-54\n                // https://promisesaplus.com/#point-75\n                // Retrieve `then` only once\n\n\n                then = returned && ( // Support: Promises/A+ section 2.3.4\n                // https://promisesaplus.com/#point-64\n                // Only check objects and functions for thenability\n                typeof returned === \"object\" || typeof returned === \"function\") && returned.then; // Handle a returned thenable\n\n                if (isFunction(then)) {\n                  // Special processors (notify) just wait for resolution\n                  if (special) {\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress\n                  } else {\n                    // ...and disregard older resolution values\n                    maxDepth++;\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                  } // Handle all other returned values\n\n                } else {\n                  // Only substitute handlers pass on context\n                  // and multiple values (non-spec behavior)\n                  if (handler !== Identity) {\n                    that = undefined;\n                    args = [returned];\n                  } // Process the value(s)\n                  // Default process is resolve\n\n\n                  (special || deferred.resolveWith)(that, args);\n                }\n              },\n                  // Only normal processors (resolve) catch and reject exceptions\n              process = special ? mightThrow : function () {\n                try {\n                  mightThrow();\n                } catch (e) {\n                  if (jQuery.Deferred.exceptionHook) {\n                    jQuery.Deferred.exceptionHook(e, process.stackTrace);\n                  } // Support: Promises/A+ section 2.3.3.3.4.1\n                  // https://promisesaplus.com/#point-61\n                  // Ignore post-resolution exceptions\n\n\n                  if (depth + 1 >= maxDepth) {\n                    // Only substitute handlers pass on context\n                    // and multiple values (non-spec behavior)\n                    if (handler !== Thrower) {\n                      that = undefined;\n                      args = [e];\n                    }\n\n                    deferred.rejectWith(that, args);\n                  }\n                }\n              }; // Support: Promises/A+ section 2.3.3.3.1\n              // https://promisesaplus.com/#point-57\n              // Re-resolve promises immediately to dodge false rejection from\n              // subsequent errors\n\n\n              if (depth) {\n                process();\n              } else {\n                // Call an optional hook to record the stack, in case of exception\n                // since it's otherwise lost when execution goes async\n                if (jQuery.Deferred.getStackHook) {\n                  process.stackTrace = jQuery.Deferred.getStackHook();\n                }\n\n                window.setTimeout(process);\n              }\n            };\n          }\n\n          return jQuery.Deferred(function (newDefer) {\n            // progress_handlers.add( ... )\n            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )\n\n            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )\n\n            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n          }).promise();\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function (obj) {\n          return obj != null ? jQuery.extend(obj, promise) : promise;\n        }\n      },\n          deferred = {}; // Add list-specific methods\n\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[5]; // promise.progress = list.add\n        // promise.done = list.add\n        // promise.fail = list.add\n\n        promise[tuple[1]] = list.add; // Handle state\n\n        if (stateString) {\n          list.add(function () {\n            // state = \"resolved\" (i.e., fulfilled)\n            // state = \"rejected\"\n            state = stateString;\n          }, // rejected_callbacks.disable\n          // fulfilled_callbacks.disable\n          tuples[3 - i][2].disable, // rejected_handlers.disable\n          // fulfilled_handlers.disable\n          tuples[3 - i][3].disable, // progress_callbacks.lock\n          tuples[0][2].lock, // progress_handlers.lock\n          tuples[0][3].lock);\n        } // progress_handlers.fire\n        // fulfilled_handlers.fire\n        // rejected_handlers.fire\n\n\n        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }\n        // deferred.resolve = function() { deferred.resolveWith(...) }\n        // deferred.reject = function() { deferred.rejectWith(...) }\n\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n          return this;\n        }; // deferred.notifyWith = list.fireWith\n        // deferred.resolveWith = list.fireWith\n        // deferred.rejectWith = list.fireWith\n\n\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      }); // Make the deferred a promise\n\n      promise.promise(deferred); // Call given func if any\n\n      if (func) {\n        func.call(deferred, deferred);\n      } // All done!\n\n\n      return deferred;\n    },\n    // Deferred helper\n    when: function (singleValue) {\n      var // count of uncompleted subordinates\n      remaining = arguments.length,\n          // count of unprocessed arguments\n      i = remaining,\n          // subordinate fulfillment data\n      resolveContexts = Array(i),\n          resolveValues = slice.call(arguments),\n          // the master Deferred\n      master = jQuery.Deferred(),\n          // subordinate callback factory\n      updateFunc = function (i) {\n        return function (value) {\n          resolveContexts[i] = this;\n          resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;\n\n          if (! --remaining) {\n            master.resolveWith(resolveContexts, resolveValues);\n          }\n        };\n      }; // Single- and empty arguments are adopted like Promise.resolve\n\n\n      if (remaining <= 1) {\n        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)\n\n        if (master.state() === \"pending\" || isFunction(resolveValues[i] && resolveValues[i].then)) {\n          return master.then();\n        }\n      } // Multiple arguments are aggregated like Promise.all array elements\n\n\n      while (i--) {\n        adoptValue(resolveValues[i], updateFunc(i), master.reject);\n      }\n\n      return master.promise();\n    }\n  }); // These usually indicate a programmer mistake during development,\n  // warn about them ASAP rather than swallowing them by default.\n\n  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\n  jQuery.Deferred.exceptionHook = function (error, stack) {\n    // Support: IE 8 - 9 only\n    // Console exists when dev tools are open, which can happen at any time\n    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\n      window.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, stack);\n    }\n  };\n\n  jQuery.readyException = function (error) {\n    window.setTimeout(function () {\n      throw error;\n    });\n  }; // The deferred used on DOM ready\n\n\n  var readyList = jQuery.Deferred();\n\n  jQuery.fn.ready = function (fn) {\n    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup\n    // happens at the time of error handling instead of callback\n    // registration.\n    .catch(function (error) {\n      jQuery.readyException(error);\n    });\n    return this;\n  };\n\n  jQuery.extend({\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n    // Handle when the DOM is ready\n    ready: function (wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      } // Remember that the DOM is ready\n\n\n      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be\n\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      } // If there are functions bound, to execute\n\n\n      readyList.resolveWith(document, [jQuery]);\n    }\n  });\n  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method\n\n  function completed() {\n    document.removeEventListener(\"DOMContentLoaded\", completed);\n    window.removeEventListener(\"load\", completed);\n    jQuery.ready();\n  } // Catch cases where $(document).ready() is called\n  // after the browser event has already occurred.\n  // Support: IE <=9 - 10 only\n  // Older IE sometimes signals \"interactive\" too soon\n\n\n  if (document.readyState === \"complete\" || document.readyState !== \"loading\" && !document.documentElement.doScroll) {\n    // Handle it asynchronously to allow scripts the opportunity to delay ready\n    window.setTimeout(jQuery.ready);\n  } else {\n    // Use the handy event callback\n    document.addEventListener(\"DOMContentLoaded\", completed); // A fallback to window.onload, that will always work\n\n    window.addEventListener(\"load\", completed);\n  } // Multifunctional method to get and set values of a collection\n  // The value/s can optionally be executed if it's a function\n\n\n  var access = function (elems, fn, key, value, chainable, emptyGet, raw) {\n    var i = 0,\n        len = elems.length,\n        bulk = key == null; // Sets many values\n\n    if (toType(key) === \"object\") {\n      chainable = true;\n\n      for (i in key) {\n        access(elems, fn, i, key[i], true, emptyGet, raw);\n      } // Sets one value\n\n    } else if (value !== undefined) {\n      chainable = true;\n\n      if (!isFunction(value)) {\n        raw = true;\n      }\n\n      if (bulk) {\n        // Bulk operations run against the entire set\n        if (raw) {\n          fn.call(elems, value);\n          fn = null; // ...except when executing function values\n        } else {\n          bulk = fn;\n\n          fn = function (elem, _key, value) {\n            return bulk.call(jQuery(elem), value);\n          };\n        }\n      }\n\n      if (fn) {\n        for (; i < len; i++) {\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n        }\n      }\n    }\n\n    if (chainable) {\n      return elems;\n    } // Gets\n\n\n    if (bulk) {\n      return fn.call(elems);\n    }\n\n    return len ? fn(elems[0], key) : emptyGet;\n  }; // Matches dashed string for camelizing\n\n\n  var rmsPrefix = /^-ms-/,\n      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()\n\n  function fcamelCase(_all, letter) {\n    return letter.toUpperCase();\n  } // Convert dashed to camelCase; used by the css and data modules\n  // Support: IE <=9 - 11, Edge 12 - 15\n  // Microsoft forgot to hump their vendor prefix (#9572)\n\n\n  function camelCase(string) {\n    return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n  }\n\n  var acceptData = function (owner) {\n    // Accepts only:\n    //  - Node\n    //    - Node.ELEMENT_NODE\n    //    - Node.DOCUMENT_NODE\n    //  - Object\n    //    - Any\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n  };\n\n  function Data() {\n    this.expando = jQuery.expando + Data.uid++;\n  }\n\n  Data.uid = 1;\n  Data.prototype = {\n    cache: function (owner) {\n      // Check if the owner object already has a cache\n      var value = owner[this.expando]; // If not, create one\n\n      if (!value) {\n        value = {}; // We can accept data for non-element nodes in modern browsers,\n        // but we should not, see #8335.\n        // Always return an empty object.\n\n        if (acceptData(owner)) {\n          // If it is a node unlikely to be stringify-ed or looped over\n          // use plain assignment\n          if (owner.nodeType) {\n            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property\n            // configurable must be true to allow the property to be\n            // deleted when data is removed\n          } else {\n            Object.defineProperty(owner, this.expando, {\n              value: value,\n              configurable: true\n            });\n          }\n        }\n      }\n\n      return value;\n    },\n    set: function (owner, data, value) {\n      var prop,\n          cache = this.cache(owner); // Handle: [ owner, key, value ] args\n      // Always use camelCase key (gh-2257)\n\n      if (typeof data === \"string\") {\n        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args\n      } else {\n        // Copy the properties one-by-one to the cache object\n        for (prop in data) {\n          cache[camelCase(prop)] = data[prop];\n        }\n      }\n\n      return cache;\n    },\n    get: function (owner, key) {\n      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)\n      owner[this.expando] && owner[this.expando][camelCase(key)];\n    },\n    access: function (owner, key, value) {\n      // In cases where either:\n      //\n      //   1. No key was specified\n      //   2. A string key was specified, but no value provided\n      //\n      // Take the \"read\" path and allow the get method to determine\n      // which value to return, respectively either:\n      //\n      //   1. The entire cache object\n      //   2. The data stored at the key\n      //\n      if (key === undefined || key && typeof key === \"string\" && value === undefined) {\n        return this.get(owner, key);\n      } // When the key is not a string, or both a key and value\n      // are specified, set or extend (existing objects) with either:\n      //\n      //   1. An object of properties\n      //   2. A key and value\n      //\n\n\n      this.set(owner, key, value); // Since the \"set\" path can have two possible entry points\n      // return the expected data based on which path was taken[*]\n\n      return value !== undefined ? value : key;\n    },\n    remove: function (owner, key) {\n      var i,\n          cache = owner[this.expando];\n\n      if (cache === undefined) {\n        return;\n      }\n\n      if (key !== undefined) {\n        // Support array or space separated string of keys\n        if (Array.isArray(key)) {\n          // If key is an array of keys...\n          // We always set camelCase keys, so remove that.\n          key = key.map(camelCase);\n        } else {\n          key = camelCase(key); // If a key with the spaces exists, use it.\n          // Otherwise, create an array by matching non-whitespace\n\n          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];\n        }\n\n        i = key.length;\n\n        while (i--) {\n          delete cache[key[i]];\n        }\n      } // Remove the expando if there's no more data\n\n\n      if (key === undefined || jQuery.isEmptyObject(cache)) {\n        // Support: Chrome <=35 - 45\n        // Webkit & Blink performance suffers when deleting properties\n        // from DOM nodes, so set to undefined instead\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n        if (owner.nodeType) {\n          owner[this.expando] = undefined;\n        } else {\n          delete owner[this.expando];\n        }\n      }\n    },\n    hasData: function (owner) {\n      var cache = owner[this.expando];\n      return cache !== undefined && !jQuery.isEmptyObject(cache);\n    }\n  };\n  var dataPriv = new Data();\n  var dataUser = new Data(); //\tImplementation Summary\n  //\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n  //\t2. Improve the module's maintainability by reducing the storage\n  //\t\tpaths to a single mechanism.\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      rmultiDash = /[A-Z]/g;\n\n  function getData(data) {\n    if (data === \"true\") {\n      return true;\n    }\n\n    if (data === \"false\") {\n      return false;\n    }\n\n    if (data === \"null\") {\n      return null;\n    } // Only convert to a number if it doesn't change the string\n\n\n    if (data === +data + \"\") {\n      return +data;\n    }\n\n    if (rbrace.test(data)) {\n      return JSON.parse(data);\n    }\n\n    return data;\n  }\n\n  function dataAttr(elem, key, data) {\n    var name; // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n\n    if (data === undefined && elem.nodeType === 1) {\n      name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n      data = elem.getAttribute(name);\n\n      if (typeof data === \"string\") {\n        try {\n          data = getData(data);\n        } catch (e) {} // Make sure we set the data so it isn't changed later\n\n\n        dataUser.set(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n\n    return data;\n  }\n\n  jQuery.extend({\n    hasData: function (elem) {\n      return dataUser.hasData(elem) || dataPriv.hasData(elem);\n    },\n    data: function (elem, name, data) {\n      return dataUser.access(elem, name, data);\n    },\n    removeData: function (elem, name) {\n      dataUser.remove(elem, name);\n    },\n    // TODO: Now that all calls to _data and _removeData have been replaced\n    // with direct calls to dataPriv methods, these can be deprecated.\n    _data: function (elem, name, data) {\n      return dataPriv.access(elem, name, data);\n    },\n    _removeData: function (elem, name) {\n      dataPriv.remove(elem, name);\n    }\n  });\n  jQuery.fn.extend({\n    data: function (key, value) {\n      var i,\n          name,\n          data,\n          elem = this[0],\n          attrs = elem && elem.attributes; // Gets all values\n\n      if (key === undefined) {\n        if (this.length) {\n          data = dataUser.get(elem);\n\n          if (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\n            i = attrs.length;\n\n            while (i--) {\n              // Support: IE 11 only\n              // The attrs elements can be null (#14894)\n              if (attrs[i]) {\n                name = attrs[i].name;\n\n                if (name.indexOf(\"data-\") === 0) {\n                  name = camelCase(name.slice(5));\n                  dataAttr(elem, name, data[name]);\n                }\n              }\n            }\n\n            dataPriv.set(elem, \"hasDataAttrs\", true);\n          }\n        }\n\n        return data;\n      } // Sets multiple values\n\n\n      if (typeof key === \"object\") {\n        return this.each(function () {\n          dataUser.set(this, key);\n        });\n      }\n\n      return access(this, function (value) {\n        var data; // The calling jQuery object (element matches) is not empty\n        // (and therefore has an element appears at this[ 0 ]) and the\n        // `value` parameter was not undefined. An empty jQuery object\n        // will result in `undefined` for elem = this[ 0 ] which will\n        // throw an exception if an attempt to read a data cache is made.\n\n        if (elem && value === undefined) {\n          // Attempt to get data from the cache\n          // The key will always be camelCased in Data\n          data = dataUser.get(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // Attempt to \"discover\" the data in\n          // HTML5 custom data-* attrs\n\n\n          data = dataAttr(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // We tried really hard, but the data doesn't exist.\n\n\n          return;\n        } // Set the data...\n\n\n        this.each(function () {\n          // We always store the camelCased key\n          dataUser.set(this, key, value);\n        });\n      }, null, value, arguments.length > 1, null, true);\n    },\n    removeData: function (key) {\n      return this.each(function () {\n        dataUser.remove(this, key);\n      });\n    }\n  });\n  jQuery.extend({\n    queue: function (elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n        if (data) {\n          if (!queue || Array.isArray(data)) {\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n\n        return queue || [];\n      }\n    },\n    dequeue: function (elem, type) {\n      type = type || \"fx\";\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function () {\n        jQuery.dequeue(elem, type);\n      }; // If the fx queue is dequeued, always remove the progress sentinel\n\n\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        } // Clear up the last queue stop function\n\n\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // Not public - generate a queueHooks object, or return the current one\n    _queueHooks: function (elem, type) {\n      var key = type + \"queueHooks\";\n      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          dataPriv.remove(elem, [type + \"queue\", key]);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function (type, data) {\n      var setter = 2;\n\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue\n\n        jQuery._queueHooks(this, type);\n\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function (type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    clearQueue: function (type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function (type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function () {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n\n      type = type || \"fx\";\n\n      while (i--) {\n        tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n  var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n  var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n  var documentElement = document.documentElement;\n\n  var isAttached = function (elem) {\n    return jQuery.contains(elem.ownerDocument, elem);\n  },\n      composed = {\n    composed: true\n  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n  // Check attachment across shadow DOM boundaries when possible (gh-3504)\n  // Support: iOS 10.0-10.2 only\n  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n  // leading to errors. We need to check for `getRootNode`.\n\n\n  if (documentElement.getRootNode) {\n    isAttached = function (elem) {\n      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;\n    };\n  }\n\n  var isHiddenWithinTree = function (elem, el) {\n    // isHiddenWithinTree might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem; // Inline style trumps all\n\n    return elem.style.display === \"none\" || elem.style.display === \"\" && // Otherwise, check computed style\n    // Support: Firefox <=43 - 45\n    // Disconnected elements can have computed display: none, so first confirm that elem is\n    // in the document.\n    isAttached(elem) && jQuery.css(elem, \"display\") === \"none\";\n  };\n\n  function adjustCSS(elem, prop, valueParts, tween) {\n    var adjusted,\n        scale,\n        maxIterations = 20,\n        currentValue = tween ? function () {\n      return tween.cur();\n    } : function () {\n      return jQuery.css(elem, prop, \"\");\n    },\n        initial = currentValue(),\n        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n        // Starting value computation is required for potential unit mismatches\n    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n\n    if (initialInUnit && initialInUnit[3] !== unit) {\n      // Support: Firefox <=54\n      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n      initial = initial / 2; // Trust units reported by jQuery.css\n\n      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point\n\n      initialInUnit = +initial || 1;\n\n      while (maxIterations--) {\n        // Evaluate and update our best guess (doubling guesses that zero out).\n        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n        jQuery.style(elem, prop, initialInUnit + unit);\n\n        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\n          maxIterations = 0;\n        }\n\n        initialInUnit = initialInUnit / scale;\n      }\n\n      initialInUnit = initialInUnit * 2;\n      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on\n\n      valueParts = valueParts || [];\n    }\n\n    if (valueParts) {\n      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified\n\n      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n\n      if (tween) {\n        tween.unit = unit;\n        tween.start = initialInUnit;\n        tween.end = adjusted;\n      }\n    }\n\n    return adjusted;\n  }\n\n  var defaultDisplayMap = {};\n\n  function getDefaultDisplay(elem) {\n    var temp,\n        doc = elem.ownerDocument,\n        nodeName = elem.nodeName,\n        display = defaultDisplayMap[nodeName];\n\n    if (display) {\n      return display;\n    }\n\n    temp = doc.body.appendChild(doc.createElement(nodeName));\n    display = jQuery.css(temp, \"display\");\n    temp.parentNode.removeChild(temp);\n\n    if (display === \"none\") {\n      display = \"block\";\n    }\n\n    defaultDisplayMap[nodeName] = display;\n    return display;\n  }\n\n  function showHide(elements, show) {\n    var display,\n        elem,\n        values = [],\n        index = 0,\n        length = elements.length; // Determine new display value for elements that need to change\n\n    for (; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      display = elem.style.display;\n\n      if (show) {\n        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n        // check is required in this first loop unless we have a nonempty display value (either\n        // inline or about-to-be-restored)\n        if (display === \"none\") {\n          values[index] = dataPriv.get(elem, \"display\") || null;\n\n          if (!values[index]) {\n            elem.style.display = \"\";\n          }\n        }\n\n        if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n          values[index] = getDefaultDisplay(elem);\n        }\n      } else {\n        if (display !== \"none\") {\n          values[index] = \"none\"; // Remember what we're overwriting\n\n          dataPriv.set(elem, \"display\", display);\n        }\n      }\n    } // Set the display of the elements in a second loop to avoid constant reflow\n\n\n    for (index = 0; index < length; index++) {\n      if (values[index] != null) {\n        elements[index].style.display = values[index];\n      }\n    }\n\n    return elements;\n  }\n\n  jQuery.fn.extend({\n    show: function () {\n      return showHide(this, true);\n    },\n    hide: function () {\n      return showHide(this);\n    },\n    toggle: function (state) {\n      if (typeof state === \"boolean\") {\n        return state ? this.show() : this.hide();\n      }\n\n      return this.each(function () {\n        if (isHiddenWithinTree(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n  var rcheckableType = /^(?:checkbox|radio)$/i;\n  var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;\n  var rscriptType = /^$|^module$|\\/(?:java|ecma)script/i;\n\n  (function () {\n    var fragment = document.createDocumentFragment(),\n        div = fragment.appendChild(document.createElement(\"div\")),\n        input = document.createElement(\"input\"); // Support: Android 4.0 - 4.3 only\n    // Check state lost if the name is set (#11217)\n    // Support: Windows Web Apps (WWA)\n    // `name` and `type` must use .setAttribute for WWA (#14901)\n\n    input.setAttribute(\"type\", \"radio\");\n    input.setAttribute(\"checked\", \"checked\");\n    input.setAttribute(\"name\", \"t\");\n    div.appendChild(input); // Support: Android <=4.1 only\n    // Older WebKit doesn't clone checked state correctly in fragments\n\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\n\n    div.innerHTML = \"<textarea>x</textarea>\";\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only\n    // IE <=9 replaces <option> tags with their contents when inserted outside of\n    // the select element.\n\n    div.innerHTML = \"<option></option>\";\n    support.option = !!div.lastChild;\n  })(); // We have to close these tags to support XHTML (#13200)\n\n\n  var wrapMap = {\n    // XHTML parsers do not magically insert elements in the\n    // same way that tag soup parsers do. So we cannot shorten\n    // this by omitting <tbody> or other required elements.\n    thead: [1, \"<table>\", \"</table>\"],\n    col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    _default: [0, \"\", \"\"]\n  };\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td; // Support: IE <=9 only\n\n  if (!support.option) {\n    wrapMap.optgroup = wrapMap.option = [1, \"<select multiple='multiple'>\", \"</select>\"];\n  }\n\n  function getAll(context, tag) {\n    // Support: IE <=9 - 11 only\n    // Use typeof to avoid zero-argument method invocation on host objects (#15151)\n    var ret;\n\n    if (typeof context.getElementsByTagName !== \"undefined\") {\n      ret = context.getElementsByTagName(tag || \"*\");\n    } else if (typeof context.querySelectorAll !== \"undefined\") {\n      ret = context.querySelectorAll(tag || \"*\");\n    } else {\n      ret = [];\n    }\n\n    if (tag === undefined || tag && nodeName(context, tag)) {\n      return jQuery.merge([context], ret);\n    }\n\n    return ret;\n  } // Mark scripts as having already been evaluated\n\n\n  function setGlobalEval(elems, refElements) {\n    var i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      dataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\n    }\n  }\n\n  var rhtml = /<|&#?\\w+;/;\n\n  function buildFragment(elems, context, scripts, selection, ignored) {\n    var elem,\n        tmp,\n        tag,\n        wrap,\n        attached,\n        j,\n        fragment = context.createDocumentFragment(),\n        nodes = [],\n        i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      elem = elems[i];\n\n      if (elem || elem === 0) {\n        // Add nodes directly\n        if (toType(elem) === \"object\") {\n          // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node\n        } else if (!rhtml.test(elem)) {\n          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes\n        } else {\n          tmp = tmp || fragment.appendChild(context.createElement(\"div\")); // Deserialize a standard representation\n\n          tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n          wrap = wrapMap[tag] || wrapMap._default;\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content\n\n          j = wrap[0];\n\n          while (j--) {\n            tmp = tmp.lastChild;\n          } // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n\n\n          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container\n\n          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)\n\n          tmp.textContent = \"\";\n        }\n      }\n    } // Remove wrapper from fragment\n\n\n    fragment.textContent = \"\";\n    i = 0;\n\n    while (elem = nodes[i++]) {\n      // Skip elements already in the context collection (trac-4087)\n      if (selection && jQuery.inArray(elem, selection) > -1) {\n        if (ignored) {\n          ignored.push(elem);\n        }\n\n        continue;\n      }\n\n      attached = isAttached(elem); // Append to fragment\n\n      tmp = getAll(fragment.appendChild(elem), \"script\"); // Preserve script evaluation history\n\n      if (attached) {\n        setGlobalEval(tmp);\n      } // Capture executables\n\n\n      if (scripts) {\n        j = 0;\n\n        while (elem = tmp[j++]) {\n          if (rscriptType.test(elem.type || \"\")) {\n            scripts.push(elem);\n          }\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  var rkeyEvent = /^key/,\n      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  } // Support: IE <=9 - 11+\n  // focus() and blur() are asynchronous, except when they are no-op.\n  // So expect focus to be synchronous when the element is already active,\n  // and blur to be synchronous when the element is not already active.\n  // (focus and blur are always synchronous in other supported browsers,\n  // this just defines when we can count on it).\n\n\n  function expectSync(elem, type) {\n    return elem === safeActiveElement() === (type === \"focus\");\n  } // Support: IE <=9 only\n  // Accessing document.activeElement can throw unexpectedly\n  // https://bugs.jquery.com/ticket/13393\n\n\n  function safeActiveElement() {\n    try {\n      return document.activeElement;\n    } catch (err) {}\n  }\n\n  function on(elem, types, selector, data, fn, one) {\n    var origFn, type; // Types can be a map of types/handlers\n\n    if (typeof types === \"object\") {\n      // ( types-Object, selector, data )\n      if (typeof selector !== \"string\") {\n        // ( types-Object, data )\n        data = data || selector;\n        selector = undefined;\n      }\n\n      for (type in types) {\n        on(elem, type, selector, data, types[type], one);\n      }\n\n      return elem;\n    }\n\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector;\n      data = selector = undefined;\n    } else if (fn == null) {\n      if (typeof selector === \"string\") {\n        // ( types, selector, fn )\n        fn = data;\n        data = undefined;\n      } else {\n        // ( types, data, fn )\n        fn = data;\n        data = selector;\n        selector = undefined;\n      }\n    }\n\n    if (fn === false) {\n      fn = returnFalse;\n    } else if (!fn) {\n      return elem;\n    }\n\n    if (one === 1) {\n      origFn = fn;\n\n      fn = function (event) {\n        // Can use an empty set, since event contains the info\n        jQuery().off(event);\n        return origFn.apply(this, arguments);\n      }; // Use same guid so caller can remove using origFn\n\n\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n    }\n\n    return elem.each(function () {\n      jQuery.event.add(this, types, fn, data, selector);\n    });\n  }\n  /*\n   * Helper functions for managing events -- not part of the public interface.\n   * Props to Dean Edwards' addEvent library for many of the ideas.\n   */\n\n\n  jQuery.event = {\n    global: {},\n    add: function (elem, types, handler, data, selector) {\n      var handleObjIn,\n          eventHandle,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.get(elem); // Only attach events to objects that accept data\n\n      if (!acceptData(elem)) {\n        return;\n      } // Caller can pass in an object of custom data in lieu of the handler\n\n\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      } // Ensure that invalid selectors throw exceptions at attach time\n      // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\n\n      if (selector) {\n        jQuery.find.matchesSelector(documentElement, selector);\n      } // Make sure that the handler has a unique ID, used to find/remove it later\n\n\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      } // Init the element's event structure and main handler, if this is the first\n\n\n      if (!(events = elemData.events)) {\n        events = elemData.events = Object.create(null);\n      }\n\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n        };\n      } // Handle multiple events separated by a space\n\n\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // There *must* be a type, no attaching namespace-only handlers\n\n        if (!type) {\n          continue;\n        } // If event changes its type, use the special event handlers for the changed type\n\n\n        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type\n\n        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type\n\n        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers\n\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join(\".\")\n        }, handleObjIn); // Init the event handler queue if we're the first\n\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false\n\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle);\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj);\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        } // Add to the element's handler list, delegates in front\n\n\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        } // Keep track of which events have ever been used, for event optimization\n\n\n        jQuery.event.global[type] = true;\n      }\n    },\n    // Detach an event or set of events from an element\n    remove: function (elem, types, handler, selector, mappedTypes) {\n      var j,\n          origCount,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      } // Once for each type.namespace in types; type may be omitted\n\n\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // Unbind all events (on this namespace, if provided) for the element\n\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n\n          continue;\n        }\n\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"); // Remove matching events\n\n        origCount = j = handlers.length;\n\n        while (j--) {\n          handleObj = handlers[j];\n\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n            handlers.splice(j, 1);\n\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        } // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n\n\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n\n          delete events[type];\n        }\n      } // Remove data and the expando if it's no longer used\n\n\n      if (jQuery.isEmptyObject(events)) {\n        dataPriv.remove(elem, \"handle events\");\n      }\n    },\n    dispatch: function (nativeEvent) {\n      var i,\n          j,\n          ret,\n          matched,\n          handleObj,\n          handlerQueue,\n          args = new Array(arguments.length),\n          // Make a writable jQuery.Event from the native event object\n      event = jQuery.event.fix(nativeEvent),\n          handlers = (dataPriv.get(this, \"events\") || Object.create(null))[event.type] || [],\n          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event\n\n      args[0] = event;\n\n      for (i = 1; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n\n      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired\n\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      } // Determine handlers\n\n\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us\n\n      i = 0;\n\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        j = 0;\n\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // If the event is namespaced, then each handler is only invoked if it is\n          // specially universal or its namespaces are a superset of the event's.\n          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      } // Call the postDispatch hook for the mapped type\n\n\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n\n      return event.result;\n    },\n    handlers: function (event, handlers) {\n      var i,\n          handleObj,\n          sel,\n          matchedHandlers,\n          matchedSelectors,\n          handlerQueue = [],\n          delegateCount = handlers.delegateCount,\n          cur = event.target; // Find delegate handlers\n\n      if (delegateCount && // Support: IE <=9\n      // Black-hole SVG <use> instance trees (trac-13180)\n      cur.nodeType && // Support: Firefox <=42\n      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n      // Support: IE 11 only\n      // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n      !(event.type === \"click\" && event.button >= 1)) {\n        for (; cur !== this; cur = cur.parentNode || this) {\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\n            matchedHandlers = [];\n            matchedSelectors = {};\n\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = handlers[i]; // Don't conflict with Object.prototype properties (#13203)\n\n              sel = handleObj.selector + \" \";\n\n              if (matchedSelectors[sel] === undefined) {\n                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;\n              }\n\n              if (matchedSelectors[sel]) {\n                matchedHandlers.push(handleObj);\n              }\n            }\n\n            if (matchedHandlers.length) {\n              handlerQueue.push({\n                elem: cur,\n                handlers: matchedHandlers\n              });\n            }\n          }\n        }\n      } // Add the remaining (directly-bound) handlers\n\n\n      cur = this;\n\n      if (delegateCount < handlers.length) {\n        handlerQueue.push({\n          elem: cur,\n          handlers: handlers.slice(delegateCount)\n        });\n      }\n\n      return handlerQueue;\n    },\n    addProp: function (name, hook) {\n      Object.defineProperty(jQuery.Event.prototype, name, {\n        enumerable: true,\n        configurable: true,\n        get: isFunction(hook) ? function () {\n          if (this.originalEvent) {\n            return hook(this.originalEvent);\n          }\n        } : function () {\n          if (this.originalEvent) {\n            return this.originalEvent[name];\n          }\n        },\n        set: function (value) {\n          Object.defineProperty(this, name, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        }\n      });\n    },\n    fix: function (originalEvent) {\n      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n    },\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      click: {\n        // Utilize native event to ensure correct state for checkable inputs\n        setup: function (data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data; // Claim the first handler\n\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            // dataPriv.set( el, \"click\", ... )\n            leverageNative(el, \"click\", returnTrue);\n          } // Return false to allow normal processing in the caller\n\n\n          return false;\n        },\n        trigger: function (data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data; // Force setup before triggering a click\n\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            leverageNative(el, \"click\");\n          } // Return non-false to allow normal event-path propagation\n\n\n          return true;\n        },\n        // For cross-browser consistency, suppress native .click() on links\n        // Also prevent it if we're currently inside a leveraged native-event stack\n        _default: function (event) {\n          var target = event.target;\n          return rcheckableType.test(target.type) && target.click && nodeName(target, \"input\") && dataPriv.get(target, \"click\") || nodeName(target, \"a\");\n        }\n      },\n      beforeunload: {\n        postDispatch: function (event) {\n          // Support: Firefox 20+\n          // Firefox doesn't alert if the returnValue field is not set.\n          if (event.result !== undefined && event.originalEvent) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    }\n  }; // Ensure the presence of an event listener that handles manually-triggered\n  // synthetic events by interrupting progress until reinvoked in response to\n  // *native* events that it fires directly, ensuring that state changes have\n  // already occurred before other listeners are invoked.\n\n  function leverageNative(el, type, expectSync) {\n    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n    if (!expectSync) {\n      if (dataPriv.get(el, type) === undefined) {\n        jQuery.event.add(el, type, returnTrue);\n      }\n\n      return;\n    } // Register the controller as a special universal handler for all event namespaces\n\n\n    dataPriv.set(el, type, false);\n    jQuery.event.add(el, type, {\n      namespace: false,\n      handler: function (event) {\n        var notAsync,\n            result,\n            saved = dataPriv.get(this, type);\n\n        if (event.isTrigger & 1 && this[type]) {\n          // Interrupt processing of the outer synthetic .trigger()ed event\n          // Saved data should be false in such cases, but might be a leftover capture object\n          // from an async native handler (gh-4350)\n          if (!saved.length) {\n            // Store arguments for use when handling the inner native event\n            // There will always be at least one argument (an event object), so this array\n            // will not be confused with a leftover capture object.\n            saved = slice.call(arguments);\n            dataPriv.set(this, type, saved); // Trigger the native event and capture its result\n            // Support: IE <=9 - 11+\n            // focus() and blur() are asynchronous\n\n            notAsync = expectSync(this, type);\n            this[type]();\n            result = dataPriv.get(this, type);\n\n            if (saved !== result || notAsync) {\n              dataPriv.set(this, type, false);\n            } else {\n              result = {};\n            }\n\n            if (saved !== result) {\n              // Cancel the outer synthetic event\n              event.stopImmediatePropagation();\n              event.preventDefault();\n              return result.value;\n            } // If this is an inner synthetic event for an event with a bubbling surrogate\n            // (focus or blur), assume that the surrogate already propagated from triggering the\n            // native event and prevent that from happening again here.\n            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n            // bubbling surrogate propagates *after* the non-bubbling base), but that seems\n            // less bad than duplication.\n\n          } else if ((jQuery.event.special[type] || {}).delegateType) {\n            event.stopPropagation();\n          } // If this is a native event triggered above, everything is now in order\n          // Fire an inner synthetic event with the original arguments\n\n        } else if (saved.length) {\n          // ...and capture the result\n          dataPriv.set(this, type, {\n            value: jQuery.event.trigger( // Support: IE <=9 - 11+\n            // Extend with the prototype to reset the above stopImmediatePropagation()\n            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)\n          }); // Abort handling of the native event\n\n          event.stopImmediatePropagation();\n        }\n      }\n    });\n  }\n\n  jQuery.removeEvent = function (elem, type, handle) {\n    // This \"if\" is needed for plain objects\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle);\n    }\n  };\n\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    } // Event object\n\n\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type; // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n\n      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only\n      src.returnValue === false ? returnTrue : returnFalse; // Create target properties\n      // Support: Safari <=6 - 7 only\n      // Target should not be a text node (#504, #13143)\n\n      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n      this.currentTarget = src.currentTarget;\n      this.relatedTarget = src.relatedTarget; // Event type\n    } else {\n      this.type = src;\n    } // Put explicitly provided properties onto the event object\n\n\n    if (props) {\n      jQuery.extend(this, props);\n    } // Create a timestamp if incoming event doesn't have one\n\n\n    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed\n\n    this[jQuery.expando] = true;\n  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  jQuery.Event.prototype = {\n    constructor: jQuery.Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    isSimulated: false,\n    preventDefault: function () {\n      var e = this.originalEvent;\n      this.isDefaultPrevented = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function () {\n      var e = this.originalEvent;\n      this.isPropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function () {\n      var e = this.originalEvent;\n      this.isImmediatePropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopImmediatePropagation();\n      }\n\n      this.stopPropagation();\n    }\n  }; // Includes all common event props including KeyEvent and MouseEvent specific props\n\n  jQuery.each({\n    altKey: true,\n    bubbles: true,\n    cancelable: true,\n    changedTouches: true,\n    ctrlKey: true,\n    detail: true,\n    eventPhase: true,\n    metaKey: true,\n    pageX: true,\n    pageY: true,\n    shiftKey: true,\n    view: true,\n    \"char\": true,\n    code: true,\n    charCode: true,\n    key: true,\n    keyCode: true,\n    button: true,\n    buttons: true,\n    clientX: true,\n    clientY: true,\n    offsetX: true,\n    offsetY: true,\n    pointerId: true,\n    pointerType: true,\n    screenX: true,\n    screenY: true,\n    targetTouches: true,\n    toElement: true,\n    touches: true,\n    which: function (event) {\n      var button = event.button; // Add which for key events\n\n      if (event.which == null && rkeyEvent.test(event.type)) {\n        return event.charCode != null ? event.charCode : event.keyCode;\n      } // Add which for click: 1 === left; 2 === middle; 3 === right\n\n\n      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {\n        if (button & 1) {\n          return 1;\n        }\n\n        if (button & 2) {\n          return 3;\n        }\n\n        if (button & 4) {\n          return 2;\n        }\n\n        return 0;\n      }\n\n      return event.which;\n    }\n  }, jQuery.event.addProp);\n  jQuery.each({\n    focus: \"focusin\",\n    blur: \"focusout\"\n  }, function (type, delegateType) {\n    jQuery.event.special[type] = {\n      // Utilize native event if possible so blur/focus sequence is correct\n      setup: function () {\n        // Claim the first handler\n        // dataPriv.set( this, \"focus\", ... )\n        // dataPriv.set( this, \"blur\", ... )\n        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller\n\n        return false;\n      },\n      trigger: function () {\n        // Force setup before trigger\n        leverageNative(this, type); // Return non-false to allow normal event-path propagation\n\n        return true;\n      },\n      delegateType: delegateType\n    };\n  }); // Create mouseenter/leave events using mouseover/out and event-time checks\n  // so that event delegation works in jQuery.\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\n  //\n  // Support: Safari 7 only\n  // Safari sends mouseenter too often; see:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n  // for the description of the bug (it existed in older Chrome versions as well).\n\n  jQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\",\n    pointerenter: \"pointerover\",\n    pointerleave: \"pointerout\"\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n      handle: function (event) {\n        var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n\n        return ret;\n      }\n    };\n  });\n  jQuery.fn.extend({\n    on: function (types, selector, data, fn) {\n      return on(this, types, selector, data, fn);\n    },\n    one: function (types, selector, data, fn) {\n      return on(this, types, selector, data, fn, 1);\n    },\n    off: function (types, selector, fn) {\n      var handleObj, type;\n\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n\n      if (typeof types === \"object\") {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n\n        return this;\n      }\n\n      if (selector === false || typeof selector === \"function\") {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      }\n\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    }\n  });\n  var // Support: IE <=10 - 11, Edge 12 - 13 only\n  // In IE/Edge using regex groups here causes severe slowdowns.\n  // See https://connect.microsoft.com/IE/feedback/details/1736512/\n  rnoInnerhtml = /<script|<style|<link/i,\n      // checked=\"checked\" or checked\n  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g; // Prefer a tbody over its parent table for containing new rows\n\n  function manipulationTarget(elem, content) {\n    if (nodeName(elem, \"table\") && nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\n      return jQuery(elem).children(\"tbody\")[0] || elem;\n    }\n\n    return elem;\n  } // Replace/restore the type attribute of script elements for safe DOM manipulation\n\n\n  function disableScript(elem) {\n    elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n    return elem;\n  }\n\n  function restoreScript(elem) {\n    if ((elem.type || \"\").slice(0, 5) === \"true/\") {\n      elem.type = elem.type.slice(5);\n    } else {\n      elem.removeAttribute(\"type\");\n    }\n\n    return elem;\n  }\n\n  function cloneCopyEvent(src, dest) {\n    var i, l, type, pdataOld, udataOld, udataCur, events;\n\n    if (dest.nodeType !== 1) {\n      return;\n    } // 1. Copy private data: events, handlers, etc.\n\n\n    if (dataPriv.hasData(src)) {\n      pdataOld = dataPriv.get(src);\n      events = pdataOld.events;\n\n      if (events) {\n        dataPriv.remove(dest, \"handle events\");\n\n        for (type in events) {\n          for (i = 0, l = events[type].length; i < l; i++) {\n            jQuery.event.add(dest, type, events[type][i]);\n          }\n        }\n      }\n    } // 2. Copy user data\n\n\n    if (dataUser.hasData(src)) {\n      udataOld = dataUser.access(src);\n      udataCur = jQuery.extend({}, udataOld);\n      dataUser.set(dest, udataCur);\n    }\n  } // Fix IE bugs, see support tests\n\n\n  function fixInput(src, dest) {\n    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.\n\n    if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options\n    } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n\n  function domManip(collection, args, callback, ignored) {\n    // Flatten any nested arrays\n    args = flat(args);\n    var fragment,\n        first,\n        scripts,\n        hasScripts,\n        node,\n        doc,\n        i = 0,\n        l = collection.length,\n        iNoClone = l - 1,\n        value = args[0],\n        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit\n\n    if (valueIsFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n      return collection.each(function (index) {\n        var self = collection.eq(index);\n\n        if (valueIsFunction) {\n          args[0] = value.call(this, index, self.html());\n        }\n\n        domManip(self, args, callback, ignored);\n      });\n    }\n\n    if (l) {\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n      first = fragment.firstChild;\n\n      if (fragment.childNodes.length === 1) {\n        fragment = first;\n      } // Require either new content or an interest in ignored elements to invoke the callback\n\n\n      if (first || ignored) {\n        scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n        hasScripts = scripts.length; // Use the original fragment for the last item\n        // instead of the first because it can end up\n        // being emptied incorrectly in certain situations (#8070).\n\n        for (; i < l; i++) {\n          node = fragment;\n\n          if (i !== iNoClone) {\n            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration\n\n            if (hasScripts) {\n              // Support: Android <=4.0 only, PhantomJS 1 only\n              // push.apply(_, arraylike) throws on ancient WebKit\n              jQuery.merge(scripts, getAll(node, \"script\"));\n            }\n          }\n\n          callback.call(collection[i], node, i);\n        }\n\n        if (hasScripts) {\n          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts\n\n          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion\n\n          for (i = 0; i < hasScripts; i++) {\n            node = scripts[i];\n\n            if (rscriptType.test(node.type || \"\") && !dataPriv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n              if (node.src && (node.type || \"\").toLowerCase() !== \"module\") {\n                // Optional AJAX dependency, but won't run scripts if not present\n                if (jQuery._evalUrl && !node.noModule) {\n                  jQuery._evalUrl(node.src, {\n                    nonce: node.nonce || node.getAttribute(\"nonce\")\n                  }, doc);\n                }\n              } else {\n                DOMEval(node.textContent.replace(rcleanScript, \"\"), node, doc);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return collection;\n  }\n\n  function remove(elem, selector, keepData) {\n    var node,\n        nodes = selector ? jQuery.filter(selector, elem) : elem,\n        i = 0;\n\n    for (; (node = nodes[i]) != null; i++) {\n      if (!keepData && node.nodeType === 1) {\n        jQuery.cleanData(getAll(node));\n      }\n\n      if (node.parentNode) {\n        if (keepData && isAttached(node)) {\n          setGlobalEval(getAll(node, \"script\"));\n        }\n\n        node.parentNode.removeChild(node);\n      }\n    }\n\n    return elem;\n  }\n\n  jQuery.extend({\n    htmlPrefilter: function (html) {\n      return html;\n    },\n    clone: function (elem, dataAndEvents, deepDataAndEvents) {\n      var i,\n          l,\n          srcElements,\n          destElements,\n          clone = elem.cloneNode(true),\n          inPage = isAttached(elem); // Fix IE cloning issues\n\n      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem);\n\n        for (i = 0, l = srcElements.length; i < l; i++) {\n          fixInput(srcElements[i], destElements[i]);\n        }\n      } // Copy the events from the original to the clone\n\n\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n\n          for (i = 0, l = srcElements.length; i < l; i++) {\n            cloneCopyEvent(srcElements[i], destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      } // Preserve script evaluation history\n\n\n      destElements = getAll(clone, \"script\");\n\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n      } // Return the cloned set\n\n\n      return clone;\n    },\n    cleanData: function (elems) {\n      var data,\n          elem,\n          type,\n          special = jQuery.event.special,\n          i = 0;\n\n      for (; (elem = elems[i]) !== undefined; i++) {\n        if (acceptData(elem)) {\n          if (data = elem[dataPriv.expando]) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            } // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n\n\n            elem[dataPriv.expando] = undefined;\n          }\n\n          if (elem[dataUser.expando]) {\n            // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataUser.expando] = undefined;\n          }\n        }\n      }\n    }\n  });\n  jQuery.fn.extend({\n    detach: function (selector) {\n      return remove(this, selector, true);\n    },\n    remove: function (selector) {\n      return remove(this, selector);\n    },\n    text: function (value) {\n      return access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().each(function () {\n          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n            this.textContent = value;\n          }\n        });\n      }, null, value, arguments.length);\n    },\n    append: function () {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.appendChild(elem);\n        }\n      });\n    },\n    prepend: function () {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.insertBefore(elem, target.firstChild);\n        }\n      });\n    },\n    before: function () {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n    after: function () {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n    empty: function () {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        if (elem.nodeType === 1) {\n          // Prevent memory leaks\n          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes\n\n          elem.textContent = \"\";\n        }\n      }\n\n      return this;\n    },\n    clone: function (dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n    html: function (value) {\n      return access(this, function (value) {\n        var elem = this[0] || {},\n            i = 0,\n            l = this.length;\n\n        if (value === undefined && elem.nodeType === 1) {\n          return elem.innerHTML;\n        } // See if we can take a shortcut and just use innerHTML\n\n\n        if (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n          value = jQuery.htmlPrefilter(value);\n\n          try {\n            for (; i < l; i++) {\n              elem = this[i] || {}; // Remove element nodes and prevent memory leaks\n\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n\n            elem = 0; // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n    replaceWith: function () {\n      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content\n\n      return domManip(this, arguments, function (elem) {\n        var parent = this.parentNode;\n\n        if (jQuery.inArray(this, ignored) < 0) {\n          jQuery.cleanData(getAll(this));\n\n          if (parent) {\n            parent.replaceChild(elem, this);\n          }\n        } // Force callback invocation\n\n      }, ignored);\n    }\n  });\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1,\n          i = 0;\n\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only\n        // .get() because push.apply(_, arraylike) throws on ancient WebKit\n\n        push.apply(ret, elems.get());\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n  var getStyles = function (elem) {\n    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n    // IE throws on elements created in popups\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n    var view = elem.ownerDocument.defaultView;\n\n    if (!view || !view.opener) {\n      view = window;\n    }\n\n    return view.getComputedStyle(elem);\n  };\n\n  var swap = function (elem, options, callback) {\n    var ret,\n        name,\n        old = {}; // Remember the old values, and insert the new ones\n\n    for (name in options) {\n      old[name] = elem.style[name];\n      elem.style[name] = options[name];\n    }\n\n    ret = callback.call(elem); // Revert the old values\n\n    for (name in options) {\n      elem.style[name] = old[name];\n    }\n\n    return ret;\n  };\n\n  var rboxStyle = new RegExp(cssExpand.join(\"|\"), \"i\");\n\n  (function () {\n    // Executing both pixelPosition & boxSizingReliable tests require only one layout\n    // so they're executed at the same time to save the second computation.\n    function computeStyleTests() {\n      // This is a singleton, we need to execute it only once\n      if (!div) {\n        return;\n      }\n\n      container.style.cssText = \"position:absolute;left:-11111px;width:60px;\" + \"margin-top:1px;padding:0;border:0\";\n      div.style.cssText = \"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" + \"margin:auto;border:1px;padding:1px;\" + \"width:60%;top:1%\";\n      documentElement.appendChild(container).appendChild(div);\n      var divStyle = window.getComputedStyle(div);\n      pixelPositionVal = divStyle.top !== \"1%\"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\n      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n      // Some styles come back with percentage values, even though they shouldn't\n\n      div.style.right = \"60%\";\n      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only\n      // Detect misreporting of content dimensions for box-sizing:border-box elements\n\n      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only\n      // Detect overflow:scroll screwiness (gh-3699)\n      // Support: Chrome <=64\n      // Don't get tricked when zoom affects offsetWidth (gh-4029)\n\n      div.style.position = \"absolute\";\n      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;\n      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and\n      // it will also be a sign that checks already performed\n\n      div = null;\n    }\n\n    function roundPixelMeasures(measure) {\n      return Math.round(parseFloat(measure));\n    }\n\n    var pixelPositionVal,\n        boxSizingReliableVal,\n        scrollboxSizeVal,\n        pixelBoxStylesVal,\n        reliableTrDimensionsVal,\n        reliableMarginLeftVal,\n        container = document.createElement(\"div\"),\n        div = document.createElement(\"div\"); // Finish early in limited (non-browser) environments\n\n    if (!div.style) {\n      return;\n    } // Support: IE <=9 - 11 only\n    // Style of cloned element affects source element cloned (#8908)\n\n\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode(true).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n    jQuery.extend(support, {\n      boxSizingReliable: function () {\n        computeStyleTests();\n        return boxSizingReliableVal;\n      },\n      pixelBoxStyles: function () {\n        computeStyleTests();\n        return pixelBoxStylesVal;\n      },\n      pixelPosition: function () {\n        computeStyleTests();\n        return pixelPositionVal;\n      },\n      reliableMarginLeft: function () {\n        computeStyleTests();\n        return reliableMarginLeftVal;\n      },\n      scrollboxSize: function () {\n        computeStyleTests();\n        return scrollboxSizeVal;\n      },\n      // Support: IE 9 - 11+, Edge 15 - 18+\n      // IE/Edge misreport `getComputedStyle` of table rows with width/height\n      // set in CSS while `offset*` properties report correct values.\n      // Behavior in IE 9 is more subtle than in newer versions & it passes\n      // some versions of this test; make sure not to make it pass there!\n      reliableTrDimensions: function () {\n        var table, tr, trChild, trStyle;\n\n        if (reliableTrDimensionsVal == null) {\n          table = document.createElement(\"table\");\n          tr = document.createElement(\"tr\");\n          trChild = document.createElement(\"div\");\n          table.style.cssText = \"position:absolute;left:-11111px\";\n          tr.style.height = \"1px\";\n          trChild.style.height = \"9px\";\n          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);\n          trStyle = window.getComputedStyle(tr);\n          reliableTrDimensionsVal = parseInt(trStyle.height) > 3;\n          documentElement.removeChild(table);\n        }\n\n        return reliableTrDimensionsVal;\n      }\n    });\n  })();\n\n  function curCSS(elem, name, computed) {\n    var width,\n        minWidth,\n        maxWidth,\n        ret,\n        // Support: Firefox 51+\n    // Retrieving style before computed somehow\n    // fixes an issue with getting wrong values\n    // on detached elements\n    style = elem.style;\n    computed = computed || getStyles(elem); // getPropertyValue is needed for:\n    //   .css('filter') (IE 9 only, #12537)\n    //   .css('--customProperty) (#3144)\n\n    if (computed) {\n      ret = computed.getPropertyValue(name) || computed[name];\n\n      if (ret === \"\" && !isAttached(elem)) {\n        ret = jQuery.style(elem, name);\n      } // A tribute to the \"awesome hack by Dean Edwards\"\n      // Android Browser returns percentage for some values,\n      // but width seems to be reliably pixels.\n      // This is against the CSSOM draft spec:\n      // https://drafts.csswg.org/cssom/#resolved-values\n\n\n      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\n        // Remember the original values\n        width = style.width;\n        minWidth = style.minWidth;\n        maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n\n        style.minWidth = style.maxWidth = style.width = ret;\n        ret = computed.width; // Revert the changed values\n\n        style.width = width;\n        style.minWidth = minWidth;\n        style.maxWidth = maxWidth;\n      }\n    }\n\n    return ret !== undefined ? // Support: IE <=9 - 11 only\n    // IE returns zIndex value as an integer.\n    ret + \"\" : ret;\n  }\n\n  function addGetHookIf(conditionFn, hookFn) {\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n      get: function () {\n        if (conditionFn()) {\n          // Hook not needed (or it's not possible to use it due\n          // to missing dependency), remove it.\n          delete this.get;\n          return;\n        } // Hook needed; redefine it so that the support test is not executed again.\n\n\n        return (this.get = hookFn).apply(this, arguments);\n      }\n    };\n  }\n\n  var cssPrefixes = [\"Webkit\", \"Moz\", \"ms\"],\n      emptyStyle = document.createElement(\"div\").style,\n      vendorProps = {}; // Return a vendor-prefixed property or undefined\n\n  function vendorPropName(name) {\n    // Check for vendor prefixed names\n    var capName = name[0].toUpperCase() + name.slice(1),\n        i = cssPrefixes.length;\n\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n\n\n  function finalPropName(name) {\n    var final = jQuery.cssProps[name] || vendorProps[name];\n\n    if (final) {\n      return final;\n    }\n\n    if (name in emptyStyle) {\n      return name;\n    }\n\n    return vendorProps[name] = vendorPropName(name) || name;\n  }\n\n  var // Swappable if display is none or starts with table\n  // except \"table\", \"table-cell\", or \"table-caption\"\n  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n      rcustomProp = /^--/,\n      cssShow = {\n    position: \"absolute\",\n    visibility: \"hidden\",\n    display: \"block\"\n  },\n      cssNormalTransform = {\n    letterSpacing: \"0\",\n    fontWeight: \"400\"\n  };\n\n  function setPositiveNumber(_elem, value, subtract) {\n    // Any relative (+/-) values have already been\n    // normalized at this point\n    var matches = rcssNum.exec(value);\n    return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") : value;\n  }\n\n  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\n    var i = dimension === \"width\" ? 1 : 0,\n        extra = 0,\n        delta = 0; // Adjustment may not be necessary\n\n    if (box === (isBorderBox ? \"border\" : \"content\")) {\n      return 0;\n    }\n\n    for (; i < 4; i += 2) {\n      // Both box models exclude margin\n      if (box === \"margin\") {\n        delta += jQuery.css(elem, box + cssExpand[i], true, styles);\n      } // If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\n\n      if (!isBorderBox) {\n        // Add padding\n        delta += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles); // For \"border\" or \"margin\", add border\n\n        if (box !== \"padding\") {\n          delta += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles); // But still keep track of it otherwise\n        } else {\n          extra += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        } // If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n        // \"padding\" or \"margin\"\n\n      } else {\n        // For \"content\", subtract padding\n        if (box === \"content\") {\n          delta -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n        } // For \"content\" or \"padding\", subtract border\n\n\n        if (box !== \"margin\") {\n          delta -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      }\n    } // Account for positive content-box scroll gutter when requested by providing computedVal\n\n\n    if (!isBorderBox && computedVal >= 0) {\n      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n      // Assuming integer scroll gutter, subtract the rest and round down\n      delta += Math.max(0, Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n      // Use an explicit zero to avoid NaN (gh-3964)\n      )) || 0;\n    }\n\n    return delta;\n  }\n\n  function getWidthOrHeight(elem, dimension, extra) {\n    // Start with computed style\n    var styles = getStyles(elem),\n        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n    // Fake content-box until we know it's needed to know the true value.\n    boxSizingNeeded = !support.boxSizingReliable() || extra,\n        isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n        valueIsBorderBox = isBorderBox,\n        val = curCSS(elem, dimension, styles),\n        offsetProp = \"offset\" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54\n    // Return a confounding non-pixel value or feign ignorance, as appropriate.\n\n    if (rnumnonpx.test(val)) {\n      if (!extra) {\n        return val;\n      }\n\n      val = \"auto\";\n    } // Support: IE 9 - 11 only\n    // Use offsetWidth/offsetHeight for when box sizing is unreliable.\n    // In those cases, the computed value can be trusted to be border-box.\n\n\n    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+\n    // IE/Edge misreport `getComputedStyle` of table rows with width/height\n    // set in CSS while `offset*` properties report correct values.\n    // Interestingly, in some cases IE 9 doesn't suffer from this issue.\n    !support.reliableTrDimensions() && nodeName(elem, \"tr\") || // Fall back to offsetWidth/offsetHeight when value is \"auto\"\n    // This happens for inline elements with no explicit setting (gh-3571)\n    val === \"auto\" || // Support: Android <=4.1 - 4.3 only\n    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n    !parseFloat(val) && jQuery.css(elem, \"display\", false, styles) === \"inline\") && // Make sure the element is visible & connected\n    elem.getClientRects().length) {\n      isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.\n      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n      // retrieved value as a content box dimension.\n\n      valueIsBorderBox = offsetProp in elem;\n\n      if (valueIsBorderBox) {\n        val = elem[offsetProp];\n      }\n    } // Normalize \"\" and auto\n\n\n    val = parseFloat(val) || 0; // Adjust for the element's box model\n\n    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)\n    val) + \"px\";\n  }\n\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function (elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, \"opacity\");\n            return ret === \"\" ? \"1\" : ret;\n          }\n        }\n      }\n    },\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n      \"animationIterationCount\": true,\n      \"columnCount\": true,\n      \"fillOpacity\": true,\n      \"flexGrow\": true,\n      \"flexShrink\": true,\n      \"fontWeight\": true,\n      \"gridArea\": true,\n      \"gridColumn\": true,\n      \"gridColumnEnd\": true,\n      \"gridColumnStart\": true,\n      \"gridRow\": true,\n      \"gridRowEnd\": true,\n      \"gridRowStart\": true,\n      \"lineHeight\": true,\n      \"opacity\": true,\n      \"order\": true,\n      \"orphans\": true,\n      \"widows\": true,\n      \"zIndex\": true,\n      \"zoom\": true\n    },\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {},\n    // Get and set the style property on a DOM Node\n    style: function (elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      } // Make sure that we're working with the right name\n\n\n      var ret,\n          type,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name),\n          style = elem.style; // Make sure that we're working with the right name. We don't\n      // want to query the value if it is a CSS custom property\n      // since they are user-defined.\n\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      } // Gets hook for the prefixed version, then unprefixed version\n\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value\n\n      if (value !== undefined) {\n        type = typeof value; // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\n        if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n          value = adjustCSS(elem, name, ret); // Fixes bug #9237\n\n          type = \"number\";\n        } // Make sure that null and NaN values aren't set (#7116)\n\n\n        if (value == null || value !== value) {\n          return;\n        } // If a number was passed in, add the unit (except for certain CSS properties)\n        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n        // \"px\" to a few hardcoded values.\n\n\n        if (type === \"number\" && !isCustomProp) {\n          value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n        } // background-* props affect original clone's values\n\n\n        if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n          style[name] = \"inherit\";\n        } // If a hook was provided, use that value, otherwise just set the specified value\n\n\n        if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          if (isCustomProp) {\n            style.setProperty(name, value);\n          } else {\n            style[name] = value;\n          }\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret;\n        } // Otherwise just get the value from the style object\n\n\n        return style[name];\n      }\n    },\n    css: function (elem, name, extra, styles) {\n      var val,\n          num,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't\n      // want to modify the value if it is a CSS custom property\n      // since they are user-defined.\n\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      } // Try prefixed name followed by the unprefixed name\n\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there\n\n      if (hooks && \"get\" in hooks) {\n        val = hooks.get(elem, true, extra);\n      } // Otherwise, if a way to get the computed value exists, use that\n\n\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      } // Convert \"normal\" to computed value\n\n\n      if (val === \"normal\" && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      } // Make numeric if forced or a qualifier was provided and val looks numeric\n\n\n      if (extra === \"\" || extra) {\n        num = parseFloat(val);\n        return extra === true || isFinite(num) ? num || 0 : val;\n      }\n\n      return val;\n    }\n  });\n  jQuery.each([\"height\", \"width\"], function (_i, dimension) {\n    jQuery.cssHooks[dimension] = {\n      get: function (elem, computed, extra) {\n        if (computed) {\n          // Certain elements can have dimension info if we invisibly show them\n          // but it must have a current display style that would benefit\n          return rdisplayswap.test(jQuery.css(elem, \"display\")) && ( // Support: Safari 8+\n          // Table columns in Safari have non-zero offsetWidth & zero\n          // getBoundingClientRect().width unless display is changed.\n          // Support: IE <=11 only\n          // Running getBoundingClientRect on a disconnected node\n          // in IE throws an error.\n          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, dimension, extra);\n          }) : getWidthOrHeight(elem, dimension, extra);\n        }\n      },\n      set: function (elem, value, extra) {\n        var matches,\n            styles = getStyles(elem),\n            // Only read styles.position if the test has a chance to fail\n        // to avoid forcing a reflow.\n        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === \"absolute\",\n            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n        boxSizingNeeded = scrollboxSizeBuggy || extra,\n            isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and\n        // faking a content-box to get border and padding (gh-3699)\n\n        if (isBorderBox && scrollboxSizeBuggy) {\n          subtract -= Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, \"border\", false, styles) - 0.5);\n        } // Convert to pixels if value adjustment is needed\n\n\n        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || \"px\") !== \"px\") {\n          elem.style[dimension] = value;\n          value = jQuery.css(elem, dimension);\n        }\n\n        return setPositiveNumber(elem, value, subtract);\n      }\n    };\n  });\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n    if (computed) {\n      return (parseFloat(curCSS(elem, \"marginLeft\")) || elem.getBoundingClientRect().left - swap(elem, {\n        marginLeft: 0\n      }, function () {\n        return elem.getBoundingClientRect().left;\n      })) + \"px\";\n    }\n  }); // These hooks are used by animate to expand properties\n\n  jQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function (value) {\n        var i = 0,\n            expanded = {},\n            // Assumes a single number if not a string\n        parts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n\n        return expanded;\n      }\n    };\n\n    if (prefix !== \"margin\") {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n  jQuery.fn.extend({\n    css: function (name, value) {\n      return access(this, function (elem, name, value) {\n        var styles,\n            len,\n            map = {},\n            i = 0;\n\n        if (Array.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n\n          return map;\n        }\n\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    }\n  });\n\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n\n  jQuery.Tween = Tween;\n  Tween.prototype = {\n    constructor: Tween,\n    init: function (elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || jQuery.easing._default;\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n    },\n    cur: function () {\n      var hooks = Tween.propHooks[this.prop];\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function (percent) {\n      var eased,\n          hooks = Tween.propHooks[this.prop];\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n\n      this.now = (this.end - this.start) * eased + this.start;\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n\n      return this;\n    }\n  };\n  Tween.prototype.init.prototype = Tween.prototype;\n  Tween.propHooks = {\n    _default: {\n      get: function (tween) {\n        var result; // Use a property on the element directly when it is not a DOM element,\n        // or when there is no matching style property that exists.\n\n        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n          return tween.elem[tween.prop];\n        } // Passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails.\n        // Simple values such as \"10px\" are parsed to Float;\n        // complex values such as \"rotate(1rad)\" are returned as-is.\n\n\n        result = jQuery.css(tween.elem, tween.prop, \"\"); // Empty strings, null, undefined and \"auto\" are converted to 0.\n\n        return !result || result === \"auto\" ? 0 : result;\n      },\n      set: function (tween) {\n        // Use step hook for back compat.\n        // Use cssHook if its there.\n        // Use .style if available and use plain properties where available.\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  }; // Support: IE <=9 only\n  // Panic based approach to setting things on disconnected nodes\n\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function (tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n  jQuery.easing = {\n    linear: function (p) {\n      return p;\n    },\n    swing: function (p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    },\n    _default: \"swing\"\n  };\n  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point\n\n  jQuery.fx.step = {};\n  var fxNow,\n      inProgress,\n      rfxtypes = /^(?:toggle|show|hide)$/,\n      rrun = /queueHooks$/;\n\n  function schedule() {\n    if (inProgress) {\n      if (document.hidden === false && window.requestAnimationFrame) {\n        window.requestAnimationFrame(schedule);\n      } else {\n        window.setTimeout(schedule, jQuery.fx.interval);\n      }\n\n      jQuery.fx.tick();\n    }\n  } // Animations created synchronously will run synchronously\n\n\n  function createFxNow() {\n    window.setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = Date.now();\n  } // Generate parameters to create a standard animation\n\n\n  function genFx(type, includeWidth) {\n    var which,\n        i = 0,\n        attrs = {\n      height: type\n    }; // If we include width, step value is 1 to do all cssExpand values,\n    // otherwise step value is 2 to skip over Left and Right\n\n    includeWidth = includeWidth ? 1 : 0;\n\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n  }\n\n  function createTween(value, prop, animation) {\n    var tween,\n        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]),\n        index = 0,\n        length = collection.length;\n\n    for (; index < length; index++) {\n      if (tween = collection[index].call(animation, prop, value)) {\n        // We're done with this property\n        return tween;\n      }\n    }\n  }\n\n  function defaultPrefilter(elem, props, opts) {\n    var prop,\n        value,\n        toggle,\n        hooks,\n        oldfire,\n        propTween,\n        restoreDisplay,\n        display,\n        isBox = \"width\" in props || \"height\" in props,\n        anim = this,\n        orig = {},\n        style = elem.style,\n        hidden = elem.nodeType && isHiddenWithinTree(elem),\n        dataShow = dataPriv.get(elem, \"fxshow\"); // Queue-skipping animations hijack the fx hooks\n\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, \"fx\");\n\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n\n      hooks.unqueued++;\n      anim.always(function () {\n        // Ensure the complete handler is called before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n\n          if (!jQuery.queue(elem, \"fx\").length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    } // Detect show/hide animations\n\n\n    for (prop in props) {\n      value = props[prop];\n\n      if (rfxtypes.test(value)) {\n        delete props[prop];\n        toggle = toggle || value === \"toggle\";\n\n        if (value === (hidden ? \"hide\" : \"show\")) {\n          // Pretend to be hidden if this is a \"show\" and\n          // there is still data from a stopped show/hide\n          if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n            hidden = true; // Ignore all other no-op show/hide data\n          } else {\n            continue;\n          }\n        }\n\n        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n      }\n    } // Bail out if this is a no-op like .hide().hide()\n\n\n    propTween = !jQuery.isEmptyObject(props);\n\n    if (!propTween && jQuery.isEmptyObject(orig)) {\n      return;\n    } // Restrict \"overflow\" and \"display\" styles during box animations\n\n\n    if (isBox && elem.nodeType === 1) {\n      // Support: IE <=9 - 11, Edge 12 - 15\n      // Record all 3 overflow attributes because IE does not infer the shorthand\n      // from identically-valued overflowX and overflowY and Edge just mirrors\n      // the overflowX value there.\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade\n\n      restoreDisplay = dataShow && dataShow.display;\n\n      if (restoreDisplay == null) {\n        restoreDisplay = dataPriv.get(elem, \"display\");\n      }\n\n      display = jQuery.css(elem, \"display\");\n\n      if (display === \"none\") {\n        if (restoreDisplay) {\n          display = restoreDisplay;\n        } else {\n          // Get nonempty value(s) by temporarily forcing visibility\n          showHide([elem], true);\n          restoreDisplay = elem.style.display || restoreDisplay;\n          display = jQuery.css(elem, \"display\");\n          showHide([elem]);\n        }\n      } // Animate inline elements as inline-block\n\n\n      if (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\n        if (jQuery.css(elem, \"float\") === \"none\") {\n          // Restore the original display value at the end of pure show/hide animations\n          if (!propTween) {\n            anim.done(function () {\n              style.display = restoreDisplay;\n            });\n\n            if (restoreDisplay == null) {\n              display = style.display;\n              restoreDisplay = display === \"none\" ? \"\" : display;\n            }\n          }\n\n          style.display = \"inline-block\";\n        }\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = \"hidden\";\n      anim.always(function () {\n        style.overflow = opts.overflow[0];\n        style.overflowX = opts.overflow[1];\n        style.overflowY = opts.overflow[2];\n      });\n    } // Implement show/hide animations\n\n\n    propTween = false;\n\n    for (prop in orig) {\n      // General show/hide setup for this element animation\n      if (!propTween) {\n        if (dataShow) {\n          if (\"hidden\" in dataShow) {\n            hidden = dataShow.hidden;\n          }\n        } else {\n          dataShow = dataPriv.access(elem, \"fxshow\", {\n            display: restoreDisplay\n          });\n        } // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\n\n        if (toggle) {\n          dataShow.hidden = !hidden;\n        } // Show elements before animating them\n\n\n        if (hidden) {\n          showHide([elem], true);\n        }\n        /* eslint-disable no-loop-func */\n\n\n        anim.done(function () {\n          /* eslint-enable no-loop-func */\n          // The final step of a \"hide\" animation is actually hiding the element\n          if (!hidden) {\n            showHide([elem]);\n          }\n\n          dataPriv.remove(elem, \"fxshow\");\n\n          for (prop in orig) {\n            jQuery.style(elem, prop, orig[prop]);\n          }\n        });\n      } // Per-property setup\n\n\n      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\n      if (!(prop in dataShow)) {\n        dataShow[prop] = propTween.start;\n\n        if (hidden) {\n          propTween.end = propTween.start;\n          propTween.start = 0;\n        }\n      }\n    }\n  }\n\n  function propFilter(props, specialEasing) {\n    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass\n\n    for (index in props) {\n      name = camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n\n      if (Array.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n\n      hooks = jQuery.cssHooks[name];\n\n      if (hooks && \"expand\" in hooks) {\n        value = hooks.expand(value);\n        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.\n        // Reusing 'index' because we have the correct \"name\"\n\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n\n  function Animation(elem, properties, options) {\n    var result,\n        stopped,\n        index = 0,\n        length = Animation.prefilters.length,\n        deferred = jQuery.Deferred().always(function () {\n      // Don't match elem in the :animated selector\n      delete tick.elem;\n    }),\n        tick = function () {\n      if (stopped) {\n        return false;\n      }\n\n      var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // Support: Android 2.3 only\n      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n      temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n\n      for (; index < length; index++) {\n        animation.tweens[index].run(percent);\n      }\n\n      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield\n\n      if (percent < 1 && length) {\n        return remaining;\n      } // If this was an empty animation, synthesize a final progress notification\n\n\n      if (!length) {\n        deferred.notifyWith(elem, [animation, 1, 0]);\n      } // Resolve the animation and report its conclusion\n\n\n      deferred.resolveWith(elem, [animation]);\n      return false;\n    },\n        animation = deferred.promise({\n      elem: elem,\n      props: jQuery.extend({}, properties),\n      opts: jQuery.extend(true, {\n        specialEasing: {},\n        easing: jQuery.easing._default\n      }, options),\n      originalProperties: properties,\n      originalOptions: options,\n      startTime: fxNow || createFxNow(),\n      duration: options.duration,\n      tweens: [],\n      createTween: function (prop, end) {\n        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n        animation.tweens.push(tween);\n        return tween;\n      },\n      stop: function (gotoEnd) {\n        var index = 0,\n            // If we are going to the end, we want to run all the tweens\n        // otherwise we skip this part\n        length = gotoEnd ? animation.tweens.length : 0;\n\n        if (stopped) {\n          return this;\n        }\n\n        stopped = true;\n\n        for (; index < length; index++) {\n          animation.tweens[index].run(1);\n        } // Resolve when we played the last frame; otherwise, reject\n\n\n        if (gotoEnd) {\n          deferred.notifyWith(elem, [animation, 1, 0]);\n          deferred.resolveWith(elem, [animation, gotoEnd]);\n        } else {\n          deferred.rejectWith(elem, [animation, gotoEnd]);\n        }\n\n        return this;\n      }\n    }),\n        props = animation.props;\n\n    propFilter(props, animation.opts.specialEasing);\n\n    for (; index < length; index++) {\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n\n      if (result) {\n        if (isFunction(result.stop)) {\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\n        }\n\n        return result;\n      }\n    }\n\n    jQuery.map(props, createTween, animation);\n\n    if (isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    } // Attach callbacks from options\n\n\n    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    }));\n    return animation;\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweeners: {\n      \"*\": [function (prop, value) {\n        var tween = this.createTween(prop, value);\n        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n        return tween;\n      }]\n    },\n    tweener: function (props, callback) {\n      if (isFunction(props)) {\n        callback = props;\n        props = [\"*\"];\n      } else {\n        props = props.match(rnothtmlwhite);\n      }\n\n      var prop,\n          index = 0,\n          length = props.length;\n\n      for (; index < length; index++) {\n        prop = props[index];\n        Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n        Animation.tweeners[prop].unshift(callback);\n      }\n    },\n    prefilters: [defaultPrefilter],\n    prefilter: function (callback, prepend) {\n      if (prepend) {\n        Animation.prefilters.unshift(callback);\n      } else {\n        Animation.prefilters.push(callback);\n      }\n    }\n  });\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && typeof speed === \"object\" ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !isFunction(easing) && easing\n    }; // Go to the end state if fx are off\n\n    if (jQuery.fx.off) {\n      opt.duration = 0;\n    } else {\n      if (typeof opt.duration !== \"number\") {\n        if (opt.duration in jQuery.fx.speeds) {\n          opt.duration = jQuery.fx.speeds[opt.duration];\n        } else {\n          opt.duration = jQuery.fx.speeds._default;\n        }\n      }\n    } // Normalize opt.queue - true/undefined/null -> \"fx\"\n\n\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = \"fx\";\n    } // Queueing\n\n\n    opt.old = opt.complete;\n\n    opt.complete = function () {\n      if (isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n\n    return opt;\n  };\n\n  jQuery.fn.extend({\n    fadeTo: function (speed, to, easing, callback) {\n      // Show any hidden elements after setting opacity to 0\n      return this.filter(isHiddenWithinTree).css(\"opacity\", 0).show() // Animate to the value specified\n      .end().animate({\n        opacity: to\n      }, speed, easing, callback);\n    },\n    animate: function (prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n          optall = jQuery.speed(speed, easing, callback),\n          doAnimation = function () {\n        // Operate on a copy of prop so per-property easing won't be lost\n        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately\n\n        if (empty || dataPriv.get(this, \"finish\")) {\n          anim.stop(true);\n        }\n      };\n\n      doAnimation.finish = doAnimation;\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function (type, clearQueue, gotoEnd) {\n      var stopQueue = function (hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n\n      if (typeof type !== \"string\") {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n\n      if (clearQueue) {\n        this.queue(type || \"fx\", []);\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n            index = type != null && type + \"queueHooks\",\n            timers = jQuery.timers,\n            data = dataPriv.get(this);\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        } // Start the next in the queue if the last step wasn't forced.\n        // Timers currently will call their complete callbacks, which\n        // will dequeue but only if they were gotoEnd.\n\n\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function (type) {\n      if (type !== false) {\n        type = type || \"fx\";\n      }\n\n      return this.each(function () {\n        var index,\n            data = dataPriv.get(this),\n            queue = data[type + \"queue\"],\n            hooks = data[type + \"queueHooks\"],\n            timers = jQuery.timers,\n            length = queue ? queue.length : 0; // Enable finishing flag on private data\n\n        data.finish = true; // Empty the queue first\n\n        jQuery.queue(this, type, []);\n\n        if (hooks && hooks.stop) {\n          hooks.stop.call(this, true);\n        } // Look for any active animations, and finish them\n\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        } // Look for any animations in the old queue and finish them\n\n\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        } // Turn off finishing flag\n\n\n        delete data.finish;\n      });\n    }\n  });\n  jQuery.each([\"toggle\", \"show\", \"hide\"], function (_i, name) {\n    var cssFn = jQuery.fn[name];\n\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  }); // Generate shortcuts for custom animations\n\n  jQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n  jQuery.timers = [];\n\n  jQuery.fx.tick = function () {\n    var timer,\n        i = 0,\n        timers = jQuery.timers;\n    fxNow = Date.now();\n\n    for (; i < timers.length; i++) {\n      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)\n\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n\n    fxNow = undefined;\n  };\n\n  jQuery.fx.timer = function (timer) {\n    jQuery.timers.push(timer);\n    jQuery.fx.start();\n  };\n\n  jQuery.fx.interval = 13;\n\n  jQuery.fx.start = function () {\n    if (inProgress) {\n      return;\n    }\n\n    inProgress = true;\n    schedule();\n  };\n\n  jQuery.fx.stop = function () {\n    inProgress = null;\n  };\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n  }; // Based off of the plugin by Clint Helfers, with permission.\n  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\n  jQuery.fn.delay = function (time, type) {\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n    type = type || \"fx\";\n    return this.queue(type, function (next, hooks) {\n      var timeout = window.setTimeout(next, time);\n\n      hooks.stop = function () {\n        window.clearTimeout(timeout);\n      };\n    });\n  };\n\n  (function () {\n    var input = document.createElement(\"input\"),\n        select = document.createElement(\"select\"),\n        opt = select.appendChild(document.createElement(\"option\"));\n    input.type = \"checkbox\"; // Support: Android <=4.3 only\n    // Default value for a checkbox should be \"on\"\n\n    support.checkOn = input.value !== \"\"; // Support: IE <=11 only\n    // Must access selectedIndex to make default options select\n\n    support.optSelected = opt.selected; // Support: IE <=11 only\n    // An input loses its value after becoming a radio\n\n    input = document.createElement(\"input\");\n    input.value = \"t\";\n    input.type = \"radio\";\n    support.radioValue = input.value === \"t\";\n  })();\n\n  var boolHook,\n      attrHandle = jQuery.expr.attrHandle;\n  jQuery.fn.extend({\n    attr: function (name, value) {\n      return access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n    removeAttr: function (name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    }\n  });\n  jQuery.extend({\n    attr: function (elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      } // Fallback to prop when attributes are not supported\n\n\n      if (typeof elem.getAttribute === \"undefined\") {\n        return jQuery.prop(elem, name, value);\n      } // Attribute hooks are determined by the lowercase version\n      // Grab necessary hook if one is defined\n\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n          return;\n        }\n\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        elem.setAttribute(name, value + \"\");\n        return value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined\n\n      return ret == null ? undefined : ret;\n    },\n    attrHooks: {\n      type: {\n        set: function (elem, value) {\n          if (!support.radioValue && value === \"radio\" && nodeName(elem, \"input\")) {\n            var val = elem.value;\n            elem.setAttribute(\"type\", value);\n\n            if (val) {\n              elem.value = val;\n            }\n\n            return value;\n          }\n        }\n      }\n    },\n    removeAttr: function (elem, value) {\n      var name,\n          i = 0,\n          // Attribute names can contain non-HTML whitespace characters\n      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n      attrNames = value && value.match(rnothtmlwhite);\n\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          elem.removeAttribute(name);\n        }\n      }\n    }\n  }); // Hooks for boolean attributes\n\n  boolHook = {\n    set: function (elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else {\n        elem.setAttribute(name, name);\n      }\n\n      return name;\n    }\n  };\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (_i, name) {\n    var getter = attrHandle[name] || jQuery.find.attr;\n\n    attrHandle[name] = function (elem, name, isXML) {\n      var ret,\n          handle,\n          lowercaseName = name.toLowerCase();\n\n      if (!isXML) {\n        // Avoid an infinite loop by temporarily removing this function from the getter\n        handle = attrHandle[lowercaseName];\n        attrHandle[lowercaseName] = ret;\n        ret = getter(elem, name, isXML) != null ? lowercaseName : null;\n        attrHandle[lowercaseName] = handle;\n      }\n\n      return ret;\n    };\n  });\n  var rfocusable = /^(?:input|select|textarea|button)$/i,\n      rclickable = /^(?:a|area)$/i;\n  jQuery.fn.extend({\n    prop: function (name, value) {\n      return access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n    removeProp: function (name) {\n      return this.each(function () {\n        delete this[jQuery.propFix[name] || name];\n      });\n    }\n  });\n  jQuery.extend({\n    prop: function (elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n\n      if (value !== undefined) {\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        return elem[name] = value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      return elem[name];\n    },\n    propHooks: {\n      tabIndex: {\n        get: function (elem) {\n          // Support: IE <=9 - 11 only\n          // elem.tabIndex doesn't always return the\n          // correct value when it hasn't been explicitly set\n          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          // Use proper attribute retrieval(#12072)\n          var tabindex = jQuery.find.attr(elem, \"tabindex\");\n\n          if (tabindex) {\n            return parseInt(tabindex, 10);\n          }\n\n          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n            return 0;\n          }\n\n          return -1;\n        }\n      }\n    },\n    propFix: {\n      \"for\": \"htmlFor\",\n      \"class\": \"className\"\n    }\n  }); // Support: IE <=11 only\n  // Accessing the selectedIndex property\n  // forces the browser to respect setting selected\n  // on the option\n  // The getter ensures a default option is selected\n  // when in an optgroup\n  // eslint rule \"no-unused-expressions\" is disabled for this code\n  // since it considers such accessions noop\n\n  if (!support.optSelected) {\n    jQuery.propHooks.selected = {\n      get: function (elem) {\n        /* eslint no-unused-expressions: \"off\" */\n        var parent = elem.parentNode;\n\n        if (parent && parent.parentNode) {\n          parent.parentNode.selectedIndex;\n        }\n\n        return null;\n      },\n      set: function (elem) {\n        /* eslint no-unused-expressions: \"off\" */\n        var parent = elem.parentNode;\n\n        if (parent) {\n          parent.selectedIndex;\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n      }\n    };\n  }\n\n  jQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    jQuery.propFix[this.toLowerCase()] = this;\n  }); // Strip and collapse whitespace according to HTML spec\n  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\n  function stripAndCollapse(value) {\n    var tokens = value.match(rnothtmlwhite) || [];\n    return tokens.join(\" \");\n  }\n\n  function getClass(elem) {\n    return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n  }\n\n  function classesToArray(value) {\n    if (Array.isArray(value)) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return value.match(rnothtmlwhite) || [];\n    }\n\n    return [];\n  }\n\n  jQuery.fn.extend({\n    addClass: function (value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem);\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                cur += clazz + \" \";\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = stripAndCollapse(cur);\n\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function (value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      if (!arguments.length) {\n        return this.attr(\"class\", \"\");\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)\n\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              // Remove *all* instances\n              while (cur.indexOf(\" \" + clazz + \" \") > -1) {\n                cur = cur.replace(\" \" + clazz + \" \", \" \");\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = stripAndCollapse(cur);\n\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function (value, stateVal) {\n      var type = typeof value,\n          isValidValue = type === \"string\" || Array.isArray(value);\n\n      if (typeof stateVal === \"boolean\" && isValidValue) {\n        return stateVal ? this.addClass(value) : this.removeClass(value);\n      }\n\n      if (isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n        });\n      }\n\n      return this.each(function () {\n        var className, i, self, classNames;\n\n        if (isValidValue) {\n          // Toggle individual class names\n          i = 0;\n          self = jQuery(this);\n          classNames = classesToArray(value);\n\n          while (className = classNames[i++]) {\n            // Check each className given, space separated list\n            if (self.hasClass(className)) {\n              self.removeClass(className);\n            } else {\n              self.addClass(className);\n            }\n          } // Toggle whole class name\n\n        } else if (value === undefined || type === \"boolean\") {\n          className = getClass(this);\n\n          if (className) {\n            // Store className if set\n            dataPriv.set(this, \"__className__\", className);\n          } // If the element has a class name or if we're passed `false`,\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n\n\n          if (this.setAttribute) {\n            this.setAttribute(\"class\", className || value === false ? \"\" : dataPriv.get(this, \"__className__\") || \"\");\n          }\n        }\n      });\n    },\n    hasClass: function (selector) {\n      var className,\n          elem,\n          i = 0;\n      className = \" \" + selector + \" \";\n\n      while (elem = this[i++]) {\n        if (elem.nodeType === 1 && (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  var rreturn = /\\r/g;\n  jQuery.fn.extend({\n    val: function (value) {\n      var hooks,\n          ret,\n          valueIsFunction,\n          elem = this[0];\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n            return ret;\n          }\n\n          ret = elem.value; // Handle most common string cases\n\n          if (typeof ret === \"string\") {\n            return ret.replace(rreturn, \"\");\n          } // Handle cases where value is null/undef or number\n\n\n          return ret == null ? \"\" : ret;\n        }\n\n        return;\n      }\n\n      valueIsFunction = isFunction(value);\n      return this.each(function (i) {\n        var val;\n\n        if (this.nodeType !== 1) {\n          return;\n        }\n\n        if (valueIsFunction) {\n          val = value.call(this, i, jQuery(this).val());\n        } else {\n          val = value;\n        } // Treat null/undefined as \"\"; convert numbers to string\n\n\n        if (val == null) {\n          val = \"\";\n        } else if (typeof val === \"number\") {\n          val += \"\";\n        } else if (Array.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? \"\" : value + \"\";\n          });\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting\n\n        if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function (elem) {\n          var val = jQuery.find.attr(elem, \"value\");\n          return val != null ? val : // Support: IE <=10 - 11 only\n          // option.text throws exceptions (#14686, #14858)\n          // Strip and collapse whitespace\n          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n          stripAndCollapse(jQuery.text(elem));\n        }\n      },\n      select: {\n        get: function (elem) {\n          var value,\n              option,\n              i,\n              options = elem.options,\n              index = elem.selectedIndex,\n              one = elem.type === \"select-one\",\n              values = one ? null : [],\n              max = one ? index + 1 : options.length;\n\n          if (index < 0) {\n            i = max;\n          } else {\n            i = one ? index : 0;\n          } // Loop through all the selected options\n\n\n          for (; i < max; i++) {\n            option = options[i]; // Support: IE <=9 only\n            // IE8-9 doesn't update selected after form reset (#2551)\n\n            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup\n            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, \"optgroup\"))) {\n              // Get the specific value for the option\n              value = jQuery(option).val(); // We don't need an array for one selects\n\n              if (one) {\n                return value;\n              } // Multi-Selects return an array\n\n\n              values.push(value);\n            }\n          }\n\n          return values;\n        },\n        set: function (elem, value) {\n          var optionSet,\n              option,\n              options = elem.options,\n              values = jQuery.makeArray(value),\n              i = options.length;\n\n          while (i--) {\n            option = options[i];\n            /* eslint-disable no-cond-assign */\n\n            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n              optionSet = true;\n            }\n            /* eslint-enable no-cond-assign */\n\n          } // Force browsers to behave consistently when non-matching value is set\n\n\n          if (!optionSet) {\n            elem.selectedIndex = -1;\n          }\n\n          return values;\n        }\n      }\n    }\n  }); // Radios and checkboxes getter/setter\n\n  jQuery.each([\"radio\", \"checkbox\"], function () {\n    jQuery.valHooks[this] = {\n      set: function (elem, value) {\n        if (Array.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n        }\n      }\n    };\n\n    if (!support.checkOn) {\n      jQuery.valHooks[this].get = function (elem) {\n        return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n      };\n    }\n  }); // Return jQuery for attributes-only inclusion\n\n  support.focusin = \"onfocusin\" in window;\n\n  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n      stopPropagationCallback = function (e) {\n    e.stopPropagation();\n  };\n\n  jQuery.extend(jQuery.event, {\n    trigger: function (event, data, elem, onlyHandlers) {\n      var i,\n          cur,\n          tmp,\n          bubbleType,\n          ontype,\n          handle,\n          special,\n          lastElement,\n          eventPath = [elem || document],\n          type = hasOwn.call(event, \"type\") ? event.type : event,\n          namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes\n\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      } // focus/blur morphs to focusin/out; ensure we're not firing them right now\n\n\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n\n      if (type.indexOf(\".\") > -1) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split(\".\");\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n\n      ontype = type.indexOf(\":\") < 0 && \"on\" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string\n\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === \"object\" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\n      event.isTrigger = onlyHandlers ? 2 : 3;\n      event.namespace = namespaces.join(\".\");\n      event.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null; // Clean up the event in case it is being reused\n\n      event.result = undefined;\n\n      if (!event.target) {\n        event.target = elem;\n      } // Clone any incoming data and prepend the event, creating the handler arg list\n\n\n      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines\n\n      special = jQuery.event.special[type] || {};\n\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      } // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\n\n      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\n        bubbleType = special.delegateType || type;\n\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        } // Only add window if we got to document (e.g., not plain obj or detached DOM)\n\n\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      } // Fire handlers on the event path\n\n\n      i = 0;\n\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        lastElement = cur;\n        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler\n\n        handle = (dataPriv.get(cur, \"events\") || Object.create(null))[event.type] && dataPriv.get(cur, \"handle\");\n\n        if (handle) {\n          handle.apply(cur, data);\n        } // Native handler\n\n\n        handle = ontype && cur[ontype];\n\n        if (handle && handle.apply && acceptData(cur)) {\n          event.result = handle.apply(cur, data);\n\n          if (event.result === false) {\n            event.preventDefault();\n          }\n        }\n      }\n\n      event.type = type; // If nobody prevented the default action, do it now\n\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n          // Call a native DOM method on the target with the same name as the event.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n\n            if (tmp) {\n              elem[ontype] = null;\n            } // Prevent re-triggering of the same event, since we already bubbled it above\n\n\n            jQuery.event.triggered = type;\n\n            if (event.isPropagationStopped()) {\n              lastElement.addEventListener(type, stopPropagationCallback);\n            }\n\n            elem[type]();\n\n            if (event.isPropagationStopped()) {\n              lastElement.removeEventListener(type, stopPropagationCallback);\n            }\n\n            jQuery.event.triggered = undefined;\n\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n\n      return event.result;\n    },\n    // Piggyback on a donor event to simulate a different one\n    // Used only for `focus(in | out)` events\n    simulate: function (type, elem, event) {\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true\n      });\n      jQuery.event.trigger(e, null, elem);\n    }\n  });\n  jQuery.fn.extend({\n    trigger: function (type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function (type, data) {\n      var elem = this[0];\n\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  }); // Support: Firefox <=44\n  // Firefox doesn't have focus(in | out) events\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n  //\n  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n  // focus(in | out) events fire after focus & blur events,\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\n  if (!support.focusin) {\n    jQuery.each({\n      focus: \"focusin\",\n      blur: \"focusout\"\n    }, function (orig, fix) {\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\n      var handler = function (event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n      };\n\n      jQuery.event.special[fix] = {\n        setup: function () {\n          // Handle: regular nodes (via `this.ownerDocument`), window\n          // (via `this.document`) & document (via `this`).\n          var doc = this.ownerDocument || this.document || this,\n              attaches = dataPriv.access(doc, fix);\n\n          if (!attaches) {\n            doc.addEventListener(orig, handler, true);\n          }\n\n          dataPriv.access(doc, fix, (attaches || 0) + 1);\n        },\n        teardown: function () {\n          var doc = this.ownerDocument || this.document || this,\n              attaches = dataPriv.access(doc, fix) - 1;\n\n          if (!attaches) {\n            doc.removeEventListener(orig, handler, true);\n            dataPriv.remove(doc, fix);\n          } else {\n            dataPriv.access(doc, fix, attaches);\n          }\n        }\n      };\n    });\n  }\n\n  var location = window.location;\n  var nonce = {\n    guid: Date.now()\n  };\n  var rquery = /\\?/; // Cross-browser xml parsing\n\n  jQuery.parseXML = function (data) {\n    var xml;\n\n    if (!data || typeof data !== \"string\") {\n      return null;\n    } // Support: IE 9 - 11 only\n    // IE throws on parseFromString with invalid input.\n\n\n    try {\n      xml = new window.DOMParser().parseFromString(data, \"text/xml\");\n    } catch (e) {\n      xml = undefined;\n    }\n\n    if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n      jQuery.error(\"Invalid XML: \" + data);\n    }\n\n    return xml;\n  };\n\n  var rbracket = /\\[\\]$/,\n      rCRLF = /\\r?\\n/g,\n      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n      rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n\n    if (Array.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + \"[\" + (typeof v === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n        }\n      });\n    } else if (!traditional && toType(obj) === \"object\") {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  } // Serialize an array of form elements or a set of\n  // key/values into a query string\n\n\n  jQuery.param = function (a, traditional) {\n    var prefix,\n        s = [],\n        add = function (key, valueOrFunction) {\n      // If value is a function, invoke it and use its return value\n      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n      s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value == null ? \"\" : value);\n    };\n\n    if (a == null) {\n      return \"\";\n    } // If an array was passed in, assume that it is an array of form elements.\n\n\n    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    } // Return the resulting serialization\n\n\n    return s.join(\"&\");\n  };\n\n  jQuery.fn.extend({\n    serialize: function () {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function () {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, \"elements\");\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type; // Use .is( \":disabled\" ) so that fieldset[disabled] works\n\n        return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n      }).map(function (_i, elem) {\n        var val = jQuery(this).val();\n\n        if (val == null) {\n          return null;\n        }\n\n        if (Array.isArray(val)) {\n          return jQuery.map(val, function (val) {\n            return {\n              name: elem.name,\n              value: val.replace(rCRLF, \"\\r\\n\")\n            };\n          });\n        }\n\n        return {\n          name: elem.name,\n          value: val.replace(rCRLF, \"\\r\\n\")\n        };\n      }).get();\n    }\n  });\n  var r20 = /%20/g,\n      rhash = /#.*$/,\n      rantiCache = /([?&])_=[^&]*/,\n      rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n      // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n\n  /* Prefilters\n   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n   * 2) These are called:\n   *    - BEFORE asking for a transport\n   *    - AFTER param serialization (s.data is a string if s.processData is true)\n   * 3) key is the dataType\n   * 4) the catchall symbol \"*\" can be used\n   * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n   */\n  prefilters = {},\n\n  /* Transports bindings\n   * 1) key is the dataType\n   * 2) the catchall symbol \"*\" can be used\n   * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n   */\n  transports = {},\n      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = \"*/\".concat(\"*\"),\n      // Anchor tag for parsing the document origin\n  originAnchor = document.createElement(\"a\");\n  originAnchor.href = location.href; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n\n      if (isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType[0] === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  } // Base inspection function for prefilters and transports\n\n\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  } // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n\n\n  function ajaxExtend(target, src) {\n    var key,\n        deep,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n  /* Handles responses to an ajax request:\n   * - finds the right dataType (mediates between content-type and expected dataType)\n   * - returns the corresponding response\n   */\n\n\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var ct,\n        type,\n        finalDataType,\n        firstDataType,\n        contents = s.contents,\n        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process\n\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    } // Check if we're dealing with a known content-type\n\n\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    } // Check to see if we have a response for the expected dataType\n\n\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      } // Or just use first one\n\n\n      finalDataType = finalDataType || firstDataType;\n    } // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n\n\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n\n      return responses[finalDataType];\n    }\n  }\n  /* Chain conversions given the request and the original response\n   * Also sets the responseXXX fields on the jqXHR instance\n   */\n\n\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        prev,\n        converters = {},\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys\n\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    }\n\n    current = dataTypes.shift(); // Convert to each sequential dataType\n\n    while (current) {\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response;\n      } // Apply the dataFilter if provided\n\n\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType);\n      }\n\n      prev = current;\n      current = dataTypes.shift();\n\n      if (current) {\n        // There's only work to do if current dataType is non-auto\n        if (current === \"*\") {\n          current = prev; // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.unshift(tmp[1]);\n                  }\n\n                  break;\n                }\n              }\n            }\n          } // Apply converter (if not an equivalence)\n\n\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s.throws) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      state: \"success\",\n      data: response\n    };\n  }\n\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: location.href,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(location.protocol),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\",\n        json: \"responseJSON\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": JSON.parse,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function (target, settings) {\n      return settings ? // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function (url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (typeof url === \"object\") {\n        options = url;\n        url = undefined;\n      } // Force options to be an object\n\n\n      options = options || {};\n      var transport,\n          // URL without anti-cache param\n      cacheURL,\n          // Response headers\n      responseHeadersString,\n          responseHeaders,\n          // timeout handle\n      timeoutTimer,\n          // Url cleanup var\n      urlAnchor,\n          // Request state (becomes false upon send and true upon completion)\n      completed,\n          // To know if global events are to be dispatched\n      fireGlobals,\n          // Loop variable\n      i,\n          // uncached part of the url\n      uncached,\n          // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n          // Callbacks context\n      callbackContext = s.context || s,\n          // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n          // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks(\"once memory\"),\n          // Status-dependent callbacks\n      statusCode = s.statusCode || {},\n          // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n          // Default abort message\n      strAbort = \"canceled\",\n          // Fake xhr\n      jqXHR = {\n        readyState: 0,\n        // Builds headers hashtable if needed\n        getResponseHeader: function (key) {\n          var match;\n\n          if (completed) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase() + \" \"] = (responseHeaders[match[1].toLowerCase() + \" \"] || []).concat(match[2]);\n              }\n            }\n\n            match = responseHeaders[key.toLowerCase() + \" \"];\n          }\n\n          return match == null ? null : match.join(\", \");\n        },\n        // Raw string\n        getAllResponseHeaders: function () {\n          return completed ? responseHeadersString : null;\n        },\n        // Caches the header\n        setRequestHeader: function (name, value) {\n          if (completed == null) {\n            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n            requestHeaders[name] = value;\n          }\n\n          return this;\n        },\n        // Overrides response content-type header\n        overrideMimeType: function (type) {\n          if (completed == null) {\n            s.mimeType = type;\n          }\n\n          return this;\n        },\n        // Status-dependent callbacks\n        statusCode: function (map) {\n          var code;\n\n          if (map) {\n            if (completed) {\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            } else {\n              // Lazy-add the new callbacks in a way that preserves old ones\n              for (code in map) {\n                statusCode[code] = [statusCode[code], map[code]];\n              }\n            }\n          }\n\n          return this;\n        },\n        // Cancel the request\n        abort: function (statusText) {\n          var finalText = statusText || strAbort;\n\n          if (transport) {\n            transport.abort(finalText);\n          }\n\n          done(0, finalText);\n          return this;\n        }\n      }; // Attach deferreds\n\n      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n\n      s.url = ((url || s.url || location.href) + \"\").replace(rprotocol, location.protocol + \"//\"); // Alias method option to type as per ticket #12004\n\n      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n      s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\"\"]; // A cross-domain request is in order when the origin doesn't match the current origin.\n\n      if (s.crossDomain == null) {\n        urlAnchor = document.createElement(\"a\"); // Support: IE <=8 - 11, Edge 12 - 15\n        // IE throws exception on accessing the href property if url is malformed,\n        // e.g. http://example.com:80x/\n\n        try {\n          urlAnchor.href = s.url; // Support: IE <=8 - 11 only\n          // Anchor's host property isn't correctly set when s.url is relative\n\n          urlAnchor.href = urlAnchor.href;\n          s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !== urlAnchor.protocol + \"//\" + urlAnchor.host;\n        } catch (e) {\n          // If there is an error parsing the URL, assume it is crossDomain,\n          // it can be rejected by the transport if it is invalid\n          s.crossDomain = true;\n        }\n      } // Convert data if not already a string\n\n\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      } // Apply prefilters\n\n\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n      if (completed) {\n        return jqXHR;\n      } // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\n\n      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests\n\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      } // Uppercase the type\n\n\n      s.type = s.type.toUpperCase(); // Determine if request has content\n\n      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n      // Remove hash to simplify url manipulation\n\n      cacheURL = s.url.replace(rhash, \"\"); // More options handling for requests with no content\n\n      if (!s.hasContent) {\n        // Remember the hash so we can put it back\n        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url\n\n        if (s.data && (s.processData || typeof s.data === \"string\")) {\n          cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n          delete s.data;\n        } // Add or update anti-cache param if needed\n\n\n        if (s.cache === false) {\n          cacheURL = cacheURL.replace(rantiCache, \"$1\");\n          uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce.guid++ + uncached;\n        } // Put hash and anti-cache on the URL that will be requested (gh-1732)\n\n\n        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)\n      } else if (s.data && s.processData && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n        s.data = s.data.replace(r20, \"+\");\n      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      } // Set the correct header, if data is being sent\n\n\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      } // Set the Accepts header for the server, depending on the dataType\n\n\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      } // Allow custom headers/mimetypes and early abort\n\n\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      } // Aborting is no longer a cancellation\n\n\n      strAbort = \"abort\"; // Install callbacks on deferreds\n\n      completeDeferred.add(s.complete);\n      jqXHR.done(s.success);\n      jqXHR.fail(s.error); // Get transport\n\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1; // Send global event\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        } // If request was aborted inside ajaxSend, stop there\n\n\n        if (completed) {\n          return jqXHR;\n        } // Timeout\n\n\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = window.setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n\n        try {\n          completed = false;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Rethrow post-completion exceptions\n          if (completed) {\n            throw e;\n          } // Propagate others as results\n\n\n          done(-1, e);\n        }\n      } // Callback for when everything is done\n\n\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText; // Ignore repeat invocations\n\n        if (completed) {\n          return;\n        }\n\n        completed = true; // Clear timeout if it exists\n\n        if (timeoutTimer) {\n          window.clearTimeout(timeoutTimer);\n        } // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n\n\n        transport = undefined; // Cache response headers\n\n        responseHeadersString = headers || \"\"; // Set readyState\n\n        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful\n\n        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data\n\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        } // Use a noop converter for missing script\n\n\n        if (!isSuccess && jQuery.inArray(\"script\", s.dataTypes) > -1) {\n          s.converters[\"text script\"] = function () {};\n        } // Convert no matter what (that way responseXXX fields are always set)\n\n\n        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining\n\n        if (isSuccess) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n\n            modified = jqXHR.getResponseHeader(\"etag\");\n\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          } // if no content\n\n\n          if (status === 204 || s.type === \"HEAD\") {\n            statusText = \"nocontent\"; // if not modified\n          } else if (status === 304) {\n            statusText = \"notmodified\"; // If we have data, let's convert it\n          } else {\n            statusText = response.state;\n            success = response.data;\n            error = response.error;\n            isSuccess = !error;\n          }\n        } else {\n          // Extract error from statusText and normalize for non-aborts\n          error = statusText;\n\n          if (status || !statusText) {\n            statusText = \"error\";\n\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        } // Set data for the fake xhr object\n\n\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        } // Status-dependent callbacks\n\n\n        jqXHR.statusCode(statusCode);\n        statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        } // Complete\n\n\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n    getJSON: function (url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    },\n    getScript: function (url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    }\n  });\n  jQuery.each([\"get\", \"post\"], function (_i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // Shift arguments if data argument was omitted\n      if (isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      } // The url can be an options object (which then must have .url)\n\n\n      return jQuery.ajax(jQuery.extend({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      }, jQuery.isPlainObject(url) && url));\n    };\n  });\n  jQuery.ajaxPrefilter(function (s) {\n    var i;\n\n    for (i in s.headers) {\n      if (i.toLowerCase() === \"content-type\") {\n        s.contentType = s.headers[i] || \"\";\n      }\n    }\n  });\n\n  jQuery._evalUrl = function (url, options, doc) {\n    return jQuery.ajax({\n      url: url,\n      // Make this explicit, since user can override this through ajaxSetup (#11264)\n      type: \"GET\",\n      dataType: \"script\",\n      cache: true,\n      async: false,\n      global: false,\n      // Only evaluate the response if it is successful (gh-4126)\n      // dataFilter is not invoked for failure responses, so using it instead\n      // of the default converter is kludgy but it works.\n      converters: {\n        \"text script\": function () {}\n      },\n      dataFilter: function (response) {\n        jQuery.globalEval(response, options, doc);\n      }\n    });\n  };\n\n  jQuery.fn.extend({\n    wrapAll: function (html) {\n      var wrap;\n\n      if (this[0]) {\n        if (isFunction(html)) {\n          html = html.call(this[0]);\n        } // The elements to wrap the target around\n\n\n        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n\n        wrap.map(function () {\n          var elem = this;\n\n          while (elem.firstElementChild) {\n            elem = elem.firstElementChild;\n          }\n\n          return elem;\n        }).append(this);\n      }\n\n      return this;\n    },\n    wrapInner: function (html) {\n      if (isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n            contents = self.contents();\n\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n    wrap: function (html) {\n      var htmlIsFunction = isFunction(html);\n      return this.each(function (i) {\n        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\n      });\n    },\n    unwrap: function (selector) {\n      this.parent(selector).not(\"body\").each(function () {\n        jQuery(this).replaceWith(this.childNodes);\n      });\n      return this;\n    }\n  });\n\n  jQuery.expr.pseudos.hidden = function (elem) {\n    return !jQuery.expr.pseudos.visible(elem);\n  };\n\n  jQuery.expr.pseudos.visible = function (elem) {\n    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n  };\n\n  jQuery.ajaxSettings.xhr = function () {\n    try {\n      return new window.XMLHttpRequest();\n    } catch (e) {}\n  };\n\n  var xhrSuccessStatus = {\n    // File protocol always yields status code 0, assume 200\n    0: 200,\n    // Support: IE <=9 only\n    // #1450: sometimes IE returns 1223 when it should be 204\n    1223: 204\n  },\n      xhrSupported = jQuery.ajaxSettings.xhr();\n  support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n  support.ajax = xhrSupported = !!xhrSupported;\n  jQuery.ajaxTransport(function (options) {\n    var callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest\n\n    if (support.cors || xhrSupported && !options.crossDomain) {\n      return {\n        send: function (headers, complete) {\n          var i,\n              xhr = options.xhr();\n          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided\n\n          if (options.xhrFields) {\n            for (i in options.xhrFields) {\n              xhr[i] = options.xhrFields[i];\n            }\n          } // Override mime type if needed\n\n\n          if (options.mimeType && xhr.overrideMimeType) {\n            xhr.overrideMimeType(options.mimeType);\n          } // X-Requested-With header\n          // For cross-domain requests, seeing as conditions for a preflight are\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\n          // (it can always be set on a per-request basis or even using ajaxSetup)\n          // For same-domain requests, won't change header if already provided.\n\n\n          if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n            headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n          } // Set headers\n\n\n          for (i in headers) {\n            xhr.setRequestHeader(i, headers[i]);\n          } // Callback\n\n\n          callback = function (type) {\n            return function () {\n              if (callback) {\n                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;\n\n                if (type === \"abort\") {\n                  xhr.abort();\n                } else if (type === \"error\") {\n                  // Support: IE <=9 only\n                  // On a manual native abort, IE9 throws\n                  // errors on any property access that is not readyState\n                  if (typeof xhr.status !== \"number\") {\n                    complete(0, \"error\");\n                  } else {\n                    complete( // File: protocol always yields status 0; see #8605, #14207\n                    xhr.status, xhr.statusText);\n                  }\n                } else {\n                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only\n                  // IE9 has no XHR2 but throws on binary (trac-11426)\n                  // For XHR2 non-text, let the caller handle it (gh-2498)\n                  (xhr.responseType || \"text\") !== \"text\" || typeof xhr.responseText !== \"string\" ? {\n                    binary: xhr.response\n                  } : {\n                    text: xhr.responseText\n                  }, xhr.getAllResponseHeaders());\n                }\n              }\n            };\n          }; // Listen to events\n\n\n          xhr.onload = callback();\n          errorCallback = xhr.onerror = xhr.ontimeout = callback(\"error\"); // Support: IE 9 only\n          // Use onreadystatechange to replace onabort\n          // to handle uncaught aborts\n\n          if (xhr.onabort !== undefined) {\n            xhr.onabort = errorCallback;\n          } else {\n            xhr.onreadystatechange = function () {\n              // Check readyState before timeout as it changes\n              if (xhr.readyState === 4) {\n                // Allow onerror to be called first,\n                // but that will not handle a native abort\n                // Also, save errorCallback to a variable\n                // as xhr.onerror cannot be accessed\n                window.setTimeout(function () {\n                  if (callback) {\n                    errorCallback();\n                  }\n                });\n              }\n            };\n          } // Create the abort callback\n\n\n          callback = callback(\"abort\");\n\n          try {\n            // Do send the request (this may raise an exception)\n            xhr.send(options.hasContent && options.data || null);\n          } catch (e) {\n            // #14683: Only rethrow if this hasn't been notified as an error yet\n            if (callback) {\n              throw e;\n            }\n          }\n        },\n        abort: function () {\n          if (callback) {\n            callback();\n          }\n        }\n      };\n    }\n  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\n  jQuery.ajaxPrefilter(function (s) {\n    if (s.crossDomain) {\n      s.contents.script = false;\n    }\n  }); // Install script dataType\n\n  jQuery.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, \" + \"application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /\\b(?:java|ecma)script\\b/\n    },\n    converters: {\n      \"text script\": function (text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  }); // Handle cache's special case and crossDomain\n\n  jQuery.ajaxPrefilter(\"script\", function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n\n    if (s.crossDomain) {\n      s.type = \"GET\";\n    }\n  }); // Bind script tag hack transport\n\n  jQuery.ajaxTransport(\"script\", function (s) {\n    // This transport only deals with cross domain or forced-by-attrs requests\n    if (s.crossDomain || s.scriptAttrs) {\n      var script, callback;\n      return {\n        send: function (_, complete) {\n          script = jQuery(\"<script>\").attr(s.scriptAttrs || {}).prop({\n            charset: s.scriptCharset,\n            src: s.url\n          }).on(\"load error\", callback = function (evt) {\n            script.remove();\n            callback = null;\n\n            if (evt) {\n              complete(evt.type === \"error\" ? 404 : 200, evt.type);\n            }\n          }); // Use native DOM manipulation to avoid our domManip AJAX trickery\n\n          document.head.appendChild(script[0]);\n        },\n        abort: function () {\n          if (callback) {\n            callback();\n          }\n        }\n      };\n    }\n  });\n  var oldCallbacks = [],\n      rjsonp = /(=)\\?(?=&|$)|\\?\\?/; // Default jsonp settings\n\n  jQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function () {\n      var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce.guid++;\n      this[callback] = true;\n      return callback;\n    }\n  }); // Detect, normalize options and install callbacks for jsonp requests\n\n  jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n    var callbackName,\n        overwritten,\n        responseContainer,\n        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0 && rjsonp.test(s.data) && \"data\"); // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\n    if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data\n\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n      } // Use data converter to retrieve json after script execution\n\n\n      s.converters[\"script json\"] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + \" was not called\");\n        }\n\n        return responseContainer[0];\n      }; // Force json dataType\n\n\n      s.dataTypes[0] = \"json\"; // Install callback\n\n      overwritten = window[callbackName];\n\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      }; // Clean-up function (fires after converters)\n\n\n      jqXHR.always(function () {\n        // If previous value didn't exist - remove it\n        if (overwritten === undefined) {\n          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value\n        } else {\n          window[callbackName] = overwritten;\n        } // Save back as free\n\n\n        if (s[callbackName]) {\n          // Make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use\n\n          oldCallbacks.push(callbackName);\n        } // Call if it was a function and we have a response\n\n\n        if (responseContainer && isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n\n        responseContainer = overwritten = undefined;\n      }); // Delegate to script\n\n      return \"script\";\n    }\n  }); // Support: Safari 8 only\n  // In Safari 8 documents created via document.implementation.createHTMLDocument\n  // collapse sibling forms: the second one becomes a child of the first one.\n  // Because of that, this security measure has to be disabled in Safari 8.\n  // https://bugs.webkit.org/show_bug.cgi?id=137337\n\n  support.createHTMLDocument = function () {\n    var body = document.implementation.createHTMLDocument(\"\").body;\n    body.innerHTML = \"<form></form><form></form>\";\n    return body.childNodes.length === 2;\n  }(); // Argument \"data\" should be string of html\n  // context (optional): If specified, the fragment will be created in this context,\n  // defaults to document\n  // keepScripts (optional): If true, will include scripts passed in the html string\n\n\n  jQuery.parseHTML = function (data, context, keepScripts) {\n    if (typeof data !== \"string\") {\n      return [];\n    }\n\n    if (typeof context === \"boolean\") {\n      keepScripts = context;\n      context = false;\n    }\n\n    var base, parsed, scripts;\n\n    if (!context) {\n      // Stop scripts or inline event handlers from being executed immediately\n      // by using document.implementation\n      if (support.createHTMLDocument) {\n        context = document.implementation.createHTMLDocument(\"\"); // Set the base href for the created document\n        // so any parsed elements with URLs\n        // are based on the document's URL (gh-2965)\n\n        base = context.createElement(\"base\");\n        base.href = document.location.href;\n        context.head.appendChild(base);\n      } else {\n        context = document;\n      }\n    }\n\n    parsed = rsingleTag.exec(data);\n    scripts = !keepScripts && []; // Single tag\n\n    if (parsed) {\n      return [context.createElement(parsed[1])];\n    }\n\n    parsed = buildFragment([data], context, scripts);\n\n    if (scripts && scripts.length) {\n      jQuery(scripts).remove();\n    }\n\n    return jQuery.merge([], parsed.childNodes);\n  };\n  /**\n   * Load a url into a page\n   */\n\n\n  jQuery.fn.load = function (url, params, callback) {\n    var selector,\n        type,\n        response,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if (off > -1) {\n      selector = stripAndCollapse(url.slice(off));\n      url = url.slice(0, off);\n    } // If it's a function\n\n\n    if (isFunction(params)) {\n      // We assume that it's the callback\n      callback = params;\n      params = undefined; // Otherwise, build a param string\n    } else if (params && typeof params === \"object\") {\n      type = \"POST\";\n    } // If we have elements to modify, make the request\n\n\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n        // If \"type\" variable is undefined, then \"GET\" method will be used.\n        // Make value of this field explicit since\n        // user can override it through ajaxSetup method\n        type: type || \"GET\",\n        dataType: \"html\",\n        data: params\n      }).done(function (responseText) {\n        // Save response for use in complete callback\n        response = arguments;\n        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n        responseText); // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n        // but they are ignored because response was set above.\n        // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n      }).always(callback && function (jqXHR, status) {\n        self.each(function () {\n          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n        });\n      });\n    }\n\n    return this;\n  };\n\n  jQuery.expr.pseudos.animated = function (elem) {\n    return jQuery.grep(jQuery.timers, function (fn) {\n      return elem === fn.elem;\n    }).length;\n  };\n\n  jQuery.offset = {\n    setOffset: function (elem, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = jQuery.css(elem, \"position\"),\n          curElem = jQuery(elem),\n          props = {}; // Set position first, in-case top/left are set even on static elem\n\n      if (position === \"static\") {\n        elem.style.position = \"relative\";\n      }\n\n      curOffset = curElem.offset();\n      curCSSTop = jQuery.css(elem, \"top\");\n      curCSSLeft = jQuery.css(elem, \"left\");\n      calculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1; // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (isFunction(options)) {\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n        options = options.call(elem, i, jQuery.extend({}, curOffset));\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n\n      if (\"using\" in options) {\n        options.using.call(elem, props);\n      } else {\n        if (typeof props.top === \"number\") {\n          props.top += \"px\";\n        }\n\n        if (typeof props.left === \"number\") {\n          props.left += \"px\";\n        }\n\n        curElem.css(props);\n      }\n    }\n  };\n  jQuery.fn.extend({\n    // offset() relates an element's border box to the document origin\n    offset: function (options) {\n      // Preserve chaining for setter\n      if (arguments.length) {\n        return options === undefined ? this : this.each(function (i) {\n          jQuery.offset.setOffset(this, options, i);\n        });\n      }\n\n      var rect,\n          win,\n          elem = this[0];\n\n      if (!elem) {\n        return;\n      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n      // Support: IE <=11 only\n      // Running getBoundingClientRect on a\n      // disconnected node in IE throws an error\n\n\n      if (!elem.getClientRects().length) {\n        return {\n          top: 0,\n          left: 0\n        };\n      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\n\n      rect = elem.getBoundingClientRect();\n      win = elem.ownerDocument.defaultView;\n      return {\n        top: rect.top + win.pageYOffset,\n        left: rect.left + win.pageXOffset\n      };\n    },\n    // position() relates an element's margin box to its offset parent's padding box\n    // This corresponds to the behavior of CSS absolute positioning\n    position: function () {\n      if (!this[0]) {\n        return;\n      }\n\n      var offsetParent,\n          offset,\n          doc,\n          elem = this[0],\n          parentOffset = {\n        top: 0,\n        left: 0\n      }; // position:fixed elements are offset from the viewport, which itself always has zero offset\n\n      if (jQuery.css(elem, \"position\") === \"fixed\") {\n        // Assume position:fixed implies availability of getBoundingClientRect\n        offset = elem.getBoundingClientRect();\n      } else {\n        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element\n        // when a statically positioned element is identified\n\n        doc = elem.ownerDocument;\n        offsetParent = elem.offsetParent || doc.documentElement;\n\n        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.parentNode;\n        }\n\n        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n          // Incorporate borders into its offset, since they are outside its content origin\n          parentOffset = jQuery(offsetParent).offset();\n          parentOffset.top += jQuery.css(offsetParent, \"borderTopWidth\", true);\n          parentOffset.left += jQuery.css(offsetParent, \"borderLeftWidth\", true);\n        }\n      } // Subtract parent offsets and element margins\n\n\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n      };\n    },\n    // This method will return documentElement in the following cases:\n    // 1) For the element inside the iframe without offsetParent, this method will return\n    //    documentElement of the parent window\n    // 2) For the hidden or detached element\n    // 3) For body or html element, i.e. in case of the html node - it will return itself\n    //\n    // but those exceptions were never presented as a real life use-cases\n    // and might be considered as more preferable results.\n    //\n    // This logic, however, is not guaranteed and can change at any point in the future\n    offsetParent: function () {\n      return this.map(function () {\n        var offsetParent = this.offsetParent;\n\n        while (offsetParent && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || documentElement;\n      });\n    }\n  }); // Create scrollLeft and scrollTop methods\n\n  jQuery.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (method, prop) {\n    var top = \"pageYOffset\" === prop;\n\n    jQuery.fn[method] = function (val) {\n      return access(this, function (elem, method, val) {\n        // Coalesce documents and windows\n        var win;\n\n        if (isWindow(elem)) {\n          win = elem;\n        } else if (elem.nodeType === 9) {\n          win = elem.defaultView;\n        }\n\n        if (val === undefined) {\n          return win ? win[prop] : elem[method];\n        }\n\n        if (win) {\n          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length);\n    };\n  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n  // Add the top/left cssHooks using jQuery.fn.position\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\n  // rather than make the css module depend on the offset module, just check for it here\n\n  jQuery.each([\"top\", \"left\"], function (_i, prop) {\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n      if (computed) {\n        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset\n\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n      }\n    });\n  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\n  jQuery.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (name, type) {\n    jQuery.each({\n      padding: \"inner\" + name,\n      content: type,\n      \"\": \"outer\" + name\n    }, function (defaultExtra, funcName) {\n      // Margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n            extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n        return access(this, function (elem, type, value) {\n          var doc;\n\n          if (isWindow(elem)) {\n            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n            return funcName.indexOf(\"outer\") === 0 ? elem[\"inner\" + name] : elem.document.documentElement[\"client\" + name];\n          } // Get document width or height\n\n\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n            // whichever is greatest\n\n            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n          }\n\n          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) : // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable);\n      };\n    });\n  });\n  jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (_i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n  jQuery.fn.extend({\n    bind: function (types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function (types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function (selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function (selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    },\n    hover: function (fnOver, fnOut) {\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n    }\n  });\n  jQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function (_i, name) {\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  }); // Support: Android <=4.0 only\n  // Make sure we trim BOM and NBSP\n\n  var rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g; // Bind a function to a context, optionally partially applying any\n  // arguments.\n  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n  // However, it is not slated for removal any time soon\n\n  jQuery.proxy = function (fn, context) {\n    var tmp, args, proxy;\n\n    if (typeof context === \"string\") {\n      tmp = fn[context];\n      context = fn;\n      fn = tmp;\n    } // Quick check to determine if target is callable, in the spec\n    // this throws a TypeError, but we will just return undefined.\n\n\n    if (!isFunction(fn)) {\n      return undefined;\n    } // Simulated bind\n\n\n    args = slice.call(arguments, 2);\n\n    proxy = function () {\n      return fn.apply(context || this, args.concat(slice.call(arguments)));\n    }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n    proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n    return proxy;\n  };\n\n  jQuery.holdReady = function (hold) {\n    if (hold) {\n      jQuery.readyWait++;\n    } else {\n      jQuery.ready(true);\n    }\n  };\n\n  jQuery.isArray = Array.isArray;\n  jQuery.parseJSON = JSON.parse;\n  jQuery.nodeName = nodeName;\n  jQuery.isFunction = isFunction;\n  jQuery.isWindow = isWindow;\n  jQuery.camelCase = camelCase;\n  jQuery.type = toType;\n  jQuery.now = Date.now;\n\n  jQuery.isNumeric = function (obj) {\n    // As of jQuery 3.0, isNumeric is limited to\n    // strings and numbers (primitives or objects)\n    // that can be coerced to finite numbers (gh-2662)\n    var type = jQuery.type(obj);\n    return (type === \"number\" || type === \"string\") && // parseFloat NaNs numeric-cast false positives (\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    !isNaN(obj - parseFloat(obj));\n  };\n\n  jQuery.trim = function (text) {\n    return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n  }; // Register as a named AMD module, since jQuery can be concatenated with other\n  // files that may use define, but not via a proper concatenation script that\n  // understands anonymous AMD modules. A named AMD is safest and most robust\n  // way to register. Lowercase jquery is used because AMD module names are\n  // derived from file names, and jQuery is normally delivered in a lowercase\n  // file name. Do this after creating the global so that if an AMD module wants\n  // to call noConflict to hide this version of jQuery, it will work.\n  // Note that for maximum portability, libraries that are not jQuery should\n  // declare themselves as anonymous modules, and avoid setting a global if an\n  // AMD loader is present. jQuery is a special case. For more information, see\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jQuery;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  var // Map over jQuery in case of overwrite\n  _jQuery = window.jQuery,\n      // Map over the $ in case of overwrite\n  _$ = window.$;\n\n  jQuery.noConflict = function (deep) {\n    if (window.$ === jQuery) {\n      window.$ = _$;\n    }\n\n    if (deep && window.jQuery === jQuery) {\n      window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n  }; // Expose jQuery and $ identifiers, even in AMD\n  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n  // and CommonJS for browser emulators (#13566)\n\n\n  if (typeof noGlobal === \"undefined\") {\n    window.jQuery = window.$ = jQuery;\n  }\n\n  return jQuery;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcz9hMzlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My41LjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIwLTA1LTA0VDIyOjQ5WlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG4gICAgLy8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cbiAgICAvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuICAgIC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuICAgIC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG4gICAgLy8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuICAgIC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgPyBmYWN0b3J5KGdsb2JhbCwgdHJ1ZSkgOiBmdW5jdGlvbiAodykge1xuICAgICAgaWYgKCF3LmRvY3VtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWN0b3J5KHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeShnbG9iYWwpO1xuICB9IC8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG5cbn0pKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAod2luZG93LCBub0dsb2JhbCkge1xuICAvLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbiAgLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4gIC8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4gIC8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgYXJyID0gW107XG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuICB2YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgcmV0dXJuIGFyci5mbGF0LmNhbGwoYXJyYXkpO1xuICB9IDogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgcmV0dXJuIGFyci5jb25jYXQuYXBwbHkoW10sIGFycmF5KTtcbiAgfTtcbiAgdmFyIHB1c2ggPSBhcnIucHVzaDtcbiAgdmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcbiAgdmFyIGNsYXNzMnR5cGUgPSB7fTtcbiAgdmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcbiAgdmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuICB2YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoT2JqZWN0KTtcbiAgdmFyIHN1cHBvcnQgPSB7fTtcblxuICB2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgfTtcblxuICB2YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuICB9O1xuXG4gIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgdmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG4gICAgdHlwZTogdHJ1ZSxcbiAgICBzcmM6IHRydWUsXG4gICAgbm9uY2U6IHRydWUsXG4gICAgbm9Nb2R1bGU6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBET01FdmFsKGNvZGUsIG5vZGUsIGRvYykge1xuICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICB2YXIgaSxcbiAgICAgICAgdmFsLFxuICAgICAgICBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBzY3JpcHQudGV4dCA9IGNvZGU7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgZm9yIChpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA2NCssIEVkZ2UgMTgrXG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXG4gICAgICAgIC8vIE9uIHRoZSBvdGhlciBoYW5kLCBqdXN0IHVzaW5nIGBnZXRBdHRyaWJ1dGVgIGlzIG5vdCBlbm91Z2ggYXNcbiAgICAgICAgLy8gdGhlIGBub25jZWAgYXR0cmlidXRlIGlzIHJlc2V0IHRvIGFuIGVtcHR5IHN0cmluZyB3aGVuZXZlciBpdFxuICAgICAgICAvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG4gICAgICAgIC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNub25jZS1hdHRyaWJ1dGVzXG4gICAgICAgIC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2ZcbiAgICAgICAgLy8gYGpRdWVyeS5nbG9iYWxFdmFsYCBzbyB0aGF0IGl0IGNhbiBmYWtlIGEgbm9uY2UtY29udGFpbmluZyBub2RlXG4gICAgICAgIC8vIHZpYSBhbiBvYmplY3QuXG4gICAgICAgIHZhbCA9IG5vZGVbaV0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoaSk7XG5cbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoaSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRvYy5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9UeXBlKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iaiArIFwiXCI7XG4gICAgfSAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblxuXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID8gY2xhc3MydHlwZVt0b1N0cmluZy5jYWxsKG9iaildIHx8IFwib2JqZWN0XCIgOiB0eXBlb2Ygb2JqO1xuICB9XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbiAgLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG4gIHZhciB2ZXJzaW9uID0gXCIzLjUuMVwiLFxuICAgICAgLy8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcbiAgalF1ZXJ5ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgLy8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG4gICAgLy8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcbiAgICByZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KHNlbGVjdG9yLCBjb250ZXh0KTtcbiAgfTtcblxuICBqUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuICAgIC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcbiAgICBqcXVlcnk6IHZlcnNpb24sXG4gICAgY29uc3RydWN0b3I6IGpRdWVyeSxcbiAgICAvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcbiAgICBsZW5ndGg6IDAsXG4gICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICAvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG4gICAgLy8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcbiAgICBnZXQ6IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcbiAgICAgIGlmIChudW0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2xpY2UuY2FsbCh0aGlzKTtcbiAgICAgIH0gLy8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXG5cbiAgICAgIHJldHVybiBudW0gPCAwID8gdGhpc1tudW0gKyB0aGlzLmxlbmd0aF0gOiB0aGlzW251bV07XG4gICAgfSxcbiAgICAvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG4gICAgLy8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG4gICAgcHVzaFN0YWNrOiBmdW5jdGlvbiAoZWxlbXMpIHtcbiAgICAgIC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG4gICAgICB2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMpOyAvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXG4gICAgICByZXQucHJldk9iamVjdCA9IHRoaXM7IC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICAvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGpRdWVyeS5lYWNoKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiAoZWxlbSwgaSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChlbGVtLCBpLCBlbGVtKTtcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIHNsaWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBmaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXEoMCk7XG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcSgtMSk7XG4gICAgfSxcbiAgICBldmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soalF1ZXJ5LmdyZXAodGhpcywgZnVuY3Rpb24gKF9lbGVtLCBpKSB7XG4gICAgICAgIHJldHVybiAoaSArIDEpICUgMjtcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIG9kZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGpRdWVyeS5ncmVwKHRoaXMsIGZ1bmN0aW9uIChfZWxlbSwgaSkge1xuICAgICAgICByZXR1cm4gaSAlIDI7XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBlcTogZnVuY3Rpb24gKGkpIHtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICBqID0gK2kgKyAoaSA8IDAgPyBsZW4gOiAwKTtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqID49IDAgJiYgaiA8IGxlbiA/IFt0aGlzW2pdXSA6IFtdKTtcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgfSxcbiAgICAvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgLy8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG4gICAgcHVzaDogcHVzaCxcbiAgICBzb3J0OiBhcnIuc29ydCxcbiAgICBzcGxpY2U6IGFyci5zcGxpY2VcbiAgfTtcblxuICBqUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3JjLFxuICAgICAgICBjb3B5LFxuICAgICAgICBjb3B5SXNBcnJheSxcbiAgICAgICAgY2xvbmUsXG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGRlZXAgPSBmYWxzZTsgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBkZWVwID0gdGFyZ2V0OyAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cbiAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXSB8fCB7fTtcbiAgICAgIGkrKztcbiAgICB9IC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXG5cbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQgPSB7fTtcbiAgICB9IC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXG5cbiAgICBpZiAoaSA9PT0gbGVuZ3RoKSB7XG4gICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgaS0tO1xuICAgIH1cblxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgIGlmICgob3B0aW9ucyA9IGFyZ3VtZW50c1tpXSkgIT0gbnVsbCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG4gICAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY29weSA9IG9wdGlvbnNbbmFtZV07IC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cbiAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cbiAgICAgICAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fCB0YXJnZXQgPT09IGNvcHkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cblxuICAgICAgICAgIGlmIChkZWVwICYmIGNvcHkgJiYgKGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29weSkpKSkge1xuICAgICAgICAgICAgc3JjID0gdGFyZ2V0W25hbWVdOyAvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcblxuICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgICAgICAgY2xvbmUgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpKSB7XG4gICAgICAgICAgICAgIGNsb25lID0ge307XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjbG9uZSA9IHNyYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTsgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGpRdWVyeS5leHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpOyAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgfSBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIGpRdWVyeS5leHRlbmQoe1xuICAgIC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuICAgIGV4cGFuZG86IFwialF1ZXJ5XCIgKyAodmVyc2lvbiArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSxcbiAgICAvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuICAgIGlzUmVhZHk6IHRydWUsXG4gICAgZXJyb3I6IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH0sXG4gICAgbm9vcDogZnVuY3Rpb24gKCkge30sXG4gICAgaXNQbGFpbk9iamVjdDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgdmFyIHByb3RvLCBDdG9yOyAvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcbiAgICAgIC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXG4gICAgICBpZiAoIW9iaiB8fCB0b1N0cmluZy5jYWxsKG9iaikgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBwcm90byA9IGdldFByb3RvKG9iaik7IC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblxuICAgICAgaWYgKCFwcm90bykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblxuXG4gICAgICBDdG9yID0gaGFzT3duLmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoQ3RvcikgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuICAgIH0sXG4gICAgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgdmFyIG5hbWU7XG5cbiAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcbiAgICAvLyBpZiBub3Qgc3BlY2lmaWVkLlxuICAgIGdsb2JhbEV2YWw6IGZ1bmN0aW9uIChjb2RlLCBvcHRpb25zLCBkb2MpIHtcbiAgICAgIERPTUV2YWwoY29kZSwge1xuICAgICAgICBub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlXG4gICAgICB9LCBkb2MpO1xuICAgIH0sXG4gICAgZWFjaDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsZW5ndGgsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICAgIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgIG1ha2VBcnJheTogZnVuY3Rpb24gKGFyciwgcmVzdWx0cykge1xuICAgICAgdmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cbiAgICAgIGlmIChhcnIgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UoT2JqZWN0KGFycikpKSB7XG4gICAgICAgICAgalF1ZXJ5Lm1lcmdlKHJldCwgdHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/IFthcnJdIDogYXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoLmNhbGwocmV0LCBhcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBpbkFycmF5OiBmdW5jdGlvbiAoZWxlbSwgYXJyLCBpKSB7XG4gICAgICByZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbChhcnIsIGVsZW0sIGkpO1xuICAgIH0sXG4gICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgIG1lcmdlOiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgdmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuICAgICAgICAgIGogPSAwLFxuICAgICAgICAgIGkgPSBmaXJzdC5sZW5ndGg7XG5cbiAgICAgIGZvciAoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgZmlyc3RbaSsrXSA9IHNlY29uZFtqXTtcbiAgICAgIH1cblxuICAgICAgZmlyc3QubGVuZ3RoID0gaTtcbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9LFxuICAgIGdyZXA6IGZ1bmN0aW9uIChlbGVtcywgY2FsbGJhY2ssIGludmVydCkge1xuICAgICAgdmFyIGNhbGxiYWNrSW52ZXJzZSxcbiAgICAgICAgICBtYXRjaGVzID0gW10sXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuICAgICAgICAgIGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDsgLy8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuICAgICAgLy8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblxuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soZWxlbXNbaV0sIGkpO1xuXG4gICAgICAgIGlmIChjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0KSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKGVsZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9LFxuICAgIC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgIG1hcDogZnVuY3Rpb24gKGVsZW1zLCBjYWxsYmFjaywgYXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIHJldCA9IFtdOyAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXG4gICAgICBpZiAoaXNBcnJheUxpa2UoZWxlbXMpKSB7XG4gICAgICAgIGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBlbGVtcykge1xuICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbXNbaV0sIGksIGFyZyk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cblxuICAgICAgcmV0dXJuIGZsYXQocmV0KTtcbiAgICB9LFxuICAgIC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuICAgIGd1aWQ6IDEsXG4gICAgLy8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG4gICAgLy8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cbiAgICBzdXBwb3J0OiBzdXBwb3J0XG4gIH0pO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBqUXVlcnkuZm5bU3ltYm9sLml0ZXJhdG9yXSA9IGFycltTeW1ib2wuaXRlcmF0b3JdO1xuICB9IC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxuXG5cbiAgalF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24gKF9pLCBuYW1lKSB7XG4gICAgY2xhc3MydHlwZVtcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCJdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9KTtcblxuICBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcbiAgICAvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG4gICAgLy8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuICAgIC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuICAgIC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcbiAgICB2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcbiAgICAgICAgdHlwZSA9IHRvVHlwZShvYmopO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSB8fCBpc1dpbmRvdyhvYmopKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHwgdHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmIGxlbmd0aCAtIDEgaW4gb2JqO1xuICB9XG5cbiAgdmFyIFNpenpsZSA9XG4gIC8qIVxuICAgKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjVcbiAgICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gICAqXG4gICAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gICAqIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cbiAgICpcbiAgICogRGF0ZTogMjAyMC0wMy0xNFxuICAgKi9cbiAgZnVuY3Rpb24gKHdpbmRvdykge1xuICAgIHZhciBpLFxuICAgICAgICBzdXBwb3J0LFxuICAgICAgICBFeHByLFxuICAgICAgICBnZXRUZXh0LFxuICAgICAgICBpc1hNTCxcbiAgICAgICAgdG9rZW5pemUsXG4gICAgICAgIGNvbXBpbGUsXG4gICAgICAgIHNlbGVjdCxcbiAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCxcbiAgICAgICAgc29ydElucHV0LFxuICAgICAgICBoYXNEdXBsaWNhdGUsXG4gICAgICAgIC8vIExvY2FsIGRvY3VtZW50IHZhcnNcbiAgICBzZXREb2N1bWVudCxcbiAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgIGRvY0VsZW0sXG4gICAgICAgIGRvY3VtZW50SXNIVE1MLFxuICAgICAgICByYnVnZ3lRU0EsXG4gICAgICAgIHJidWdneU1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGNvbnRhaW5zLFxuICAgICAgICAvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG4gICAgZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcbiAgICAgICAgcHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICBkaXJydW5zID0gMCxcbiAgICAgICAgZG9uZSA9IDAsXG4gICAgICAgIGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICB0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgY29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICBzb3J0T3JkZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICAgICAgLy8gSW5zdGFuY2UgbWV0aG9kc1xuICAgIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgICAgICBhcnIgPSBbXSxcbiAgICAgICAgcG9wID0gYXJyLnBvcCxcbiAgICAgICAgcHVzaE5hdGl2ZSA9IGFyci5wdXNoLFxuICAgICAgICBwdXNoID0gYXJyLnB1c2gsXG4gICAgICAgIHNsaWNlID0gYXJyLnNsaWNlLFxuICAgICAgICAvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAgICAvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG4gICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChsaXN0LCBlbGVtKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGxpc3RbaV0gPT09IGVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICAgICAgYm9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxcIiArIFwiaXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuICAgICAgICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2VcbiAgICB3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpZGVudC10b2tlbi1kaWFncmFtXG4gICAgaWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuICAgICAgICAvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcbiAgICBhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgKyAvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuICAgIFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArIC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XVxuICAgIC8vIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcbiAgICBcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG4gICAgICAgIHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgKyAvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuICAgIC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuICAgIFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgKyAvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcbiAgICBcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArIC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcbiAgICBcIi4qXCIgKyBcIilcXFxcKXwpXCIsXG4gICAgICAgIC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcbiAgICByd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAod2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiksXG4gICAgICAgIHJ0cmltID0gbmV3IFJlZ0V4cChcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiksXG4gICAgICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcbiAgICAgICAgcmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cChcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIpLFxuICAgICAgICByZGVzY2VuZCA9IG5ldyBSZWdFeHAod2hpdGVzcGFjZSArIFwifD5cIiksXG4gICAgICAgIHJwc2V1ZG8gPSBuZXcgUmVnRXhwKHBzZXVkb3MpLFxuICAgICAgICByaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIpLFxuICAgICAgICBtYXRjaEV4cHIgPSB7XG4gICAgICBcIklEXCI6IG5ldyBSZWdFeHAoXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiksXG4gICAgICBcIkNMQVNTXCI6IG5ldyBSZWdFeHAoXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIpLFxuICAgICAgXCJUQUdcIjogbmV3IFJlZ0V4cChcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiKSxcbiAgICAgIFwiQVRUUlwiOiBuZXcgUmVnRXhwKFwiXlwiICsgYXR0cmlidXRlcyksXG4gICAgICBcIlBTRVVET1wiOiBuZXcgUmVnRXhwKFwiXlwiICsgcHNldWRvcyksXG4gICAgICBcIkNISUxEXCI6IG5ldyBSZWdFeHAoXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiksXG4gICAgICBcImJvb2xcIjogbmV3IFJlZ0V4cChcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiksXG4gICAgICAvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcbiAgICAgIC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcbiAgICAgIFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIilcbiAgICB9LFxuICAgICAgICByaHRtbCA9IC9IVE1MJC9pLFxuICAgICAgICByaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICAgICAgcmhlYWRlciA9IC9eaFxcZCQvaSxcbiAgICAgICAgcm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG4gICAgICAgIC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuICAgIHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcbiAgICAgICAgcnNpYmxpbmcgPSAvWyt+XS8sXG4gICAgICAgIC8vIENTUyBlc2NhcGVzXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuICAgIHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiKSxcbiAgICAgICAgZnVuZXNjYXBlID0gZnVuY3Rpb24gKGVzY2FwZSwgbm9uSGV4KSB7XG4gICAgICB2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZS5zbGljZSgxKSAtIDB4MTAwMDA7XG4gICAgICByZXR1cm4gbm9uSGV4ID8gLy8gU3RyaXAgdGhlIGJhY2tzbGFzaCBwcmVmaXggZnJvbSBhIG5vbi1oZXggZXNjYXBlIHNlcXVlbmNlXG4gICAgICBub25IZXggOiAvLyBSZXBsYWNlIGEgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlIHdpdGggdGhlIGVuY29kZWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAvLyBTdXBwb3J0OiBJRSA8PTExK1xuICAgICAgLy8gRm9yIHZhbHVlcyBvdXRzaWRlIHRoZSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmUgKEJNUCksIG1hbnVhbGx5IGNvbnN0cnVjdCBhXG4gICAgICAvLyBzdXJyb2dhdGUgcGFpclxuICAgICAgaGlnaCA8IDAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGhpZ2ggKyAweDEwMDAwKSA6IFN0cmluZy5mcm9tQ2hhckNvZGUoaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwKTtcbiAgICB9LFxuICAgICAgICAvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuICAgIHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcbiAgICAgICAgZmNzc2VzY2FwZSA9IGZ1bmN0aW9uIChjaCwgYXNDb2RlUG9pbnQpIHtcbiAgICAgIGlmIChhc0NvZGVQb2ludCkge1xuICAgICAgICAvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgICAgaWYgKGNoID09PSBcIlxcMFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXFx1RkZGRFwiO1xuICAgICAgICB9IC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cblxuICAgICAgICByZXR1cm4gY2guc2xpY2UoMCwgLTEpICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KGNoLmxlbmd0aCAtIDEpLnRvU3RyaW5nKDE2KSArIFwiIFwiO1xuICAgICAgfSAvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cblxuICAgICAgcmV0dXJuIFwiXFxcXFwiICsgY2g7XG4gICAgfSxcbiAgICAgICAgLy8gVXNlZCBmb3IgaWZyYW1lc1xuICAgIC8vIFNlZSBzZXREb2N1bWVudCgpXG4gICAgLy8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG4gICAgLy8gZXJyb3IgaW4gSUVcbiAgICB1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0RG9jdW1lbnQoKTtcbiAgICB9LFxuICAgICAgICBpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcbiAgICB9LCB7XG4gICAgICBkaXI6IFwicGFyZW50Tm9kZVwiLFxuICAgICAgbmV4dDogXCJsZWdlbmRcIlxuICAgIH0pOyAvLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxuXG5cbiAgICB0cnkge1xuICAgICAgcHVzaC5hcHBseShhcnIgPSBzbGljZS5jYWxsKHByZWZlcnJlZERvYy5jaGlsZE5vZGVzKSwgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMpOyAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuICAgICAgLy8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gICAgICBhcnJbcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBwdXNoID0ge1xuICAgICAgICBhcHBseTogYXJyLmxlbmd0aCA/IC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG4gICAgICAgIGZ1bmN0aW9uICh0YXJnZXQsIGVscykge1xuICAgICAgICAgIHB1c2hOYXRpdmUuYXBwbHkodGFyZ2V0LCBzbGljZS5jYWxsKGVscykpO1xuICAgICAgICB9IDogLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG4gICAgICAgIGZ1bmN0aW9uICh0YXJnZXQsIGVscykge1xuICAgICAgICAgIHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgaSA9IDA7IC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXG4gICAgICAgICAgd2hpbGUgKHRhcmdldFtqKytdID0gZWxzW2krK10pIHt9XG5cbiAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU2l6emxlKHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKSB7XG4gICAgICB2YXIgbSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgbmlkLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGdyb3VwcyxcbiAgICAgICAgICBuZXdTZWxlY3RvcixcbiAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgLy8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuICAgICAgbm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTsgLy8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHwgbm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSAvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cblxuICAgICAgaWYgKCFzZWVkKSB7XG4gICAgICAgIHNldERvY3VtZW50KGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuICAgICAgICBpZiAoZG9jdW1lbnRJc0hUTUwpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuICAgICAgICAgIC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcbiAgICAgICAgICBpZiAobm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyhzZWxlY3RvcikpKSB7XG4gICAgICAgICAgICAvLyBJRCBzZWxlY3RvclxuICAgICAgICAgICAgaWYgKG0gPSBtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAvLyBEb2N1bWVudCBjb250ZXh0XG4gICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChtKSkge1xuICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbS5pZCA9PT0gbSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9IC8vIEVsZW1lbnQgY29udGV4dFxuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICBpZiAobmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQobSkpICYmIGNvbnRhaW5zKGNvbnRleHQsIGVsZW0pICYmIGVsZW0uaWQgPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBUeXBlIHNlbGVjdG9yXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKSk7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzOyAvLyBDbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgfSBlbHNlIGlmICgobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG0pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cblxuICAgICAgICAgIGlmIChzdXBwb3J0LnFzYSAmJiAhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVtzZWxlY3RvciArIFwiIFwiXSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3Qoc2VsZWN0b3IpKSAmJiAoIC8vIFN1cHBvcnQ6IElFIDggb25seVxuICAgICAgICAgIC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG4gICAgICAgICAgbm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0OyAvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG4gICAgICAgICAgICAvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuICAgICAgICAgICAgLy8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcbiAgICAgICAgICAgIC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cbiAgICAgICAgICAgIC8vIFRoZSB0ZWNobmlxdWUgaGFzIHRvIGJlIHVzZWQgYXMgd2VsbCB3aGVuIGEgbGVhZGluZyBjb21iaW5hdG9yIGlzIHVzZWRcbiAgICAgICAgICAgIC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuICAgICAgICAgICAgLy8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgJiYgKHJkZXNjZW5kLnRlc3Qoc2VsZWN0b3IpIHx8IHJjb21iaW5hdG9ycy50ZXN0KHNlbGVjdG9yKSkpIHtcbiAgICAgICAgICAgICAgLy8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG4gICAgICAgICAgICAgIG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KHNlbGVjdG9yKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHQ7IC8vIFdlIGNhbiB1c2UgOnNjb3BlIGluc3RlYWQgb2YgdGhlIElEIGhhY2sgaWYgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgICAgLy8gc3VwcG9ydHMgaXQgJiBpZiB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIGNvbnRleHQuXG5cbiAgICAgICAgICAgICAgaWYgKG5ld0NvbnRleHQgIT09IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSB7XG4gICAgICAgICAgICAgICAgICBuaWQgPSBuaWQucmVwbGFjZShyY3NzZXNjYXBlLCBmY3NzZXNjYXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBuaWQgPSBleHBhbmRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cblxuICAgICAgICAgICAgICBncm91cHMgPSB0b2tlbml6ZShzZWxlY3Rvcik7XG4gICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBncm91cHNbaV0gPSAobmlkID8gXCIjXCIgKyBuaWQgOiBcIjpzY29wZVwiKSArIFwiIFwiICsgdG9TZWxlY3Rvcihncm91cHNbaV0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBncm91cHMuam9pbihcIixcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgbmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKG5ld1NlbGVjdG9yKSk7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBjYXRjaCAocXNhRXJyb3IpIHtcbiAgICAgICAgICAgICAgbm9ubmF0aXZlU2VsZWN0b3JDYWNoZShzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAobmlkID09PSBleHBhbmRvKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBBbGwgb3RoZXJzXG5cblxuICAgICAgcmV0dXJuIHNlbGVjdChzZWxlY3Rvci5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICAgICAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICAgICAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gY2FjaGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuICAgICAgICBpZiAoa2V5cy5wdXNoKGtleSArIFwiIFwiKSA+IEV4cHIuY2FjaGVMZW5ndGgpIHtcbiAgICAgICAgICAvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcbiAgICAgICAgICBkZWxldGUgY2FjaGVba2V5cy5zaGlmdCgpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZVtrZXkgKyBcIiBcIl0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIG1hcmtGdW5jdGlvbihmbikge1xuICAgICAgZm5bZXhwYW5kb10gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGZuKSB7XG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIWZuKGVsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH0gLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblxuXG4gICAgICAgIGVsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gYWRkSGFuZGxlKGF0dHJzLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuICAgICAgICAgIGkgPSBhcnIubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIEV4cHIuYXR0ckhhbmRsZVthcnJbaV1dID0gaGFuZGxlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBzaWJsaW5nQ2hlY2soYSwgYikge1xuICAgICAgdmFyIGN1ciA9IGIgJiYgYSxcbiAgICAgICAgICBkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJiBhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDsgLy8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgfSAvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXG5cbiAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgd2hpbGUgKGN1ciA9IGN1ci5uZXh0U2libGluZykge1xuICAgICAgICAgIGlmIChjdXIgPT09IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEgPyAxIDogLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyh0eXBlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKHR5cGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKGRpc2FibGVkKSB7XG4gICAgICAvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG4gICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG4gICAgICAgIGlmIChcImZvcm1cIiBpbiBlbGVtKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuICAgICAgICAgIC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG4gICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG4gICAgICAgICAgLy8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuICAgICAgICAgIC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cbiAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKFwibGFiZWxcIiBpbiBlbGVtKSB7XG4gICAgICAgICAgICAgIGlmIChcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuICAgICAgICAgICAgLy8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fCAvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXG4gICAgICAgICAgICAvKiBqc2hpbnQgLVcwMTggKi9cbiAgICAgICAgICAgIGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmIGluRGlzYWJsZWRGaWVsZHNldChlbGVtKSA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkOyAvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG4gICAgICAgICAgLy8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG4gICAgICAgICAgLy8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICAgIH0gZWxzZSBpZiAoXCJsYWJlbFwiIGluIGVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgIH0gLy8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZuKSB7XG4gICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICBhcmd1bWVudCA9ICthcmd1bWVudDtcbiAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcykge1xuICAgICAgICAgIHZhciBqLFxuICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMgPSBmbihbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50KSxcbiAgICAgICAgICAgICAgaSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7IC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYgKHNlZWRbaiA9IG1hdGNoSW5kZXhlc1tpXV0pIHtcbiAgICAgICAgICAgICAgc2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gICAgICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHRlc3RDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG4gICAgfSAvLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuXG5cbiAgICBzdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIFhNTCBub2Rlc1xuICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICAgICAqL1xuXG4gICAgaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IGVsZW0ubmFtZXNwYWNlVVJJLFxuICAgICAgICAgIGRvY0VsZW0gPSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDsgLy8gU3VwcG9ydDogSUUgPD04XG4gICAgICAvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG4gICAgICAvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNDgzM1xuXG4gICAgICByZXR1cm4gIXJodG1sLnRlc3QobmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgKi9cblxuXG4gICAgc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGhhc0NvbXBhcmUsXG4gICAgICAgICAgc3ViV2luZG93LFxuICAgICAgICAgIGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYzsgLy8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG4gICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cbiAgICAgIGlmIChkb2MgPT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgIH0gLy8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblxuXG4gICAgICBkb2N1bWVudCA9IGRvYztcbiAgICAgIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBkb2N1bWVudElzSFRNTCA9ICFpc1hNTChkb2N1bWVudCk7IC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcbiAgICAgIC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcbiAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG4gICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cbiAgICAgIGlmIChwcmVmZXJyZWREb2MgIT0gZG9jdW1lbnQgJiYgKHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cpIHtcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEsIEVkZ2VcbiAgICAgICAgaWYgKHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UpOyAvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuICAgICAgICB9IGVsc2UgaWYgKHN1YldpbmRvdy5hdHRhY2hFdmVudCkge1xuICAgICAgICAgIHN1YldpbmRvdy5hdHRhY2hFdmVudChcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFN1cHBvcnQ6IElFIDggLSAxMSssIEVkZ2UgMTIgLSAxOCssIENocm9tZSA8PTE2IC0gMjUgb25seSwgRmlyZWZveCA8PTMuNiAtIDMxIG9ubHksXG4gICAgICAvLyBTYWZhcmkgNCAtIDUgb25seSwgT3BlcmEgPD0xMS42IC0gMTIueCBvbmx5XG4gICAgICAvLyBJRS9FZGdlICYgb2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgOnNjb3BlIHBzZXVkby1jbGFzcy5cbiAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjAgb25seVxuICAgICAgLy8gU2FmYXJpIDYuMCBzdXBwb3J0cyA6c2NvcGUgYnV0IGl0J3MgYW4gYWxpYXMgb2YgOnJvb3QgdGhlcmUuXG5cblxuICAgICAgc3VwcG9ydC5zY29wZSA9IGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZWwucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSBmaWVsZHNldCBkaXZcIikubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgICAvKiBBdHRyaWJ1dGVzXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAvLyBTdXBwb3J0OiBJRTw4XG4gICAgICAvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcbiAgICAgIC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXG4gICAgICBzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuICAgICAgICByZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcbiAgICAgIH0pO1xuICAgICAgLyogZ2V0RWxlbWVudChzKUJ5KlxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXG4gICAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpKTtcbiAgICAgICAgcmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuICAgICAgfSk7IC8vIFN1cHBvcnQ6IElFPDlcblxuICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpOyAvLyBTdXBwb3J0OiBJRTwxMFxuICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG4gICAgICAvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcbiAgICAgIC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXG4gICAgICBzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZWwpLmlkID0gZXhwYW5kbztcbiAgICAgICAgcmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoZXhwYW5kbykubGVuZ3RoO1xuICAgICAgfSk7IC8vIElEIGZpbHRlciBhbmQgZmluZFxuXG4gICAgICBpZiAoc3VwcG9ydC5nZXRCeUlkKSB7XG4gICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiAoaWQsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwpIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSA/IFtlbGVtXSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTsgLy8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cblxuICAgICAgICBFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uIChpZCwgY29udGV4dCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCkge1xuICAgICAgICAgICAgdmFyIG5vZGUsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBlbGVtcyxcbiAgICAgICAgICAgICAgICBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG4gICAgICAgICAgICAgIG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblxuICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbV07XG4gICAgICAgICAgICAgIH0gLy8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cblxuICAgICAgICAgICAgICBlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoaWQpO1xuICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgICB3aGlsZSAoZWxlbSA9IGVsZW1zW2krK10pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gLy8gVGFnXG5cblxuICAgICAgRXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uICh0YWcsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTsgLy8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5xc2EpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHRhZyk7XG4gICAgICAgIH1cbiAgICAgIH0gOiBmdW5jdGlvbiAodGFnLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgdG1wID0gW10sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cbiAgICAgICAgcmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTsgLy8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXG4gICAgICAgIGlmICh0YWcgPT09IFwiKlwiKSB7XG4gICAgICAgICAgd2hpbGUgKGVsZW0gPSByZXN1bHRzW2krK10pIHtcbiAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIHRtcC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH07IC8vIENsYXNzXG5cbiAgICAgIEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uIChjbGFzc05hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG4gICAgICAvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXG5cbiAgICAgIHJidWdneU1hdGNoZXMgPSBbXTsgLy8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcbiAgICAgIC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuICAgICAgLy8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuICAgICAgLy8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3JcbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblxuICAgICAgcmJ1Z2d5UVNBID0gW107XG5cbiAgICAgIGlmIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKSkge1xuICAgICAgICAvLyBCdWlsZCBRU0EgcmVnZXhcbiAgICAgICAgLy8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuICAgICAgICBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgdmFyIGlucHV0OyAvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG4gICAgICAgICAgLy8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG4gICAgICAgICAgLy8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG4gICAgICAgICAgLy8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcbiAgICAgICAgICAvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblxuICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZWwpLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgKyBcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICsgXCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiOyAvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG4gICAgICAgICAgLy8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuICAgICAgICAgIC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuICAgICAgICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXG4gICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIpO1xuICAgICAgICAgIH0gLy8gU3VwcG9ydDogSUU4XG4gICAgICAgICAgLy8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXG5cbiAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIik7XG4gICAgICAgICAgfSAvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblxuXG4gICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcbiAgICAgICAgICB9IC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNSAtIDE4K1xuICAgICAgICAgIC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG4gICAgICAgICAgLy8gQWRkaW5nIGEgdGVtcG9yYXJ5IGF0dHJpYnV0ZSB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBzZWxlY3Rpb24gd29ya3NcbiAgICAgICAgICAvLyBhcm91bmQgdGhlIGlzc3VlLlxuICAgICAgICAgIC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblxuXG4gICAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIlwiKTtcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChpbnB1dCk7XG5cbiAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT0nJ11cIikubGVuZ3RoKSB7XG4gICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIik7XG4gICAgICAgICAgfSAvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblxuXG4gICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuICAgICAgICAgIH0gLy8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcbiAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG4gICAgICAgICAgLy8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXG5cbiAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuICAgICAgICAgIH0gLy8gU3VwcG9ydDogRmlyZWZveCA8PTMuNiAtIDUgb25seVxuICAgICAgICAgIC8vIE9sZCBGaXJlZm94IGRvZXNuJ3QgdGhyb3cgb24gYSBiYWRseS1lc2NhcGVkIGlkZW50aWZpZXIuXG5cblxuICAgICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJcXFxcXFxmXCIpO1xuICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiW1xcXFxyXFxcXG5cXFxcZl1cIik7XG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICsgXCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7IC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuICAgICAgICAgIC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXG4gICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoaW5wdXQpLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJEXCIpOyAvLyBTdXBwb3J0OiBJRThcbiAgICAgICAgICAvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblxuICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoKSB7XG4gICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIpO1xuICAgICAgICAgIH0gLy8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcbiAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXG5cbiAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKTtcbiAgICAgICAgICB9IC8vIFN1cHBvcnQ6IElFOS0xMStcbiAgICAgICAgICAvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblxuXG4gICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuZGlzYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpO1xuICAgICAgICAgIH0gLy8gU3VwcG9ydDogT3BlcmEgMTAgLSAxMSBvbmx5XG4gICAgICAgICAgLy8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3NcblxuXG4gICAgICAgICAgZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG4gICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHwgZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8IGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpKSB7XG4gICAgICAgIGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuICAgICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoZWwsIFwiKlwiKTsgLy8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblxuICAgICAgICAgIG1hdGNoZXMuY2FsbChlbCwgXCJbcyE9JyddOnhcIik7XG4gICAgICAgICAgcmJ1Z2d5TWF0Y2hlcy5wdXNoKFwiIT1cIiwgcHNldWRvcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpKTtcbiAgICAgIHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHJidWdneU1hdGNoZXMuam9pbihcInxcIikpO1xuICAgICAgLyogQ29udGFpbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgaGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdChkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKTsgLy8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG4gICAgICAvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcbiAgICAgIC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cbiAgICAgIGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoZG9jRWxlbS5jb250YWlucykgPyBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuICAgICAgICAgICAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiBhID09PSBidXAgfHwgISEoYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoYWRvd24uY29udGFpbnMgPyBhZG93bi5jb250YWlucyhidXApIDogYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGJ1cCkgJiAxNikpO1xuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgd2hpbGUgKGIgPSBiLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChiID09PSBhKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICAvKiBTb3J0aW5nXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cbiAgICAgIHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgPyBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gLy8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXG5cbiAgICAgICAgdmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChjb21wYXJlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH0gLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG4gICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgICAgICAgY29tcGFyZSA9IChhLm93bmVyRG9jdW1lbnQgfHwgYSkgPT0gKGIub3duZXJEb2N1bWVudCB8fCBiKSA/IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgOiAvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcbiAgICAgICAgMTsgLy8gRGlzY29ubmVjdGVkIG5vZGVzXG5cbiAgICAgICAgaWYgKGNvbXBhcmUgJiAxIHx8ICFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGEpID09PSBjb21wYXJlKSB7XG4gICAgICAgICAgLy8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG4gICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG4gICAgICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG4gICAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICBpZiAoYSA9PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICAgICAgICAgIGlmIChiID09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSAvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXG5cbiAgICAgICAgICByZXR1cm4gc29ydElucHV0ID8gaW5kZXhPZihzb3J0SW5wdXQsIGEpIC0gaW5kZXhPZihzb3J0SW5wdXQsIGIpIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG4gICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXIsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGF1cCA9IGEucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIGJ1cCA9IGIucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIGFwID0gW2FdLFxuICAgICAgICAgICAgYnAgPSBbYl07IC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cbiAgICAgICAgaWYgKCFhdXAgfHwgIWJ1cCkge1xuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblxuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgICAgICAgIHJldHVybiBhID09IGRvY3VtZW50ID8gLTEgOiBiID09IGRvY3VtZW50ID8gMSA6XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbiAgICAgICAgICBhdXAgPyAtMSA6IGJ1cCA/IDEgOiBzb3J0SW5wdXQgPyBpbmRleE9mKHNvcnRJbnB1dCwgYSkgLSBpbmRleE9mKHNvcnRJbnB1dCwgYikgOiAwOyAvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuICAgICAgICB9IGVsc2UgaWYgKGF1cCA9PT0gYnVwKSB7XG4gICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayhhLCBiKTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXG5cbiAgICAgICAgY3VyID0gYTtcblxuICAgICAgICB3aGlsZSAoY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBhcC51bnNoaWZ0KGN1cik7XG4gICAgICAgIH1cblxuICAgICAgICBjdXIgPSBiO1xuXG4gICAgICAgIHdoaWxlIChjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGJwLnVuc2hpZnQoY3VyKTtcbiAgICAgICAgfSAvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXG5cbiAgICAgICAgd2hpbGUgKGFwW2ldID09PSBicFtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpID8gLy8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG4gICAgICAgIHNpYmxpbmdDaGVjayhhcFtpXSwgYnBbaV0pIDogLy8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgICAgICBhcFtpXSA9PSBwcmVmZXJyZWREb2MgPyAtMSA6IGJwW2ldID09IHByZWZlcnJlZERvYyA/IDEgOlxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuICAgICAgICAwO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9O1xuXG4gICAgU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZXhwciwgZWxlbWVudHMpIHtcbiAgICAgIHJldHVybiBTaXp6bGUoZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMpO1xuICAgIH07XG5cbiAgICBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGVsZW0sIGV4cHIpIHtcbiAgICAgIHNldERvY3VtZW50KGVsZW0pO1xuXG4gICAgICBpZiAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiYgIW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbZXhwciArIFwiIFwiXSAmJiAoIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdChleHByKSkgJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KGV4cHIpKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXQgPSBtYXRjaGVzLmNhbGwoZWxlbSwgZXhwcik7IC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblxuICAgICAgICAgIGlmIChyZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fCAvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuICAgICAgICAgIC8vIGZyYWdtZW50IGluIElFIDlcbiAgICAgICAgICBlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoZXhwciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFNpenpsZShleHByLCBkb2N1bWVudCwgbnVsbCwgW2VsZW1dKS5sZW5ndGggPiAwO1xuICAgIH07XG5cbiAgICBTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlbSkge1xuICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgaWYgKChjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCkgIT0gZG9jdW1lbnQpIHtcbiAgICAgICAgc2V0RG9jdW1lbnQoY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250YWlucyhjb250ZXh0LCBlbGVtKTtcbiAgICB9O1xuXG4gICAgU2l6emxlLmF0dHIgPSBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xuICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgaWYgKChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkgIT0gZG9jdW1lbnQpIHtcbiAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVtuYW1lLnRvTG93ZXJDYXNlKCldLFxuICAgICAgICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuICAgICAgdmFsID0gZm4gJiYgaGFzT3duLmNhbGwoRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkpID8gZm4oZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgPyBlbGVtLmdldEF0dHJpYnV0ZShuYW1lKSA6ICh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgPyB2YWwudmFsdWUgOiBudWxsO1xuICAgIH07XG5cbiAgICBTaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24gKHNlbCkge1xuICAgICAgcmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUpO1xuICAgIH07XG5cbiAgICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gICAgICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAgICAgKi9cblxuXG4gICAgU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgZHVwbGljYXRlcyA9IFtdLFxuICAgICAgICAgIGogPSAwLFxuICAgICAgICAgIGkgPSAwOyAvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cbiAgICAgIGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG4gICAgICBzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoMCk7XG4gICAgICByZXN1bHRzLnNvcnQoc29ydE9yZGVyKTtcblxuICAgICAgaWYgKGhhc0R1cGxpY2F0ZSkge1xuICAgICAgICB3aGlsZSAoZWxlbSA9IHJlc3VsdHNbaSsrXSkge1xuICAgICAgICAgIGlmIChlbGVtID09PSByZXN1bHRzW2ldKSB7XG4gICAgICAgICAgICBqID0gZHVwbGljYXRlcy5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICByZXN1bHRzLnNwbGljZShkdXBsaWNhdGVzW2pdLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cblxuICAgICAgc29ydElucHV0ID0gbnVsbDtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAgICAgKi9cblxuXG4gICAgZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHZhciBub2RlLFxuICAgICAgICAgIHJldCA9IFwiXCIsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICBpZiAoIW5vZGVUeXBlKSB7XG4gICAgICAgIC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG4gICAgICAgIHdoaWxlIChub2RlID0gZWxlbVtpKytdKSB7XG4gICAgICAgICAgLy8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgICByZXQgKz0gZ2V0VGV4dChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuICAgICAgICAvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuICAgICAgICBpZiAodHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cbiAgICAgICAgICBmb3IgKGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICByZXQgKz0gZ2V0VGV4dChlbGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuICAgICAgfSAvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBFeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcbiAgICAgIC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuICAgICAgY2FjaGVMZW5ndGg6IDUwLFxuICAgICAgY3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG4gICAgICBtYXRjaDogbWF0Y2hFeHByLFxuICAgICAgYXR0ckhhbmRsZToge30sXG4gICAgICBmaW5kOiB7fSxcbiAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgIFwiPlwiOiB7XG4gICAgICAgICAgZGlyOiBcInBhcmVudE5vZGVcIixcbiAgICAgICAgICBmaXJzdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcIiBcIjoge1xuICAgICAgICAgIGRpcjogXCJwYXJlbnROb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCIrXCI6IHtcbiAgICAgICAgICBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsXG4gICAgICAgICAgZmlyc3Q6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJ+XCI6IHtcbiAgICAgICAgICBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByZUZpbHRlcjoge1xuICAgICAgICBcIkFUVFJcIjogZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTsgLy8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblxuICAgICAgICAgIG1hdGNoWzNdID0gKG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIpLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuXG4gICAgICAgICAgaWYgKG1hdGNoWzJdID09PSBcIn49XCIpIHtcbiAgICAgICAgICAgIG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSgwLCA0KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJDSElMRFwiOiBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cbiAgICAgICAgICBcdDEgdHlwZSAob25seXxudGh8Li4uKVxuICAgICAgICAgIFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuICAgICAgICAgIFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcbiAgICAgICAgICBcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuICAgICAgICAgIFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuICAgICAgICAgIFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuICAgICAgICAgIFx0NyBzaWduIG9mIHktY29tcG9uZW50XG4gICAgICAgICAgXHQ4IHkgb2YgeS1jb21wb25lbnRcbiAgICAgICAgICAqL1xuICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgIGlmIChtYXRjaFsxXS5zbGljZSgwLCAzKSA9PT0gXCJudGhcIikge1xuICAgICAgICAgICAgLy8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcbiAgICAgICAgICAgIGlmICghbWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgU2l6emxlLmVycm9yKG1hdGNoWzBdKTtcbiAgICAgICAgICAgIH0gLy8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cblxuICAgICAgICAgICAgbWF0Y2hbNF0gPSArKG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIikpO1xuICAgICAgICAgICAgbWF0Y2hbNV0gPSArKG1hdGNoWzddICsgbWF0Y2hbOF0gfHwgbWF0Y2hbM10gPT09IFwib2RkXCIpOyAvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICBTaXp6bGUuZXJyb3IobWF0Y2hbMF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfSxcbiAgICAgICAgXCJQU0VVRE9cIjogZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgdmFyIGV4Y2VzcyxcbiAgICAgICAgICAgICAgdW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cbiAgICAgICAgICBpZiAobWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdChtYXRjaFswXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gLy8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblxuXG4gICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICBtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7IC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG4gICAgICAgICAgfSBlbHNlIGlmICh1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QodW5xdW90ZWQpICYmICggLy8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcbiAgICAgICAgICBleGNlc3MgPSB0b2tlbml6ZSh1bnF1b3RlZCwgdHJ1ZSkpICYmICggLy8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgICAgZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZihcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzKSAtIHVucXVvdGVkLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG4gICAgICAgICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKDAsIGV4Y2Vzcyk7XG4gICAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKDAsIGV4Y2Vzcyk7XG4gICAgICAgICAgfSAvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblxuXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmlsdGVyOiB7XG4gICAgICAgIFwiVEFHXCI6IGZ1bmN0aW9uIChub2RlTmFtZVNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBcIkNMQVNTXCI6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICB2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbY2xhc3NOYW1lICsgXCIgXCJdO1xuICAgICAgICAgIHJldHVybiBwYXR0ZXJuIHx8IChwYXR0ZXJuID0gbmV3IFJlZ0V4cChcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIikpICYmIGNsYXNzQ2FjaGUoY2xhc3NOYW1lLCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbiAobmFtZSwgb3BlcmF0b3IsIGNoZWNrKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoZWxlbSwgbmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcGVyYXRvcikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXCI7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDogb3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOiBvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoY2hlY2spID09PSAwIDogb3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKGNoZWNrKSA+IC0xIDogb3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSgtY2hlY2subGVuZ3RoKSA9PT0gY2hlY2sgOiBvcGVyYXRvciA9PT0gXCJ+PVwiID8gKFwiIFwiICsgcmVzdWx0LnJlcGxhY2UocndoaXRlc3BhY2UsIFwiIFwiKSArIFwiIFwiKS5pbmRleE9mKGNoZWNrKSA+IC0xIDogb3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKDAsIGNoZWNrLmxlbmd0aCArIDEpID09PSBjaGVjayArIFwiLVwiIDogZmFsc2U7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBcIkNISUxEXCI6IGZ1bmN0aW9uICh0eXBlLCB3aGF0LCBfYXJndW1lbnQsIGZpcnN0LCBsYXN0KSB7XG4gICAgICAgICAgdmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoMCwgMykgIT09IFwibnRoXCIsXG4gICAgICAgICAgICAgIGZvcndhcmQgPSB0eXBlLnNsaWNlKC00KSAhPT0gXCJsYXN0XCIsXG4gICAgICAgICAgICAgIG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID8gLy8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuICAgICAgICAgIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChlbGVtLCBfY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUsXG4gICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUsXG4gICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIG5vZGVJbmRleCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICB1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcbiAgICAgICAgICAgICAgICBkaWZmID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgLy8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuICAgICAgICAgICAgICBpZiAoc2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRpcikge1xuICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG5cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlID0gbm9kZVtkaXJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXG5cbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0YXJ0ID0gW2ZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGRdOyAvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXG4gICAgICAgICAgICAgIGlmIChmb3J3YXJkICYmIHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IG5vZGVbZXhwYW5kb10gfHwgKG5vZGVbZXhwYW5kb10gPSB7fSk7IC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblxuICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fCAob3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSA9IHt9KTtcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHVuaXF1ZUNhY2hlW3R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbMl07XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1tub2RlSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbZGlyXSB8fCAoIC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbdHlwZV0gPSBbZGlycnVucywgbm9kZUluZGV4LCBkaWZmXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmICh1c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KTsgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cbiAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fCAob3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgIGNhY2hlID0gdW5pcXVlQ2FjaGVbdHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsxXTtcbiAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgfSAvLyB4bWwgOm50aC1jaGlsZCguLi4pXG4gICAgICAgICAgICAgICAgLy8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZGlmZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVtkaXJdIHx8IChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxKSAmJiArK2RpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KTsgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fCAob3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlW3R5cGVdID0gW2RpcnJ1bnMsIGRpZmZdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblxuXG4gICAgICAgICAgICAgIGRpZmYgLT0gbGFzdDtcbiAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8IGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBcIlBTRVVET1wiOiBmdW5jdGlvbiAocHNldWRvLCBhcmd1bWVudCkge1xuICAgICAgICAgIC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcbiAgICAgICAgICAvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3NcbiAgICAgICAgICB2YXIgYXJncyxcbiAgICAgICAgICAgICAgZm4gPSBFeHByLnBzZXVkb3NbcHNldWRvXSB8fCBFeHByLnNldEZpbHRlcnNbcHNldWRvLnRvTG93ZXJDYXNlKCldIHx8IFNpenpsZS5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8pOyAvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAgICAgLy8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgICAgICAvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cbiAgICAgICAgICBpZiAoZm5bZXhwYW5kb10pIHtcbiAgICAgICAgICAgIHJldHVybiBmbihhcmd1bWVudCk7XG4gICAgICAgICAgfSAvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblxuXG4gICAgICAgICAgaWYgKGZuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBbcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50XTtcbiAgICAgICAgICAgIHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkocHNldWRvLnRvTG93ZXJDYXNlKCkpID8gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCBtYXRjaGVzKSB7XG4gICAgICAgICAgICAgIHZhciBpZHgsXG4gICAgICAgICAgICAgICAgICBtYXRjaGVkID0gZm4oc2VlZCwgYXJndW1lbnQpLFxuICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZWQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZHggPSBpbmRleE9mKHNlZWQsIG1hdGNoZWRbaV0pO1xuICAgICAgICAgICAgICAgIHNlZWRbaWR4XSA9ICEobWF0Y2hlc1tpZHhdID0gbWF0Y2hlZFtpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pIDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZuKGVsZW0sIDAsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwc2V1ZG9zOiB7XG4gICAgICAgIC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuICAgICAgICBcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgLy8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcbiAgICAgICAgICAvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuICAgICAgICAgIC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuICAgICAgICAgIHZhciBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgICByZXN1bHRzID0gW10sXG4gICAgICAgICAgICAgIG1hdGNoZXIgPSBjb21waWxlKHNlbGVjdG9yLnJlcGxhY2UocnRyaW0sIFwiJDFcIikpO1xuICAgICAgICAgIHJldHVybiBtYXRjaGVyW2V4cGFuZG9dID8gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCBtYXRjaGVzLCBfY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICB1bm1hdGNoZWQgPSBtYXRjaGVyKHNlZWQsIG51bGwsIHhtbCwgW10pLFxuICAgICAgICAgICAgICAgIGkgPSBzZWVkLmxlbmd0aDsgLy8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtID0gdW5tYXRjaGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgc2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkgOiBmdW5jdGlvbiAoZWxlbSwgX2NvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgaW5wdXRbMF0gPSBlbGVtO1xuICAgICAgICAgICAgbWF0Y2hlcihpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzKTsgLy8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblxuICAgICAgICAgICAgaW5wdXRbMF0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gU2l6emxlKHNlbGVjdG9yLCBlbGVtKS5sZW5ndGggPiAwO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIChlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoZWxlbSkpLmluZGV4T2YodGV4dCkgPiAtMTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLy8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG4gICAgICAgIC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG4gICAgICAgIC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG4gICAgICAgIC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG4gICAgICAgIC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICAvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cbiAgICAgICAgXCJsYW5nXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAobGFuZykge1xuICAgICAgICAgIC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcbiAgICAgICAgICBpZiAoIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSkge1xuICAgICAgICAgICAgU2l6emxlLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsYW5nID0gbGFuZy5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgdmFyIGVsZW1MYW5nO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGlmIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID8gZWxlbS5sYW5nIDogZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpIHtcbiAgICAgICAgICAgICAgICBlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YobGFuZyArIFwiLVwiKSA9PT0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcbiAgICAgICAgXCJ0YXJnZXRcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKDEpID09PSBlbGVtLmlkO1xuICAgICAgICB9LFxuICAgICAgICBcInJvb3RcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJmb2N1c1wiOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEJvb2xlYW4gcHJvcGVydGllc1xuICAgICAgICBcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oZmFsc2UpLFxuICAgICAgICBcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKHRydWUpLFxuICAgICAgICBcImNoZWNrZWRcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuICAgICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCB8fCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG4gICAgICAgICAgLy8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDb250ZW50c1xuICAgICAgICBcImVtcHR5XCI6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cbiAgICAgICAgICAvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG4gICAgICAgICAgLy8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcbiAgICAgICAgICAvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG4gICAgICAgICAgZm9yIChlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPCA2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXJlbnRcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKGVsZW0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFbGVtZW50L2lucHV0IHR5cGVzXG4gICAgICAgIFwiaGVhZGVyXCI6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgcmV0dXJuIHJoZWFkZXIudGVzdChlbGVtLm5vZGVOYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgIHJldHVybiByaW5wdXRzLnRlc3QoZWxlbS5ub2RlTmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiYnV0dG9uXCI6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0XCI6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgKCAvLyBTdXBwb3J0OiBJRTw4XG4gICAgICAgICAgLy8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcbiAgICAgICAgICAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuICAgICAgICBcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgIH0pLFxuICAgICAgICBcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAoX21hdGNoSW5kZXhlcywgbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFtsZW5ndGggLSAxXTtcbiAgICAgICAgfSksXG4gICAgICAgIFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAoX21hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xuICAgICAgICAgIHJldHVybiBbYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudF07XG4gICAgICAgIH0pLFxuICAgICAgICBcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgICB9KSxcbiAgICAgICAgXCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgaSA9IDE7XG5cbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgICB9KSxcbiAgICAgICAgXCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQpIHtcbiAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgPiBsZW5ndGggPyBsZW5ndGggOiBhcmd1bWVudDtcblxuICAgICAgICAgIGZvciAoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgIH0pLFxuICAgICAgICBcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xuICAgICAgICAgIHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblxuICAgICAgICAgIGZvciAoOyArK2kgPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH07XG4gICAgRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07IC8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5cbiAgICBmb3IgKGkgaW4ge1xuICAgICAgcmFkaW86IHRydWUsXG4gICAgICBjaGVja2JveDogdHJ1ZSxcbiAgICAgIGZpbGU6IHRydWUsXG4gICAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICAgIGltYWdlOiB0cnVlXG4gICAgfSkge1xuICAgICAgRXhwci5wc2V1ZG9zW2ldID0gY3JlYXRlSW5wdXRQc2V1ZG8oaSk7XG4gICAgfVxuXG4gICAgZm9yIChpIGluIHtcbiAgICAgIHN1Ym1pdDogdHJ1ZSxcbiAgICAgIHJlc2V0OiB0cnVlXG4gICAgfSkge1xuICAgICAgRXhwci5wc2V1ZG9zW2ldID0gY3JlYXRlQnV0dG9uUHNldWRvKGkpO1xuICAgIH0gLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5cblxuICAgIGZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuXG4gICAgc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG4gICAgRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxuICAgIHRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBwYXJzZU9ubHkpIHtcbiAgICAgIHZhciBtYXRjaGVkLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHNvRmFyLFxuICAgICAgICAgIGdyb3VwcyxcbiAgICAgICAgICBwcmVGaWx0ZXJzLFxuICAgICAgICAgIGNhY2hlZCA9IHRva2VuQ2FjaGVbc2VsZWN0b3IgKyBcIiBcIl07XG5cbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoMCk7XG4gICAgICB9XG5cbiAgICAgIHNvRmFyID0gc2VsZWN0b3I7XG4gICAgICBncm91cHMgPSBbXTtcbiAgICAgIHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuICAgICAgd2hpbGUgKHNvRmFyKSB7XG4gICAgICAgIC8vIENvbW1hIGFuZCBmaXJzdCBydW5cbiAgICAgICAgaWYgKCFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKHNvRmFyKSkpIHtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG4gICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoWzBdLmxlbmd0aCkgfHwgc29GYXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3JvdXBzLnB1c2godG9rZW5zID0gW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2hlZCA9IGZhbHNlOyAvLyBDb21iaW5hdG9yc1xuXG4gICAgICAgIGlmIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKHNvRmFyKSkge1xuICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuICAgICAgICAgICAgLy8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG4gICAgICAgICAgICB0eXBlOiBtYXRjaFswXS5yZXBsYWNlKHJ0cmltLCBcIiBcIilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcbiAgICAgICAgfSAvLyBGaWx0ZXJzXG5cblxuICAgICAgICBmb3IgKHR5cGUgaW4gRXhwci5maWx0ZXIpIHtcbiAgICAgICAgICBpZiAoKG1hdGNoID0gbWF0Y2hFeHByW3R5cGVdLmV4ZWMoc29GYXIpKSAmJiAoIXByZUZpbHRlcnNbdHlwZV0gfHwgKG1hdGNoID0gcHJlRmlsdGVyc1t0eXBlXShtYXRjaCkpKSkge1xuICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBtYXRjaGVzOiBtYXRjaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3NcbiAgICAgIC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuICAgICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cblxuICAgICAgcmV0dXJuIHBhcnNlT25seSA/IHNvRmFyLmxlbmd0aCA6IHNvRmFyID8gU2l6emxlLmVycm9yKHNlbGVjdG9yKSA6IC8vIENhY2hlIHRoZSB0b2tlbnNcbiAgICAgIHRva2VuQ2FjaGUoc2VsZWN0b3IsIGdyb3Vwcykuc2xpY2UoMCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRvU2VsZWN0b3IodG9rZW5zKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICBzZWxlY3RvciA9IFwiXCI7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ29tYmluYXRvcihtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlKSB7XG4gICAgICB2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG4gICAgICAgICAgc2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcbiAgICAgICAgICBrZXkgPSBza2lwIHx8IGRpcixcbiAgICAgICAgICBjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuICAgICAgICAgIGRvbmVOYW1lID0gZG9uZSsrO1xuICAgICAgcmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgPyAvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcbiAgICAgIGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcbiAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gOiAvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcbiAgICAgIGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgdmFyIG9sZENhY2hlLFxuICAgICAgICAgICAgdW5pcXVlQ2FjaGUsXG4gICAgICAgICAgICBvdXRlckNhY2hlLFxuICAgICAgICAgICAgbmV3Q2FjaGUgPSBbZGlycnVucywgZG9uZU5hbWVdOyAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblxuICAgICAgICBpZiAoeG1sKSB7XG4gICAgICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcbiAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoaWxlIChlbGVtID0gZWxlbVtkaXJdKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBlbGVtW2V4cGFuZG9dIHx8IChlbGVtW2V4cGFuZG9dID0ge30pOyAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXG4gICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtlbGVtLnVuaXF1ZUlEXSB8fCAob3V0ZXJDYWNoZVtlbGVtLnVuaXF1ZUlEXSA9IHt9KTtcblxuICAgICAgICAgICAgICBpZiAoc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVtkaXJdIHx8IGVsZW07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVba2V5XSkgJiYgb2xkQ2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbMV0gPT09IGRvbmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q2FjaGVbMl0gPSBvbGRDYWNoZVsyXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVba2V5XSA9IG5ld0NhY2hlOyAvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblxuICAgICAgICAgICAgICAgIGlmIChuZXdDYWNoZVsyXSA9IG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycykge1xuICAgICAgcmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgPyBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgIHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBpZiAoIW1hdGNoZXJzW2ldKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gOiBtYXRjaGVyc1swXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cykge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBTaXp6bGUoc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZGVuc2UodW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sKSB7XG4gICAgICB2YXIgZWxlbSxcbiAgICAgICAgICBuZXdVbm1hdGNoZWQgPSBbXSxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuICAgICAgICAgIG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChlbGVtID0gdW5tYXRjaGVkW2ldKSB7XG4gICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcbiAgICAgICAgICAgIG5ld1VubWF0Y2hlZC5wdXNoKGVsZW0pO1xuXG4gICAgICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICAgIG1hcC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3VW5tYXRjaGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE1hdGNoZXIocHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKSB7XG4gICAgICBpZiAocG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlcltleHBhbmRvXSkge1xuICAgICAgICBwb3N0RmlsdGVyID0gc2V0TWF0Y2hlcihwb3N0RmlsdGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbZXhwYW5kb10pIHtcbiAgICAgICAgcG9zdEZpbmRlciA9IHNldE1hdGNoZXIocG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sKSB7XG4gICAgICAgIHZhciB0ZW1wLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICBwcmVNYXAgPSBbXSxcbiAgICAgICAgICAgIHBvc3RNYXAgPSBbXSxcbiAgICAgICAgICAgIHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG4gICAgICAgICAgICAvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuICAgICAgICBlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyhzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFtjb250ZXh0XSA6IGNvbnRleHQsIFtdKSxcbiAgICAgICAgICAgIC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuICAgICAgICBtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKHNlZWQgfHwgIXNlbGVjdG9yKSA/IGNvbmRlbnNlKGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sKSA6IGVsZW1zLFxuICAgICAgICAgICAgbWF0Y2hlck91dCA9IG1hdGNoZXIgPyAvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuICAgICAgICBwb3N0RmluZGVyIHx8IChzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlcikgPyAvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3NhcnlcbiAgICAgICAgW10gOiAvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcbiAgICAgICAgcmVzdWx0cyA6IG1hdGNoZXJJbjsgLy8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblxuICAgICAgICBpZiAobWF0Y2hlcikge1xuICAgICAgICAgIG1hdGNoZXIobWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwpO1xuICAgICAgICB9IC8vIEFwcGx5IHBvc3RGaWx0ZXJcblxuXG4gICAgICAgIGlmIChwb3N0RmlsdGVyKSB7XG4gICAgICAgICAgdGVtcCA9IGNvbmRlbnNlKG1hdGNoZXJPdXQsIHBvc3RNYXApO1xuICAgICAgICAgIHBvc3RGaWx0ZXIodGVtcCwgW10sIGNvbnRleHQsIHhtbCk7IC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblxuICAgICAgICAgIGkgPSB0ZW1wLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChlbGVtID0gdGVtcFtpXSkge1xuICAgICAgICAgICAgICBtYXRjaGVyT3V0W3Bvc3RNYXBbaV1dID0gIShtYXRjaGVySW5bcG9zdE1hcFtpXV0gPSBlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VlZCkge1xuICAgICAgICAgIGlmIChwb3N0RmluZGVyIHx8IHByZUZpbHRlcikge1xuICAgICAgICAgICAgaWYgKHBvc3RGaW5kZXIpIHtcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG4gICAgICAgICAgICAgIHRlbXAgPSBbXTtcbiAgICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pIHtcbiAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG4gICAgICAgICAgICAgICAgICB0ZW1wLnB1c2gobWF0Y2hlckluW2ldID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcG9zdEZpbmRlcihudWxsLCBtYXRjaGVyT3V0ID0gW10sIHRlbXAsIHhtbCk7XG4gICAgICAgICAgICB9IC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cblxuICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgIGlmICgoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmICh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2Yoc2VlZCwgZWxlbSkgOiBwcmVNYXBbaV0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2hlck91dCA9IGNvbmRlbnNlKG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgPyBtYXRjaGVyT3V0LnNwbGljZShwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGgpIDogbWF0Y2hlck91dCk7XG5cbiAgICAgICAgICBpZiAocG9zdEZpbmRlcikge1xuICAgICAgICAgICAgcG9zdEZpbmRlcihudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIG1hdGNoZXJPdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zKSB7XG4gICAgICB2YXIgY2hlY2tDb250ZXh0LFxuICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgaixcbiAgICAgICAgICBsZW4gPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgICAgIGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbdG9rZW5zWzBdLnR5cGVdLFxuICAgICAgICAgIGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG4gICAgICAgICAgaSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuICAgICAgICAgIC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG4gICAgICBtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG4gICAgICB9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlKSxcbiAgICAgICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBpbmRleE9mKGNoZWNrQ29udGV4dCwgZWxlbSkgPiAtMTtcbiAgICAgIH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUpLFxuICAgICAgICAgIG1hdGNoZXJzID0gW2Z1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgdmFyIHJldCA9ICFsZWFkaW5nUmVsYXRpdmUgJiYgKHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0KSB8fCAoKGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID8gbWF0Y2hDb250ZXh0KGVsZW0sIGNvbnRleHQsIHhtbCkgOiBtYXRjaEFueUNvbnRleHQoZWxlbSwgY29udGV4dCwgeG1sKSk7IC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXG4gICAgICAgIGNoZWNrQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XTtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbdG9rZW5zW2ldLnR5cGVdKSB7XG4gICAgICAgICAgbWF0Y2hlcnMgPSBbYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksIG1hdGNoZXIpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaGVyID0gRXhwci5maWx0ZXJbdG9rZW5zW2ldLnR5cGVdLmFwcGx5KG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzKTsgLy8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblxuICAgICAgICAgIGlmIChtYXRjaGVyW2V4cGFuZG9dKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcbiAgICAgICAgICAgIGogPSArK2k7XG5cbiAgICAgICAgICAgIGZvciAoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKEV4cHIucmVsYXRpdmVbdG9rZW5zW2pdLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNldE1hdGNoZXIoaSA+IDEgJiYgZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpLCBpID4gMSAmJiB0b1NlbGVjdG9yKCAvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuICAgICAgICAgICAgdG9rZW5zLnNsaWNlKDAsIGkgLSAxKS5jb25jYXQoe1xuICAgICAgICAgICAgICB2YWx1ZTogdG9rZW5zW2kgLSAyXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIlxuICAgICAgICAgICAgfSkpLnJlcGxhY2UocnRyaW0sIFwiJDFcIiksIG1hdGNoZXIsIGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKHRva2Vucy5zbGljZShpLCBqKSksIGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zID0gdG9rZW5zLnNsaWNlKGopKSwgaiA8IGxlbiAmJiB0b1NlbGVjdG9yKHRva2VucykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycykge1xuICAgICAgdmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcbiAgICAgICAgICBieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcbiAgICAgICAgICBzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiAoc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QpIHtcbiAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICAgIG1hdGNoZWRDb3VudCA9IDAsXG4gICAgICAgICAgICBpID0gXCIwXCIsXG4gICAgICAgICAgICB1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgY29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG4gICAgICAgICAgICAvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG4gICAgICAgIGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKFwiKlwiLCBvdXRlcm1vc3QpLFxuICAgICAgICAgICAgLy8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcbiAgICAgICAgZGlycnVuc1VuaXF1ZSA9IGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xLFxuICAgICAgICAgICAgbGVuID0gZWxlbXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChvdXRlcm1vc3QpIHtcbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuICAgICAgICB9IC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuICAgICAgICAvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblxuXG4gICAgICAgIGZvciAoOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGJ5RWxlbWVudCAmJiBlbGVtKSB7XG4gICAgICAgICAgICBqID0gMDsgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG4gICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuICAgICAgICAgICAgaWYgKCFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICBzZXREb2N1bWVudChlbGVtKTtcbiAgICAgICAgICAgICAgeG1sID0gIWRvY3VtZW50SXNIVE1MO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRjaGVyKGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG91dGVybW9zdCkge1xuICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblxuXG4gICAgICAgICAgaWYgKGJ5U2V0KSB7XG4gICAgICAgICAgICAvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG4gICAgICAgICAgICBpZiAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pIHtcbiAgICAgICAgICAgICAgbWF0Y2hlZENvdW50LS07XG4gICAgICAgICAgICB9IC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3RcblxuXG4gICAgICAgICAgICBpZiAoc2VlZCkge1xuICAgICAgICAgICAgICB1bm1hdGNoZWQucHVzaChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuICAgICAgICAvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXG5cbiAgICAgICAgbWF0Y2hlZENvdW50ICs9IGk7IC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG4gICAgICAgIC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuICAgICAgICAvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuICAgICAgICAvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG4gICAgICAgIC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuICAgICAgICAvLyBudW1lcmljYWxseSB6ZXJvLlxuXG4gICAgICAgIGlmIChieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQpIHtcbiAgICAgICAgICBqID0gMDtcblxuICAgICAgICAgIHdoaWxlIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkge1xuICAgICAgICAgICAgbWF0Y2hlcih1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgIC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcbiAgICAgICAgICAgIGlmIChtYXRjaGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbChyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblxuXG4gICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2Uoc2V0TWF0Y2hlZCk7XG4gICAgICAgICAgfSAvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cblxuICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc2V0TWF0Y2hlZCk7IC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXG4gICAgICAgICAgaWYgKG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiYgbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgU2l6emxlLnVuaXF1ZVNvcnQocmVzdWx0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXG5cbiAgICAgICAgaWYgKG91dGVybW9zdCkge1xuICAgICAgICAgIGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVubWF0Y2hlZDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBieVNldCA/IG1hcmtGdW5jdGlvbihzdXBlck1hdGNoZXIpIDogc3VwZXJNYXRjaGVyO1xuICAgIH1cblxuICAgIGNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgbWF0Y2hcbiAgICAvKiBJbnRlcm5hbCBVc2UgT25seSAqL1xuICAgICkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgc2V0TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlW3NlbGVjdG9yICsgXCIgXCJdO1xuXG4gICAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICAvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgIG1hdGNoID0gdG9rZW5pemUoc2VsZWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaSA9IG1hdGNoLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMobWF0Y2hbaV0pO1xuXG4gICAgICAgICAgaWYgKGNhY2hlZFtleHBhbmRvXSkge1xuICAgICAgICAgICAgc2V0TWF0Y2hlcnMucHVzaChjYWNoZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMucHVzaChjYWNoZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblxuXG4gICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyhlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzKSk7IC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXG4gICAgICAgIGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICAgICAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICAgICAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAgICAgKi9cblxuXG4gICAgc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZmluZCxcbiAgICAgICAgICBjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuICAgICAgICAgIG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3Rvcik7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTsgLy8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcbiAgICAgIC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblxuICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgICB0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKDApO1xuXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbdG9rZW5zWzFdLnR5cGVdKSB7XG4gICAgICAgICAgY29udGV4dCA9IChFeHByLmZpbmRbXCJJRFwiXSh0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0KSB8fCBbXSlbMF07XG5cbiAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzOyAvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG4gICAgICAgICAgfSBlbHNlIGlmIChjb21waWxlZCkge1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH0gLy8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXG5cbiAgICAgICAgaSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KHNlbGVjdG9yKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTsgLy8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXG4gICAgICAgICAgaWYgKEV4cHIucmVsYXRpdmVbdHlwZSA9IHRva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmluZCA9IEV4cHIuZmluZFt0eXBlXSkge1xuICAgICAgICAgICAgLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICBpZiAoc2VlZCA9IGZpbmQodG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgcnNpYmxpbmcudGVzdCh0b2tlbnNbMF0udHlwZSkgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcbiAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKHRva2Vucyk7XG5cbiAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc2VlZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cblxuICAgICAgKGNvbXBpbGVkIHx8IGNvbXBpbGUoc2VsZWN0b3IsIG1hdGNoKSkoc2VlZCwgY29udGV4dCwgIWRvY3VtZW50SXNIVE1MLCByZXN1bHRzLCAhY29udGV4dCB8fCByc2libGluZy50ZXN0KHNlbGVjdG9yKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTsgLy8gT25lLXRpbWUgYXNzaWdubWVudHNcbiAgICAvLyBTb3J0IHN0YWJpbGl0eVxuXG5cbiAgICBzdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoc29ydE9yZGVyKS5qb2luKFwiXCIpID09PSBleHBhbmRvOyAvLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4gICAgLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuXG4gICAgc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7IC8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuXG4gICAgc2V0RG9jdW1lbnQoKTsgLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbiAgICAvLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcblxuICAgIHN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgLy8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG4gICAgICByZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpKSAmIDE7XG4gICAgfSk7IC8vIFN1cHBvcnQ6IElFPDhcbiAgICAvLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5cbiAgICBpZiAoIWFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuICAgICAgcmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCI7XG4gICAgfSkpIHtcbiAgICAgIGFkZEhhbmRsZShcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XG4gICAgICAgIGlmICghaXNYTUwpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBTdXBwb3J0OiBJRTw5XG4gICAgLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuXG5cbiAgICBpZiAoIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuICAgICAgZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBcIlwiKTtcbiAgICAgIHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBcIlwiO1xuICAgIH0pKSB7XG4gICAgICBhZGRIYW5kbGUoXCJ2YWx1ZVwiLCBmdW5jdGlvbiAoZWxlbSwgX25hbWUsIGlzWE1MKSB7XG4gICAgICAgIGlmICghaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gU3VwcG9ydDogSUU8OVxuICAgIC8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcblxuXG4gICAgaWYgKCFhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbiAgICB9KSkge1xuICAgICAgYWRkSGFuZGxlKGJvb2xlYW5zLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgaXNYTUwpIHtcbiAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICBpZiAoIWlzWE1MKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1bbmFtZV0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID8gdmFsLnZhbHVlIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNpenpsZTtcbiAgfSh3aW5kb3cpO1xuXG4gIGpRdWVyeS5maW5kID0gU2l6emxlO1xuICBqUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7IC8vIERlcHJlY2F0ZWRcblxuICBqUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xuICBqUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbiAgalF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbiAgalF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xuICBqUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG4gIGpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cbiAgdmFyIGRpciA9IGZ1bmN0aW9uIChlbGVtLCBkaXIsIHVudGlsKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgdHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgd2hpbGUgKChlbGVtID0gZWxlbVtkaXJdKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5KSB7XG4gICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBpZiAodHJ1bmNhdGUgJiYgalF1ZXJ5KGVsZW0pLmlzKHVudGlsKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2hlZC5wdXNoKGVsZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVkO1xuICB9O1xuXG4gIHZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uIChuLCBlbGVtKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBbXTtcblxuICAgIGZvciAoOyBuOyBuID0gbi5uZXh0U2libGluZykge1xuICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSkge1xuICAgICAgICBtYXRjaGVkLnB1c2gobik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZWQ7XG4gIH07XG5cbiAgdmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbiAgZnVuY3Rpb24gbm9kZU5hbWUoZWxlbSwgbmFtZSkge1xuICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgO1xuICB2YXIgcnNpbmdsZVRhZyA9IC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pOyAvLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuXG4gIGZ1bmN0aW9uIHdpbm5vdyhlbGVtZW50cywgcXVhbGlmaWVyLCBub3QpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihxdWFsaWZpZXIpKSB7XG4gICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtLCBpKSB7XG4gICAgICAgIHJldHVybiAhIXF1YWxpZmllci5jYWxsKGVsZW0sIGksIGVsZW0pICE9PSBub3Q7XG4gICAgICB9KTtcbiAgICB9IC8vIFNpbmdsZSBlbGVtZW50XG5cblxuICAgIGlmIChxdWFsaWZpZXIubm9kZVR5cGUpIHtcbiAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGVsZW0gPT09IHF1YWxpZmllciAhPT0gbm90O1xuICAgICAgfSk7XG4gICAgfSAvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblxuXG4gICAgaWYgKHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChxdWFsaWZpZXIsIGVsZW0pID4gLTEgIT09IG5vdDtcbiAgICAgIH0pO1xuICAgIH0gLy8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXG5cbiAgICByZXR1cm4galF1ZXJ5LmZpbHRlcihxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QpO1xuICB9XG5cbiAgalF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uIChleHByLCBlbGVtcywgbm90KSB7XG4gICAgdmFyIGVsZW0gPSBlbGVtc1swXTtcblxuICAgIGlmIChub3QpIHtcbiAgICAgIGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICByZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGVsZW0sIGV4cHIpID8gW2VsZW1dIDogW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoZXhwciwgalF1ZXJ5LmdyZXAoZWxlbXMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICByZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcbiAgICB9KSk7XG4gIH07XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICByZXQsXG4gICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGpRdWVyeShzZWxlY3RvcikuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChqUXVlcnkuY29udGFpbnMoc2VsZltpXSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHRoaXMucHVzaFN0YWNrKFtdKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGpRdWVyeS5maW5kKHNlbGVjdG9yLCBzZWxmW2ldLCByZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KHJldCkgOiByZXQ7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UpKTtcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sod2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlKSk7XG4gICAgfSxcbiAgICBpczogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gISF3aW5ub3codGhpcywgLy8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuICAgICAgLy8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuICAgICAgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdChzZWxlY3RvcikgPyBqUXVlcnkoc2VsZWN0b3IpIDogc2VsZWN0b3IgfHwgW10sIGZhbHNlKS5sZW5ndGg7XG4gICAgfVxuICB9KTsgLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcbiAgLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG5cbiAgdmFyIHJvb3RqUXVlcnksXG4gICAgICAvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuICAvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG4gIC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuICAvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG4gIHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcbiAgICAgIGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCwgcm9vdCkge1xuICAgIHZhciBtYXRjaCwgZWxlbTsgLy8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuICAgIC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblxuXG4gICAgcm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTsgLy8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHNlbGVjdG9yWzBdID09PSBcIjxcIiAmJiBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSA9PT0gXCI+XCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMpIHtcbiAgICAgICAgLy8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcbiAgICAgICAgbWF0Y2ggPSBbbnVsbCwgc2VsZWN0b3IsIG51bGxdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoc2VsZWN0b3IpO1xuICAgICAgfSAvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cblxuICAgICAgaWYgKG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkpIHtcbiAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7IC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cbiAgICAgICAgICBqUXVlcnkubWVyZ2UodGhpcywgalF1ZXJ5LnBhcnNlSFRNTChtYXRjaFsxXSwgY29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCwgdHJ1ZSkpOyAvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cbiAgICAgICAgICBpZiAocnNpbmdsZVRhZy50ZXN0KG1hdGNoWzFdKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChjb250ZXh0KSkge1xuICAgICAgICAgICAgZm9yIChtYXRjaCBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1ttYXRjaF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpc1ttYXRjaF0oY29udGV4dFttYXRjaF0pOyAvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyKG1hdGNoLCBjb250ZXh0W21hdGNoXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpczsgLy8gSEFORExFOiAkKCNpZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMl0pO1xuXG4gICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgIC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG4gICAgICAgICAgICB0aGlzWzBdID0gZWxlbTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSAvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXG4gICAgICB9IGVsc2UgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiAoY29udGV4dCB8fCByb290KS5maW5kKHNlbGVjdG9yKTsgLy8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG4gICAgICAgIC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoY29udGV4dCkuZmluZChzZWxlY3Rvcik7XG4gICAgICB9IC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvci5ub2RlVHlwZSkge1xuICAgICAgdGhpc1swXSA9IHNlbGVjdG9yO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIEhBTkRMRTogJChmdW5jdGlvbilcbiAgICAgIC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgPyByb290LnJlYWR5KHNlbGVjdG9yKSA6IC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcbiAgICAgIHNlbGVjdG9yKGpRdWVyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoc2VsZWN0b3IsIHRoaXMpO1xuICB9OyAvLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5cblxuICBpbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjsgLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxuXG4gIHJvb3RqUXVlcnkgPSBqUXVlcnkoZG9jdW1lbnQpO1xuICB2YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG4gICAgICAvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuICBndWFyYW50ZWVkVW5pcXVlID0ge1xuICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgIGNvbnRlbnRzOiB0cnVlLFxuICAgIG5leHQ6IHRydWUsXG4gICAgcHJldjogdHJ1ZVxuICB9O1xuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICBoYXM6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHZhciB0YXJnZXRzID0galF1ZXJ5KHRhcmdldCwgdGhpcyksXG4gICAgICAgICAgbCA9IHRhcmdldHMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGpRdWVyeS5jb250YWlucyh0aGlzLCB0YXJnZXRzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uIChzZWxlY3RvcnMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBjdXIsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgICB0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoc2VsZWN0b3JzKTsgLy8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXG4gICAgICBpZiAoIXJuZWVkc0NvbnRleHQudGVzdChzZWxlY3RvcnMpKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgZm9yIChjdXIgPSB0aGlzW2ldOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG4gICAgICAgICAgICBpZiAoY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHRhcmdldHMgPyB0YXJnZXRzLmluZGV4KGN1cikgPiAtMSA6IC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuICAgICAgICAgICAgY3VyLm5vZGVUeXBlID09PSAxICYmIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpKSB7XG4gICAgICAgICAgICAgIG1hdGNoZWQucHVzaChjdXIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KG1hdGNoZWQpIDogbWF0Y2hlZCk7XG4gICAgfSxcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcbiAgICBpbmRleDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG4gICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcbiAgICAgIH0gLy8gSW5kZXggaW4gc2VsZWN0b3JcblxuXG4gICAgICBpZiAodHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChqUXVlcnkoZWxlbSksIHRoaXNbMF0pO1xuICAgICAgfSAvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblxuXG4gICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKHRoaXMsIC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuICAgICAgZWxlbS5qcXVlcnkgPyBlbGVtWzBdIDogZWxlbSk7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGpRdWVyeS51bmlxdWVTb3J0KGpRdWVyeS5tZXJnZSh0aGlzLmdldCgpLCBqUXVlcnkoc2VsZWN0b3IsIGNvbnRleHQpKSkpO1xuICAgIH0sXG4gICAgYWRkQmFjazogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoc2VsZWN0b3IgPT0gbnVsbCA/IHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoc2VsZWN0b3IpKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHNpYmxpbmcoY3VyLCBkaXIpIHtcbiAgICB3aGlsZSAoKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEpIHt9XG5cbiAgICByZXR1cm4gY3VyO1xuICB9XG5cbiAgalF1ZXJ5LmVhY2goe1xuICAgIHBhcmVudDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuICAgIH0sXG4gICAgcGFyZW50czogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwYXJlbnROb2RlXCIpO1xuICAgIH0sXG4gICAgcGFyZW50c1VudGlsOiBmdW5jdGlvbiAoZWxlbSwgX2ksIHVudGlsKSB7XG4gICAgICByZXR1cm4gZGlyKGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCk7XG4gICAgfSxcbiAgICBuZXh0OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmV0dXJuIHNpYmxpbmcoZWxlbSwgXCJuZXh0U2libGluZ1wiKTtcbiAgICB9LFxuICAgIHByZXY6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICByZXR1cm4gc2libGluZyhlbGVtLCBcInByZXZpb3VzU2libGluZ1wiKTtcbiAgICB9LFxuICAgIG5leHRBbGw6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICByZXR1cm4gZGlyKGVsZW0sIFwibmV4dFNpYmxpbmdcIik7XG4gICAgfSxcbiAgICBwcmV2QWxsOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmV0dXJuIGRpcihlbGVtLCBcInByZXZpb3VzU2libGluZ1wiKTtcbiAgICB9LFxuICAgIG5leHRVbnRpbDogZnVuY3Rpb24gKGVsZW0sIF9pLCB1bnRpbCkge1xuICAgICAgcmV0dXJuIGRpcihlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsKTtcbiAgICB9LFxuICAgIHByZXZVbnRpbDogZnVuY3Rpb24gKGVsZW0sIF9pLCB1bnRpbCkge1xuICAgICAgcmV0dXJuIGRpcihlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCk7XG4gICAgfSxcbiAgICBzaWJsaW5nczogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHJldHVybiBzaWJsaW5ncygoZWxlbS5wYXJlbnROb2RlIHx8IHt9KS5maXJzdENoaWxkLCBlbGVtKTtcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmV0dXJuIHNpYmxpbmdzKGVsZW0uZmlyc3RDaGlsZCk7XG4gICAgfSxcbiAgICBjb250ZW50czogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIGlmIChlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmIC8vIFN1cHBvcnQ6IElFIDExK1xuICAgICAgLy8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3RcbiAgICAgIC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuICAgICAgZ2V0UHJvdG8oZWxlbS5jb250ZW50RG9jdW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcbiAgICAgIH0gLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG4gICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcbiAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG5cblxuICAgICAgaWYgKG5vZGVOYW1lKGVsZW0sIFwidGVtcGxhdGVcIikpIHtcbiAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKFtdLCBlbGVtLmNoaWxkTm9kZXMpO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHVudGlsLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKHRoaXMsIGZuLCB1bnRpbCk7XG5cbiAgICAgIGlmIChuYW1lLnNsaWNlKC01KSAhPT0gXCJVbnRpbFwiKSB7XG4gICAgICAgIHNlbGVjdG9yID0gdW50aWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoc2VsZWN0b3IsIG1hdGNoZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgIGlmICghZ3VhcmFudGVlZFVuaXF1ZVtuYW1lXSkge1xuICAgICAgICAgIGpRdWVyeS51bmlxdWVTb3J0KG1hdGNoZWQpO1xuICAgICAgICB9IC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cblxuICAgICAgICBpZiAocnBhcmVudHNwcmV2LnRlc3QobmFtZSkpIHtcbiAgICAgICAgICBtYXRjaGVkLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobWF0Y2hlZCk7XG4gICAgfTtcbiAgfSk7XG4gIHZhciBybm90aHRtbHdoaXRlID0gL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nOyAvLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBqUXVlcnkuZWFjaChvcHRpb25zLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdLCBmdW5jdGlvbiAoXywgZmxhZykge1xuICAgICAgb2JqZWN0W2ZsYWddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIC8qXG4gICAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICAgKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAgICpcbiAgICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAgICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICAgKlxuICAgKiBQb3NzaWJsZSBvcHRpb25zOlxuICAgKlxuICAgKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gICAqXG4gICAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICAgKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gICAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICAgKlxuICAgKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICAgKlxuICAgKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICovXG5cblxuICBqUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG4gICAgLy8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/IGNyZWF0ZU9wdGlvbnMob3B0aW9ucykgOiBqUXVlcnkuZXh0ZW5kKHt9LCBvcHRpb25zKTtcblxuICAgIHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG4gICAgZmlyaW5nLFxuICAgICAgICAvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuICAgIG1lbW9yeSxcbiAgICAgICAgLy8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcbiAgICBmaXJlZCxcbiAgICAgICAgLy8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuICAgIGxvY2tlZCxcbiAgICAgICAgLy8gQWN0dWFsIGNhbGxiYWNrIGxpc3RcbiAgICBsaXN0ID0gW10sXG4gICAgICAgIC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG4gICAgcXVldWUgPSBbXSxcbiAgICAgICAgLy8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG4gICAgZmlyaW5nSW5kZXggPSAtMSxcbiAgICAgICAgLy8gRmlyZSBjYWxsYmFja3NcbiAgICBmaXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG4gICAgICBsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlOyAvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcbiAgICAgIC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblxuICAgICAgZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXG4gICAgICBmb3IgKDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xKSB7XG4gICAgICAgIG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgd2hpbGUgKCsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG4gICAgICAgICAgaWYgKGxpc3RbZmlyaW5nSW5kZXhdLmFwcGx5KG1lbW9yeVswXSwgbWVtb3J5WzFdKSA9PT0gZmFsc2UgJiYgb3B0aW9ucy5zdG9wT25GYWxzZSkge1xuICAgICAgICAgICAgLy8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuICAgICAgICAgICAgZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cblxuICAgICAgaWYgKCFvcHRpb25zLm1lbW9yeSkge1xuICAgICAgICBtZW1vcnkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZmlyaW5nID0gZmFsc2U7IC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cbiAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgLy8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuICAgICAgICBpZiAobWVtb3J5KSB7XG4gICAgICAgICAgbGlzdCA9IFtdOyAvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICAgICAvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuICAgIHNlbGYgPSB7XG4gICAgICAvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG4gICAgICBhZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuICAgICAgICAgIGlmIChtZW1vcnkgJiYgIWZpcmluZykge1xuICAgICAgICAgICAgZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG1lbW9yeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgKGZ1bmN0aW9uIGFkZChhcmdzKSB7XG4gICAgICAgICAgICBqUXVlcnkuZWFjaChhcmdzLCBmdW5jdGlvbiAoXywgYXJnKSB7XG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyhhcmcpKSB7XG4gICAgICAgICAgICAgICAgICBsaXN0LnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKGFyZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgYWRkKGFyZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICBpZiAobWVtb3J5ICYmICFmaXJpbmcpIHtcbiAgICAgICAgICAgIGZpcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG4gICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgalF1ZXJ5LmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbiAoXywgYXJnKSB7XG4gICAgICAgICAgdmFyIGluZGV4O1xuXG4gICAgICAgICAgd2hpbGUgKChpbmRleCA9IGpRdWVyeS5pbkFycmF5KGFyZywgbGlzdCwgaW5kZXgpKSA+IC0xKSB7XG4gICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7IC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPD0gZmlyaW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgZmlyaW5nSW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuICAgICAgLy8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG4gICAgICBoYXM6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4gPyBqUXVlcnkuaW5BcnJheShmbiwgbGlzdCkgPiAtMSA6IGxpc3QubGVuZ3RoID4gMDtcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG4gICAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcbiAgICAgIC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuICAgICAgLy8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG4gICAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2tlZCA9IHF1ZXVlID0gW107XG4gICAgICAgIGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIWxpc3Q7XG4gICAgICB9LFxuICAgICAgLy8gRGlzYWJsZSAuZmlyZVxuICAgICAgLy8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcbiAgICAgIC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcbiAgICAgIGxvY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9ja2VkID0gcXVldWUgPSBbXTtcblxuICAgICAgICBpZiAoIW1lbW9yeSAmJiAhZmlyaW5nKSB7XG4gICAgICAgICAgbGlzdCA9IG1lbW9yeSA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBsb2NrZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhbG9ja2VkO1xuICAgICAgfSxcbiAgICAgIC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcbiAgICAgIGZpcmVXaXRoOiBmdW5jdGlvbiAoY29udGV4dCwgYXJncykge1xuICAgICAgICBpZiAoIWxvY2tlZCkge1xuICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgICAgICAgIGFyZ3MgPSBbY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3NdO1xuICAgICAgICAgIHF1ZXVlLnB1c2goYXJncyk7XG5cbiAgICAgICAgICBpZiAoIWZpcmluZykge1xuICAgICAgICAgICAgZmlyZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICBmaXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZmlyZVdpdGgodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG4gICAgICBmaXJlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISFmaXJlZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgZnVuY3Rpb24gSWRlbnRpdHkodikge1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgZnVuY3Rpb24gVGhyb3dlcihleCkge1xuICAgIHRocm93IGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gYWRvcHRWYWx1ZSh2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlKSB7XG4gICAgdmFyIG1ldGhvZDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG4gICAgICBpZiAodmFsdWUgJiYgaXNGdW5jdGlvbihtZXRob2QgPSB2YWx1ZS5wcm9taXNlKSkge1xuICAgICAgICBtZXRob2QuY2FsbCh2YWx1ZSkuZG9uZShyZXNvbHZlKS5mYWlsKHJlamVjdCk7IC8vIE90aGVyIHRoZW5hYmxlc1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiBpc0Z1bmN0aW9uKG1ldGhvZCA9IHZhbHVlLnRoZW4pKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKHZhbHVlLCByZXNvbHZlLCByZWplY3QpOyAvLyBPdGhlciBub24tdGhlbmFibGVzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG4gICAgICAgIC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcbiAgICAgICAgLy8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcbiAgICAgICAgcmVzb2x2ZS5hcHBseSh1bmRlZmluZWQsIFt2YWx1ZV0uc2xpY2Uobm9WYWx1ZSkpO1xuICAgICAgfSAvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcbiAgICAgIC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cbiAgICAgIC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cbiAgICB9IGNhdGNoICh2YWx1ZSkge1xuICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuICAgICAgLy8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuICAgICAgcmVqZWN0LmFwcGx5KHVuZGVmaW5lZCwgW3ZhbHVlXSk7XG4gICAgfVxuICB9XG5cbiAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgRGVmZXJyZWQ6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICB2YXIgdHVwbGVzID0gWy8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG4gICAgICAvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG4gICAgICBbXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLCAyXSwgW1wicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDAsIFwicmVzb2x2ZWRcIl0sIFtcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDEsIFwicmVqZWN0ZWRcIl1dLFxuICAgICAgICAgIHN0YXRlID0gXCJwZW5kaW5nXCIsXG4gICAgICAgICAgcHJvbWlzZSA9IHtcbiAgICAgICAgc3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGFsd2F5czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlZmVycmVkLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihudWxsLCBmbik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcbiAgICAgICAgcGlwZTogZnVuY3Rpb24gKClcbiAgICAgICAgLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi9cbiAgICAgICAge1xuICAgICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgcmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiAobmV3RGVmZXIpIHtcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKHR1cGxlcywgZnVuY3Rpb24gKF9pLCB0dXBsZSkge1xuICAgICAgICAgICAgICAvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcbiAgICAgICAgICAgICAgdmFyIGZuID0gaXNGdW5jdGlvbihmbnNbdHVwbGVbNF1dKSAmJiBmbnNbdHVwbGVbNF1dOyAvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcbiAgICAgICAgICAgICAgLy8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG4gICAgICAgICAgICAgIC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cbiAgICAgICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMV1dKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkICYmIGlzRnVuY3Rpb24ocmV0dXJuZWQucHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybmVkLnByb21pc2UoKS5wcm9ncmVzcyhuZXdEZWZlci5ub3RpZnkpLmRvbmUobmV3RGVmZXIucmVzb2x2ZSkuZmFpbChuZXdEZWZlci5yZWplY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXdEZWZlclt0dXBsZVswXSArIFwiV2l0aFwiXSh0aGlzLCBmbiA/IFtyZXR1cm5lZF0gOiBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZucyA9IG51bGw7XG4gICAgICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgICB9LFxuICAgICAgICB0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICB2YXIgbWF4RGVwdGggPSAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZShkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICBtaWdodFRocm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZCwgdGhlbjsgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDwgbWF4RGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkodGhhdCwgYXJncyk7IC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIik7XG4gICAgICAgICAgICAgICAgfSAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG4gICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXG5cbiAgICAgICAgICAgICAgICB0aGVuID0gcmV0dXJuZWQgJiYgKCAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcbiAgICAgICAgICAgICAgICB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIpICYmIHJldHVybmVkLnRoZW47IC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKHJldHVybmVkLCByZXNvbHZlKG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwpLCByZXNvbHZlKG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCkpOyAvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKHJldHVybmVkLCByZXNvbHZlKG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwpLCByZXNvbHZlKG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCksIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgZGVmZXJyZWQubm90aWZ5V2l0aCkpO1xuICAgICAgICAgICAgICAgICAgfSAvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IElkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbcmV0dXJuZWRdO1xuICAgICAgICAgICAgICAgICAgfSAvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblxuXG4gICAgICAgICAgICAgICAgICAoc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCkodGhhdCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLy8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG4gICAgICAgICAgICAgIHByb2Nlc3MgPSBzcGVjaWFsID8gbWlnaHRUaHJvdyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgbWlnaHRUaHJvdygpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vaykge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayhlLCBwcm9jZXNzLnN0YWNrVHJhY2UpO1xuICAgICAgICAgICAgICAgICAgfSAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG4gICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cblxuICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoICsgMSA+PSBtYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gVGhyb3dlcikge1xuICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgodGhhdCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9OyAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuICAgICAgICAgICAgICAvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG4gICAgICAgICAgICAgIC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cblxuICAgICAgICAgICAgICBpZiAoZGVwdGgpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2spIHtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChwcm9jZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uIChuZXdEZWZlcikge1xuICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuICAgICAgICAgICAgdHVwbGVzWzBdWzNdLmFkZChyZXNvbHZlKDAsIG5ld0RlZmVyLCBpc0Z1bmN0aW9uKG9uUHJvZ3Jlc3MpID8gb25Qcm9ncmVzcyA6IElkZW50aXR5LCBuZXdEZWZlci5ub3RpZnlXaXRoKSk7IC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cbiAgICAgICAgICAgIHR1cGxlc1sxXVszXS5hZGQocmVzb2x2ZSgwLCBuZXdEZWZlciwgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IElkZW50aXR5KSk7IC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblxuICAgICAgICAgICAgdHVwbGVzWzJdWzNdLmFkZChyZXNvbHZlKDAsIG5ld0RlZmVyLCBpc0Z1bmN0aW9uKG9uUmVqZWN0ZWQpID8gb25SZWplY3RlZCA6IFRocm93ZXIpKTtcbiAgICAgICAgICB9KS5wcm9taXNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcbiAgICAgICAgLy8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuICAgICAgICBwcm9taXNlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZChvYmosIHByb21pc2UpIDogcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICAgICBkZWZlcnJlZCA9IHt9OyAvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cbiAgICAgIGpRdWVyeS5lYWNoKHR1cGxlcywgZnVuY3Rpb24gKGksIHR1cGxlKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdHVwbGVbMl0sXG4gICAgICAgICAgICBzdGF0ZVN0cmluZyA9IHR1cGxlWzVdOyAvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcbiAgICAgICAgLy8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcbiAgICAgICAgLy8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblxuICAgICAgICBwcm9taXNlW3R1cGxlWzFdXSA9IGxpc3QuYWRkOyAvLyBIYW5kbGUgc3RhdGVcblxuICAgICAgICBpZiAoc3RhdGVTdHJpbmcpIHtcbiAgICAgICAgICBsaXN0LmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuICAgICAgICAgICAgLy8gc3RhdGUgPSBcInJlamVjdGVkXCJcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGVTdHJpbmc7XG4gICAgICAgICAgfSwgLy8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcbiAgICAgICAgICAvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcbiAgICAgICAgICB0dXBsZXNbMyAtIGldWzJdLmRpc2FibGUsIC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcbiAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuICAgICAgICAgIHR1cGxlc1szIC0gaV1bM10uZGlzYWJsZSwgLy8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcbiAgICAgICAgICB0dXBsZXNbMF1bMl0ubG9jaywgLy8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuICAgICAgICAgIHR1cGxlc1swXVszXS5sb2NrKTtcbiAgICAgICAgfSAvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG4gICAgICAgIC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG4gICAgICAgIC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblxuXG4gICAgICAgIGxpc3QuYWRkKHR1cGxlWzNdLmZpcmUpOyAvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cbiAgICAgICAgLy8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cbiAgICAgICAgLy8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cbiAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzBdICsgXCJXaXRoXCJdKHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTsgLy8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcbiAgICAgICAgLy8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG4gICAgICAgIC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cblxuICAgICAgICBkZWZlcnJlZFt0dXBsZVswXSArIFwiV2l0aFwiXSA9IGxpc3QuZmlyZVdpdGg7XG4gICAgICB9KTsgLy8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cbiAgICAgIHByb21pc2UucHJvbWlzZShkZWZlcnJlZCk7IC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgZnVuYy5jYWxsKGRlZmVycmVkLCBkZWZlcnJlZCk7XG4gICAgICB9IC8vIEFsbCBkb25lIVxuXG5cbiAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICB9LFxuICAgIC8vIERlZmVycmVkIGhlbHBlclxuICAgIHdoZW46IGZ1bmN0aW9uIChzaW5nbGVWYWx1ZSkge1xuICAgICAgdmFyIC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuICAgICAgcmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcbiAgICAgIGkgPSByZW1haW5pbmcsXG4gICAgICAgICAgLy8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuICAgICAgcmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoaSksXG4gICAgICAgICAgcmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAvLyB0aGUgbWFzdGVyIERlZmVycmVkXG4gICAgICBtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcbiAgICAgICAgICAvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG4gICAgICB1cGRhdGVGdW5jID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJlc29sdmVDb250ZXh0c1tpXSA9IHRoaXM7XG4gICAgICAgICAgcmVzb2x2ZVZhbHVlc1tpXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbChhcmd1bWVudHMpIDogdmFsdWU7XG5cbiAgICAgICAgICBpZiAoISAtLXJlbWFpbmluZykge1xuICAgICAgICAgICAgbWFzdGVyLnJlc29sdmVXaXRoKHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTsgLy8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cblxuICAgICAgaWYgKHJlbWFpbmluZyA8PSAxKSB7XG4gICAgICAgIGFkb3B0VmFsdWUoc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKHVwZGF0ZUZ1bmMoaSkpLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsICFyZW1haW5pbmcpOyAvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cbiAgICAgICAgaWYgKG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fCBpc0Z1bmN0aW9uKHJlc29sdmVWYWx1ZXNbaV0gJiYgcmVzb2x2ZVZhbHVlc1tpXS50aGVuKSkge1xuICAgICAgICAgIHJldHVybiBtYXN0ZXIudGhlbigpO1xuICAgICAgICB9XG4gICAgICB9IC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBhZG9wdFZhbHVlKHJlc29sdmVWYWx1ZXNbaV0sIHVwZGF0ZUZ1bmMoaSksIG1hc3Rlci5yZWplY3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcbiAgICB9XG4gIH0pOyAvLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbiAgLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG5cbiAgdmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbiAgalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiAoZXJyb3IsIHN0YWNrKSB7XG4gICAgLy8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuICAgIC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG4gICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdChlcnJvci5uYW1lKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUud2FybihcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrKTtcbiAgICB9XG4gIH07XG5cbiAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH07IC8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxuXG5cbiAgdmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG4gIGpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJlYWR5TGlzdC50aGVuKGZuKSAvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuICAgIC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuICAgIC8vIHJlZ2lzdHJhdGlvbi5cbiAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBqUXVlcnkucmVhZHlFeGNlcHRpb24oZXJyb3IpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGpRdWVyeS5leHRlbmQoe1xuICAgIC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG4gICAgaXNSZWFkeTogZmFsc2UsXG4gICAgLy8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuICAgIC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG4gICAgcmVhZHlXYWl0OiAxLFxuICAgIC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcbiAgICByZWFkeTogZnVuY3Rpb24gKHdhaXQpIHtcbiAgICAgIC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcbiAgICAgIGlmICh3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblxuXG4gICAgICBqUXVlcnkuaXNSZWFkeSA9IHRydWU7IC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cbiAgICAgIGlmICh3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cblxuICAgICAgcmVhZHlMaXN0LnJlc29sdmVXaXRoKGRvY3VtZW50LCBbalF1ZXJ5XSk7XG4gICAgfVxuICB9KTtcbiAgalF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjsgLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcblxuICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcGxldGVkKTtcbiAgICBqUXVlcnkucmVhZHkoKTtcbiAgfSAvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuICAvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbiAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuICAvLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cblxuXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCkge1xuICAgIC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGpRdWVyeS5yZWFkeSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCk7IC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcGxldGVkKTtcbiAgfSAvLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbiAgLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG5cblxuICB2YXIgYWNjZXNzID0gZnVuY3Rpb24gKGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3KSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBsZW4gPSBlbGVtcy5sZW5ndGgsXG4gICAgICAgIGJ1bGsgPSBrZXkgPT0gbnVsbDsgLy8gU2V0cyBtYW55IHZhbHVlc1xuXG4gICAgaWYgKHRvVHlwZShrZXkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjaGFpbmFibGUgPSB0cnVlO1xuXG4gICAgICBmb3IgKGkgaW4ga2V5KSB7XG4gICAgICAgIGFjY2VzcyhlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyk7XG4gICAgICB9IC8vIFNldHMgb25lIHZhbHVlXG5cbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoYWluYWJsZSA9IHRydWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmF3ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1bGspIHtcbiAgICAgICAgLy8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG4gICAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgICBmbi5jYWxsKGVsZW1zLCB2YWx1ZSk7XG4gICAgICAgICAgZm4gPSBudWxsOyAvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVsayA9IGZuO1xuXG4gICAgICAgICAgZm4gPSBmdW5jdGlvbiAoZWxlbSwgX2tleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBidWxrLmNhbGwoalF1ZXJ5KGVsZW0pLCB2YWx1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGZuKGVsZW1zW2ldLCBrZXksIHJhdyA/IHZhbHVlIDogdmFsdWUuY2FsbChlbGVtc1tpXSwgaSwgZm4oZWxlbXNbaV0sIGtleSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGFpbmFibGUpIHtcbiAgICAgIHJldHVybiBlbGVtcztcbiAgICB9IC8vIEdldHNcblxuXG4gICAgaWYgKGJ1bGspIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKGVsZW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuID8gZm4oZWxlbXNbMF0sIGtleSkgOiBlbXB0eUdldDtcbiAgfTsgLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cblxuICB2YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcbiAgICAgIHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZzsgLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cbiAgZnVuY3Rpb24gZmNhbWVsQ2FzZShfYWxsLCBsZXR0ZXIpIHtcbiAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0gLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4gIC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcblxuXG4gIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2Uocm1zUHJlZml4LCBcIm1zLVwiKS5yZXBsYWNlKHJkYXNoQWxwaGEsIGZjYW1lbENhc2UpO1xuICB9XG5cbiAgdmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICAvLyBBY2NlcHRzIG9ubHk6XG4gICAgLy8gIC0gTm9kZVxuICAgIC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcbiAgICAvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuICAgIC8vICAtIE9iamVjdFxuICAgIC8vICAgIC0gQW55XG4gICAgcmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICErb3duZXIubm9kZVR5cGU7XG4gIH07XG5cbiAgZnVuY3Rpb24gRGF0YSgpIHtcbiAgICB0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG4gIH1cblxuICBEYXRhLnVpZCA9IDE7XG4gIERhdGEucHJvdG90eXBlID0ge1xuICAgIGNhY2hlOiBmdW5jdGlvbiAob3duZXIpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuICAgICAgdmFyIHZhbHVlID0gb3duZXJbdGhpcy5leHBhbmRvXTsgLy8gSWYgbm90LCBjcmVhdGUgb25lXG5cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB7fTsgLy8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG4gICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG4gICAgICAgIC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXG4gICAgICAgIGlmIChhY2NlcHREYXRhKG93bmVyKSkge1xuICAgICAgICAgIC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcbiAgICAgICAgICAvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuICAgICAgICAgIGlmIChvd25lci5ub2RlVHlwZSkge1xuICAgICAgICAgICAgb3duZXJbdGhpcy5leHBhbmRvXSA9IHZhbHVlOyAvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG4gICAgICAgICAgICAvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvd25lciwgdGhpcy5leHBhbmRvLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAob3duZXIsIGRhdGEsIHZhbHVlKSB7XG4gICAgICB2YXIgcHJvcCxcbiAgICAgICAgICBjYWNoZSA9IHRoaXMuY2FjaGUob3duZXIpOyAvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG4gICAgICAvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjYWNoZVtjYW1lbENhc2UoZGF0YSldID0gdmFsdWU7IC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuICAgICAgICBmb3IgKHByb3AgaW4gZGF0YSkge1xuICAgICAgICAgIGNhY2hlW2NhbWVsQ2FzZShwcm9wKV0gPSBkYXRhW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gKG93bmVyLCBrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/IHRoaXMuY2FjaGUob3duZXIpIDogLy8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuICAgICAgb3duZXJbdGhpcy5leHBhbmRvXSAmJiBvd25lclt0aGlzLmV4cGFuZG9dW2NhbWVsQ2FzZShrZXkpXTtcbiAgICB9LFxuICAgIGFjY2VzczogZnVuY3Rpb24gKG93bmVyLCBrZXksIHZhbHVlKSB7XG4gICAgICAvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG4gICAgICAvL1xuICAgICAgLy8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuICAgICAgLy8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG4gICAgICAvL1xuICAgICAgLy8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG4gICAgICAvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG4gICAgICAvL1xuICAgICAgLy8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuICAgICAgLy8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuICAgICAgLy9cbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChvd25lciwga2V5KTtcbiAgICAgIH0gLy8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcbiAgICAgIC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuICAgICAgLy9cbiAgICAgIC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcbiAgICAgIC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG4gICAgICAvL1xuXG5cbiAgICAgIHRoaXMuc2V0KG93bmVyLCBrZXksIHZhbHVlKTsgLy8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG4gICAgICAvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblxuICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKG93bmVyLCBrZXkpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGNhY2hlID0gb3duZXJbdGhpcy5leHBhbmRvXTtcblxuICAgICAgaWYgKGNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgIC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG4gICAgICAgICAgLy8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG4gICAgICAgICAga2V5ID0ga2V5Lm1hcChjYW1lbENhc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSA9IGNhbWVsQ2FzZShrZXkpOyAvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2VcblxuICAgICAgICAgIGtleSA9IGtleSBpbiBjYWNoZSA/IFtrZXldIDoga2V5Lm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaSA9IGtleS5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXlbaV1dO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXG5cbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdChjYWNoZSkpIHtcbiAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuICAgICAgICAvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuICAgICAgICAvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG4gICAgICAgIGlmIChvd25lci5ub2RlVHlwZSkge1xuICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIG93bmVyW3RoaXMuZXhwYW5kb107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc0RhdGE6IGZ1bmN0aW9uIChvd25lcikge1xuICAgICAgdmFyIGNhY2hlID0gb3duZXJbdGhpcy5leHBhbmRvXTtcbiAgICAgIHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdChjYWNoZSk7XG4gICAgfVxuICB9O1xuICB2YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuICB2YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpOyAvL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuICAvL1xuICAvL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuICAvL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4gIC8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbiAgLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4gIC8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4gIC8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbiAgLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG4gIHZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG4gICAgICBybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbiAgZnVuY3Rpb24gZ2V0RGF0YShkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgPT09IFwibnVsbFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cblxuICAgIGlmIChkYXRhID09PSArZGF0YSArIFwiXCIpIHtcbiAgICAgIHJldHVybiArZGF0YTtcbiAgICB9XG5cbiAgICBpZiAocmJyYWNlLnRlc3QoZGF0YSkpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gZGF0YUF0dHIoZWxlbSwga2V5LCBkYXRhKSB7XG4gICAgdmFyIG5hbWU7IC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcbiAgICAvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgbmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKHJtdWx0aURhc2gsIFwiLSQmXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBnZXREYXRhKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fSAvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblxuXG4gICAgICAgIGRhdGFVc2VyLnNldChlbGVtLCBrZXksIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGpRdWVyeS5leHRlbmQoe1xuICAgIGhhc0RhdGE6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICByZXR1cm4gZGF0YVVzZXIuaGFzRGF0YShlbGVtKSB8fCBkYXRhUHJpdi5oYXNEYXRhKGVsZW0pO1xuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhVXNlci5hY2Nlc3MoZWxlbSwgbmFtZSwgZGF0YSk7XG4gICAgfSxcbiAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xuICAgICAgZGF0YVVzZXIucmVtb3ZlKGVsZW0sIG5hbWUpO1xuICAgIH0sXG4gICAgLy8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcbiAgICAvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cbiAgICBfZGF0YTogZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoZWxlbSwgbmFtZSwgZGF0YSk7XG4gICAgfSxcbiAgICBfcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGVsZW0sIG5hbWUpIHtcbiAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCBuYW1lKTtcbiAgICB9XG4gIH0pO1xuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICBkYXRhOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGVsZW0gPSB0aGlzWzBdLFxuICAgICAgICAgIGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7IC8vIEdldHMgYWxsIHZhbHVlc1xuXG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgZGF0YSA9IGRhdGFVc2VyLmdldChlbGVtKTtcblxuICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoZWxlbSwgXCJoYXNEYXRhQXR0cnNcIikpIHtcbiAgICAgICAgICAgIGkgPSBhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEgb25seVxuICAgICAgICAgICAgICAvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcbiAgICAgICAgICAgICAgaWYgKGF0dHJzW2ldKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKFwiZGF0YS1cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbENhc2UobmFtZS5zbGljZSg1KSk7XG4gICAgICAgICAgICAgICAgICBkYXRhQXR0cihlbGVtLCBuYW1lLCBkYXRhW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YVByaXYuc2V0KGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSAvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXG5cbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRhdGFVc2VyLnNldCh0aGlzLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGE7IC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG4gICAgICAgIC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG4gICAgICAgIC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG4gICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblxuICAgICAgICBpZiAoZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgIC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG4gICAgICAgICAgZGF0YSA9IGRhdGFVc2VyLmdldChlbGVtLCBrZXkpO1xuXG4gICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgfSAvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuICAgICAgICAgIC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblxuXG4gICAgICAgICAgZGF0YSA9IGRhdGFBdHRyKGVsZW0sIGtleSk7XG5cbiAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9IC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFNldCB0aGUgZGF0YS4uLlxuXG5cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG4gICAgICAgICAgZGF0YVVzZXIuc2V0KHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGF0YVVzZXIucmVtb3ZlKHRoaXMsIGtleSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBqUXVlcnkuZXh0ZW5kKHtcbiAgICBxdWV1ZTogZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGRhdGEpIHtcbiAgICAgIHZhciBxdWV1ZTtcblxuICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgdHlwZSA9ICh0eXBlIHx8IFwiZnhcIikgKyBcInF1ZXVlXCI7XG4gICAgICAgIHF1ZXVlID0gZGF0YVByaXYuZ2V0KGVsZW0sIHR5cGUpOyAvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBpZiAoIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxdWV1ZSB8fCBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlcXVldWU6IGZ1bmN0aW9uIChlbGVtLCB0eXBlKSB7XG4gICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cbiAgICAgIHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZShlbGVtLCB0eXBlKSxcbiAgICAgICAgICBzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcbiAgICAgICAgICBmbiA9IHF1ZXVlLnNoaWZ0KCksXG4gICAgICAgICAgaG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoZWxlbSwgdHlwZSksXG4gICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgalF1ZXJ5LmRlcXVldWUoZWxlbSwgdHlwZSk7XG4gICAgICB9OyAvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cblxuICAgICAgaWYgKGZuID09PSBcImlucHJvZ3Jlc3NcIikge1xuICAgICAgICBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHN0YXJ0TGVuZ3RoLS07XG4gICAgICB9XG5cbiAgICAgIGlmIChmbikge1xuICAgICAgICAvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZnhcIikge1xuICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpO1xuICAgICAgICB9IC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblxuXG4gICAgICAgIGRlbGV0ZSBob29rcy5zdG9wO1xuICAgICAgICBmbi5jYWxsKGVsZW0sIG5leHQsIGhvb2tzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdGFydExlbmd0aCAmJiBob29rcykge1xuICAgICAgICBob29rcy5lbXB0eS5maXJlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuICAgIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiAoZWxlbSwgdHlwZSkge1xuICAgICAgdmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcbiAgICAgIHJldHVybiBkYXRhUHJpdi5nZXQoZWxlbSwga2V5KSB8fCBkYXRhUHJpdi5hY2Nlc3MoZWxlbSwga2V5LCB7XG4gICAgICAgIGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgW3R5cGUgKyBcInF1ZXVlXCIsIGtleV0pO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgcXVldWU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICB2YXIgc2V0dGVyID0gMjtcblxuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEgPSB0eXBlO1xuICAgICAgICB0eXBlID0gXCJmeFwiO1xuICAgICAgICBzZXR0ZXItLTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5xdWV1ZSh0aGlzWzBdLCB0eXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUodGhpcywgdHlwZSwgZGF0YSk7IC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cbiAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKHRoaXMsIHR5cGUpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbMF0gIT09IFwiaW5wcm9ncmVzc1wiKSB7XG4gICAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVxdWV1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXVlKHR5cGUgfHwgXCJmeFwiLCBbXSk7XG4gICAgfSxcbiAgICAvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG4gICAgLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG4gICAgcHJvbWlzZTogZnVuY3Rpb24gKHR5cGUsIG9iaikge1xuICAgICAgdmFyIHRtcCxcbiAgICAgICAgICBjb3VudCA9IDEsXG4gICAgICAgICAgZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcbiAgICAgICAgICBlbGVtZW50cyA9IHRoaXMsXG4gICAgICAgICAgaSA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgIHJlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghIC0tY291bnQpIHtcbiAgICAgICAgICBkZWZlci5yZXNvbHZlV2l0aChlbGVtZW50cywgW2VsZW1lbnRzXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvYmogPSB0eXBlO1xuICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdG1wID0gZGF0YVByaXYuZ2V0KGVsZW1lbnRzW2ldLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIpO1xuXG4gICAgICAgIGlmICh0bXAgJiYgdG1wLmVtcHR5KSB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgICB0bXAuZW1wdHkuYWRkKHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKG9iaik7XG4gICAgfVxuICB9KTtcbiAgdmFyIHBudW0gPSAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2U7XG4gIHZhciByY3NzTnVtID0gbmV3IFJlZ0V4cChcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIik7XG4gIHZhciBjc3NFeHBhbmQgPSBbXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIl07XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgdmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHJldHVybiBqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKTtcbiAgfSxcbiAgICAgIGNvbXBvc2VkID0ge1xuICAgIGNvbXBvc2VkOiB0cnVlXG4gIH07IC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCssIGlPUyAxMC4wIC0gMTAuMiBvbmx5XG4gIC8vIENoZWNrIGF0dGFjaG1lbnQgYWNyb3NzIHNoYWRvdyBET00gYm91bmRhcmllcyB3aGVuIHBvc3NpYmxlIChnaC0zNTA0KVxuICAvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcbiAgLy8gRWFybHkgaU9TIDEwIHZlcnNpb25zIHN1cHBvcnQgYGF0dGFjaFNoYWRvd2AgYnV0IG5vdCBgZ2V0Um9vdE5vZGVgLFxuICAvLyBsZWFkaW5nIHRvIGVycm9ycy4gV2UgbmVlZCB0byBjaGVjayBmb3IgYGdldFJvb3ROb2RlYC5cblxuXG4gIGlmIChkb2N1bWVudEVsZW1lbnQuZ2V0Um9vdE5vZGUpIHtcbiAgICBpc0F0dGFjaGVkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHJldHVybiBqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSB8fCBlbGVtLmdldFJvb3ROb2RlKGNvbXBvc2VkKSA9PT0gZWxlbS5vd25lckRvY3VtZW50O1xuICAgIH07XG4gIH1cblxuICB2YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24gKGVsZW0sIGVsKSB7XG4gICAgLy8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG4gICAgLy8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG4gICAgZWxlbSA9IGVsIHx8IGVsZW07IC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cbiAgICByZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgLy8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG4gICAgLy8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG4gICAgLy8gaW4gdGhlIGRvY3VtZW50LlxuICAgIGlzQXR0YWNoZWQoZWxlbSkgJiYgalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIikgPT09IFwibm9uZVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkanVzdENTUyhlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2Vlbikge1xuICAgIHZhciBhZGp1c3RlZCxcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIG1heEl0ZXJhdGlvbnMgPSAyMCxcbiAgICAgICAgY3VycmVudFZhbHVlID0gdHdlZW4gPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHdlZW4uY3VyKCk7XG4gICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBqUXVlcnkuY3NzKGVsZW0sIHByb3AsIFwiXCIpO1xuICAgIH0sXG4gICAgICAgIGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcbiAgICAgICAgdW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1szXSB8fCAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSA/IFwiXCIgOiBcInB4XCIpLFxuICAgICAgICAvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuICAgIGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmIChqUXVlcnkuY3NzTnVtYmVyW3Byb3BdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCkgJiYgcmNzc051bS5leGVjKGpRdWVyeS5jc3MoZWxlbSwgcHJvcCkpO1xuXG4gICAgaWYgKGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFszXSAhPT0gdW5pdCkge1xuICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG4gICAgICAvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG4gICAgICBpbml0aWFsID0gaW5pdGlhbCAvIDI7IC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3NcblxuICAgICAgdW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFszXTsgLy8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblxuICAgICAgaW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cbiAgICAgIHdoaWxlIChtYXhJdGVyYXRpb25zLS0pIHtcbiAgICAgICAgLy8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cbiAgICAgICAgLy8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQpO1xuXG4gICAgICAgIGlmICgoMSAtIHNjYWxlKSAqICgxIC0gKHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSkpIDw9IDApIHtcbiAgICAgICAgICBtYXhJdGVyYXRpb25zID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcbiAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCk7IC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblxuICAgICAgdmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlUGFydHMpIHtcbiAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwOyAvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblxuICAgICAgYWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWzFdID8gaW5pdGlhbEluVW5pdCArICh2YWx1ZVBhcnRzWzFdICsgMSkgKiB2YWx1ZVBhcnRzWzJdIDogK3ZhbHVlUGFydHNbMl07XG5cbiAgICAgIGlmICh0d2Vlbikge1xuICAgICAgICB0d2Vlbi51bml0ID0gdW5pdDtcbiAgICAgICAgdHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuICAgICAgICB0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWRqdXN0ZWQ7XG4gIH1cblxuICB2YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuICBmdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheShlbGVtKSB7XG4gICAgdmFyIHRlbXAsXG4gICAgICAgIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcbiAgICAgICAgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuICAgICAgICBkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbbm9kZU5hbWVdO1xuXG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIHJldHVybiBkaXNwbGF5O1xuICAgIH1cblxuICAgIHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlRWxlbWVudChub2RlTmFtZSkpO1xuICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKHRlbXAsIFwiZGlzcGxheVwiKTtcbiAgICB0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGVtcCk7XG5cbiAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgIGRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfVxuXG4gICAgZGVmYXVsdERpc3BsYXlNYXBbbm9kZU5hbWVdID0gZGlzcGxheTtcbiAgICByZXR1cm4gZGlzcGxheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3dIaWRlKGVsZW1lbnRzLCBzaG93KSB7XG4gICAgdmFyIGRpc3BsYXksXG4gICAgICAgIGVsZW0sXG4gICAgICAgIHZhbHVlcyA9IFtdLFxuICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDsgLy8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cbiAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGVsZW0gPSBlbGVtZW50c1tpbmRleF07XG5cbiAgICAgIGlmICghZWxlbS5zdHlsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblxuICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgLy8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuICAgICAgICAvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcbiAgICAgICAgLy8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuICAgICAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gZGF0YVByaXYuZ2V0KGVsZW0sIFwiZGlzcGxheVwiKSB8fCBudWxsO1xuXG4gICAgICAgICAgaWYgKCF2YWx1ZXNbaW5kZXhdKSB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKGVsZW0pKSB7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IGdldERlZmF1bHREaXNwbGF5KGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGlzcGxheSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gXCJub25lXCI7IC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblxuICAgICAgICAgIGRhdGFQcml2LnNldChlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblxuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAodmFsdWVzW2luZGV4XSAhPSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnRzW2luZGV4XS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH1cblxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2hvd0hpZGUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2hvd0hpZGUodGhpcyk7XG4gICAgfSxcbiAgICB0b2dnbGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc0hpZGRlbldpdGhpblRyZWUodGhpcykpIHtcbiAgICAgICAgICBqUXVlcnkodGhpcykuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGpRdWVyeSh0aGlzKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHZhciByY2hlY2thYmxlVHlwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pO1xuICB2YXIgcnRhZ05hbWUgPSAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2k7XG4gIHZhciByc2NyaXB0VHlwZSA9IC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2k7XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLFxuICAgICAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTsgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuICAgIC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG4gICAgLy8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuICAgIC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInJhZGlvXCIpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJ0XCIpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChpbnB1dCk7IC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuICAgIC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXG4gICAgc3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSh0cnVlKS5jbG9uZU5vZGUodHJ1ZSkubGFzdENoaWxkLmNoZWNrZWQ7IC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgIC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cbiAgICBkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG4gICAgc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSh0cnVlKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlOyAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgIC8vIElFIDw9OSByZXBsYWNlcyA8b3B0aW9uPiB0YWdzIHdpdGggdGhlaXIgY29udGVudHMgd2hlbiBpbnNlcnRlZCBvdXRzaWRlIG9mXG4gICAgLy8gdGhlIHNlbGVjdCBlbGVtZW50LlxuXG4gICAgZGl2LmlubmVySFRNTCA9IFwiPG9wdGlvbj48L29wdGlvbj5cIjtcbiAgICBzdXBwb3J0Lm9wdGlvbiA9ICEhZGl2Lmxhc3RDaGlsZDtcbiAgfSkoKTsgLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcblxuXG4gIHZhciB3cmFwTWFwID0ge1xuICAgIC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG4gICAgLy8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuICAgIC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cbiAgICB0aGVhZDogWzEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCJdLFxuICAgIGNvbDogWzIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLFxuICAgIHRyOiBbMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sXG4gICAgdGQ6IFszLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSxcbiAgICBfZGVmYXVsdDogWzAsIFwiXCIsIFwiXCJdXG4gIH07XG4gIHdyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG4gIHdyYXBNYXAudGggPSB3cmFwTWFwLnRkOyAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXG4gIGlmICghc3VwcG9ydC5vcHRpb24pIHtcbiAgICB3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb24gPSBbMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCJdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWxsKGNvbnRleHQsIHRhZykge1xuICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcbiAgICAvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG4gICAgdmFyIHJldDtcblxuICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcgfHwgXCIqXCIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHRhZyB8fCBcIipcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoY29udGV4dCwgdGFnKSkge1xuICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZShbY29udGV4dF0sIHJldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSAvLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcblxuXG4gIGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoZWxlbXMsIHJlZkVsZW1lbnRzKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBsID0gZWxlbXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGRhdGFQcml2LnNldChlbGVtc1tpXSwgXCJnbG9iYWxFdmFsXCIsICFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQocmVmRWxlbWVudHNbaV0sIFwiZ2xvYmFsRXZhbFwiKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCkge1xuICAgIHZhciBlbGVtLFxuICAgICAgICB0bXAsXG4gICAgICAgIHRhZyxcbiAgICAgICAgd3JhcCxcbiAgICAgICAgYXR0YWNoZWQsXG4gICAgICAgIGosXG4gICAgICAgIGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIG5vZGVzID0gW10sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBsID0gZWxlbXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGVsZW0gPSBlbGVtc1tpXTtcblxuICAgICAgaWYgKGVsZW0gfHwgZWxlbSA9PT0gMCkge1xuICAgICAgICAvLyBBZGQgbm9kZXMgZGlyZWN0bHlcbiAgICAgICAgaWYgKHRvVHlwZShlbGVtKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcbiAgICAgICAgICBqUXVlcnkubWVyZ2Uobm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbZWxlbV0gOiBlbGVtKTsgLy8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG4gICAgICAgIH0gZWxzZSBpZiAoIXJodG1sLnRlc3QoZWxlbSkpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoZWxlbSkpOyAvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTsgLy8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXG4gICAgICAgICAgdGFnID0gKHJ0YWdOYW1lLmV4ZWMoZWxlbSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHdyYXAgPSB3cmFwTWFwW3RhZ10gfHwgd3JhcE1hcC5fZGVmYXVsdDtcbiAgICAgICAgICB0bXAuaW5uZXJIVE1MID0gd3JhcFsxXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKGVsZW0pICsgd3JhcFsyXTsgLy8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cbiAgICAgICAgICBqID0gd3JhcFswXTtcblxuICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgfSAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cblxuICAgICAgICAgIGpRdWVyeS5tZXJnZShub2RlcywgdG1wLmNoaWxkTm9kZXMpOyAvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXG4gICAgICAgICAgdG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDsgLy8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXG4gICAgICAgICAgdG1wLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXG5cbiAgICBmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoZWxlbSA9IG5vZGVzW2krK10pIHtcbiAgICAgIC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KGVsZW0sIHNlbGVjdGlvbikgPiAtMSkge1xuICAgICAgICBpZiAoaWdub3JlZCkge1xuICAgICAgICAgIGlnbm9yZWQucHVzaChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2hlZCA9IGlzQXR0YWNoZWQoZWxlbSk7IC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXG4gICAgICB0bXAgPSBnZXRBbGwoZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWxlbSksIFwic2NyaXB0XCIpOyAvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cbiAgICAgIGlmIChhdHRhY2hlZCkge1xuICAgICAgICBzZXRHbG9iYWxFdmFsKHRtcCk7XG4gICAgICB9IC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblxuXG4gICAgICBpZiAoc2NyaXB0cykge1xuICAgICAgICBqID0gMDtcblxuICAgICAgICB3aGlsZSAoZWxlbSA9IHRtcFtqKytdKSB7XG4gICAgICAgICAgaWYgKHJzY3JpcHRUeXBlLnRlc3QoZWxlbS50eXBlIHx8IFwiXCIpKSB7XG4gICAgICAgICAgICBzY3JpcHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG5cbiAgdmFyIHJrZXlFdmVudCA9IC9ea2V5LyxcbiAgICAgIHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuICAgICAgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG4gIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4gIC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzLCBleGNlcHQgd2hlbiB0aGV5IGFyZSBuby1vcC5cbiAgLy8gU28gZXhwZWN0IGZvY3VzIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhY3RpdmUsXG4gIC8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuICAvLyAoZm9jdXMgYW5kIGJsdXIgYXJlIGFsd2F5cyBzeW5jaHJvbm91cyBpbiBvdGhlciBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4gIC8vIHRoaXMganVzdCBkZWZpbmVzIHdoZW4gd2UgY2FuIGNvdW50IG9uIGl0KS5cblxuXG4gIGZ1bmN0aW9uIGV4cGVjdFN5bmMoZWxlbSwgdHlwZSkge1xuICAgIHJldHVybiBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpID09PSAodHlwZSA9PT0gXCJmb2N1c1wiKTtcbiAgfSAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAvLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XG4gIC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuXG5cbiAgZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSkge1xuICAgIHZhciBvcmlnRm4sIHR5cGU7IC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuICAgICAgICBkYXRhID0gZGF0YSB8fCBzZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodHlwZSBpbiB0eXBlcykge1xuICAgICAgICBvbihlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbdHlwZV0sIG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIGlmIChkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCkge1xuICAgICAgLy8gKCB0eXBlcywgZm4gKVxuICAgICAgZm4gPSBzZWxlY3RvcjtcbiAgICAgIGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGZuID09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcbiAgICAgICAgZm4gPSBkYXRhO1xuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxuICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgIGRhdGEgPSBzZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZuID09PSBmYWxzZSkge1xuICAgICAgZm4gPSByZXR1cm5GYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFmbikge1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgaWYgKG9uZSA9PT0gMSkge1xuICAgICAgb3JpZ0ZuID0gZm47XG5cbiAgICAgIGZuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuICAgICAgICBqUXVlcnkoKS5vZmYoZXZlbnQpO1xuICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9OyAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXG5cbiAgICAgIGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAob3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGpRdWVyeS5ldmVudC5hZGQodGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3Rvcik7XG4gICAgfSk7XG4gIH1cbiAgLypcbiAgICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICAgKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICAgKi9cblxuXG4gIGpRdWVyeS5ldmVudCA9IHtcbiAgICBnbG9iYWw6IHt9LFxuICAgIGFkZDogZnVuY3Rpb24gKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIGhhbmRsZU9iakluLFxuICAgICAgICAgIGV2ZW50SGFuZGxlLFxuICAgICAgICAgIHRtcCxcbiAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgdCxcbiAgICAgICAgICBoYW5kbGVPYmosXG4gICAgICAgICAgc3BlY2lhbCxcbiAgICAgICAgICBoYW5kbGVycyxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG5hbWVzcGFjZXMsXG4gICAgICAgICAgb3JpZ1R5cGUsXG4gICAgICAgICAgZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoZWxlbSk7IC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcblxuICAgICAgaWYgKCFhY2NlcHREYXRhKGVsZW0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cblxuICAgICAgaWYgKGhhbmRsZXIuaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuICAgICAgICBzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuICAgICAgfSAvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG4gICAgICAvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblxuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IpO1xuICAgICAgfSAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblxuXG4gICAgICBpZiAoIWhhbmRsZXIuZ3VpZCkge1xuICAgICAgICBoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuICAgICAgfSAvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cblxuICAgICAgaWYgKCEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSkge1xuICAgICAgICBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSkpIHtcbiAgICAgICAgZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG4gICAgICAgICAgLy8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuICAgICAgICAgIHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/IGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseShlbGVtLCBhcmd1bWVudHMpIDogdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgfSAvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cblxuICAgICAgdHlwZXMgPSAodHlwZXMgfHwgXCJcIikubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW1wiXCJdO1xuICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHQtLSkge1xuICAgICAgICB0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKHR5cGVzW3RdKSB8fCBbXTtcbiAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuICAgICAgICBuYW1lc3BhY2VzID0gKHRtcFsyXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpOyAvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblxuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblxuXG4gICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTsgLy8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cbiAgICAgICAgdHlwZSA9IChzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSkgfHwgdHlwZTsgLy8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXG4gICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTsgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblxuICAgICAgICBoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIG9yaWdUeXBlOiBvcmlnVHlwZSxcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgZ3VpZDogaGFuZGxlci5ndWlkLFxuICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICBuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KHNlbGVjdG9yKSxcbiAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbihcIi5cIilcbiAgICAgICAgfSwgaGFuZGxlT2JqSW4pOyAvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXG4gICAgICAgIGlmICghKGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdKSkge1xuICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdID0gW107XG4gICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7IC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXG4gICAgICAgICAgaWYgKCFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbChlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldmVudEhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWNpYWwuYWRkKSB7XG4gICAgICAgICAgc3BlY2lhbC5hZGQuY2FsbChlbGVtLCBoYW5kbGVPYmopO1xuXG4gICAgICAgICAgaWYgKCFoYW5kbGVPYmouaGFuZGxlci5ndWlkKSB7XG4gICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXG5cbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZU9iaik7XG4gICAgICAgIH0gLy8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXG5cbiAgICAgICAgalF1ZXJ5LmV2ZW50Lmdsb2JhbFt0eXBlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzKSB7XG4gICAgICB2YXIgaixcbiAgICAgICAgICBvcmlnQ291bnQsXG4gICAgICAgICAgdG1wLFxuICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICB0LFxuICAgICAgICAgIGhhbmRsZU9iaixcbiAgICAgICAgICBzcGVjaWFsLFxuICAgICAgICAgIGhhbmRsZXJzLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgbmFtZXNwYWNlcyxcbiAgICAgICAgICBvcmlnVHlwZSxcbiAgICAgICAgICBlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoZWxlbSkgJiYgZGF0YVByaXYuZ2V0KGVsZW0pO1xuXG4gICAgICBpZiAoIWVsZW1EYXRhIHx8ICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblxuXG4gICAgICB0eXBlcyA9ICh0eXBlcyB8fCBcIlwiKS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXCJcIl07XG4gICAgICB0ID0gdHlwZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAodC0tKSB7XG4gICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWModHlwZXNbdF0pIHx8IFtdO1xuICAgICAgICB0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XG4gICAgICAgIG5hbWVzcGFjZXMgPSAodG1wWzJdIHx8IFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCk7IC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIGZvciAodHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoZWxlbSwgdHlwZSArIHR5cGVzW3RdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XG4gICAgICAgIHR5cGUgPSAoc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUpIHx8IHR5cGU7XG4gICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdIHx8IFtdO1xuICAgICAgICB0bXAgPSB0bXBbMl0gJiYgbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKTsgLy8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXG4gICAgICAgIG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzW2pdO1xuXG4gICAgICAgICAgaWYgKChtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlKSAmJiAoIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCkgJiYgKCF0bXAgfHwgdG1wLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpICYmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShqLCAxKTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZU9iai5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzcGVjaWFsLnJlbW92ZSkge1xuICAgICAgICAgICAgICBzcGVjaWFsLnJlbW92ZS5jYWxsKGVsZW0sIGhhbmRsZU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3RcbiAgICAgICAgLy8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cblxuICAgICAgICBpZiAob3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXNwZWNpYWwudGVhcmRvd24gfHwgc3BlY2lhbC50ZWFyZG93bi5jYWxsKGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBqUXVlcnkucmVtb3ZlRXZlbnQoZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cblxuICAgICAgaWYgKGpRdWVyeS5pc0VtcHR5T2JqZWN0KGV2ZW50cykpIHtcbiAgICAgICAgZGF0YVByaXYucmVtb3ZlKGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAobmF0aXZlRXZlbnQpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGosXG4gICAgICAgICAgcmV0LFxuICAgICAgICAgIG1hdGNoZWQsXG4gICAgICAgICAgaGFuZGxlT2JqLFxuICAgICAgICAgIGhhbmRsZXJRdWV1ZSxcbiAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLFxuICAgICAgICAgIC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuICAgICAgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KG5hdGl2ZUV2ZW50KSxcbiAgICAgICAgICBoYW5kbGVycyA9IChkYXRhUHJpdi5nZXQodGhpcywgXCJldmVudHNcIikgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSlbZXZlbnQudHlwZV0gfHwgW10sXG4gICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW2V2ZW50LnR5cGVdIHx8IHt9OyAvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXG4gICAgICBhcmdzWzBdID0gZXZlbnQ7XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzOyAvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cbiAgICAgIGlmIChzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cblxuICAgICAgaGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcywgZXZlbnQsIGhhbmRsZXJzKTsgLy8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblxuICAgICAgaSA9IDA7XG5cbiAgICAgIHdoaWxlICgobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuICAgICAgICBqID0gMDtcblxuICAgICAgICB3aGlsZSAoKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbaisrXSkgJiYgIWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG4gICAgICAgICAgLy8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cbiAgICAgICAgICBpZiAoIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KGhhbmRsZU9iai5uYW1lc3BhY2UpKSB7XG4gICAgICAgICAgICBldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG4gICAgICAgICAgICBldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG4gICAgICAgICAgICByZXQgPSAoKGpRdWVyeS5ldmVudC5zcGVjaWFsW2hhbmRsZU9iai5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fCBoYW5kbGVPYmouaGFuZGxlcikuYXBwbHkobWF0Y2hlZC5lbGVtLCBhcmdzKTtcblxuICAgICAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmICgoZXZlbnQucmVzdWx0ID0gcmV0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblxuXG4gICAgICBpZiAoc3BlY2lhbC5wb3N0RGlzcGF0Y2gpIHtcbiAgICAgICAgc3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgfSxcbiAgICBoYW5kbGVyczogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVycykge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgaGFuZGxlT2JqLFxuICAgICAgICAgIHNlbCxcbiAgICAgICAgICBtYXRjaGVkSGFuZGxlcnMsXG4gICAgICAgICAgbWF0Y2hlZFNlbGVjdG9ycyxcbiAgICAgICAgICBoYW5kbGVyUXVldWUgPSBbXSxcbiAgICAgICAgICBkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcbiAgICAgICAgICBjdXIgPSBldmVudC50YXJnZXQ7IC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblxuICAgICAgaWYgKGRlbGVnYXRlQ291bnQgJiYgLy8gU3VwcG9ydDogSUUgPD05XG4gICAgICAvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcbiAgICAgIGN1ci5ub2RlVHlwZSAmJiAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcbiAgICAgIC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcbiAgICAgIC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcbiAgICAgIC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0MylcbiAgICAgICEoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxKSkge1xuICAgICAgICBmb3IgKDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG4gICAgICAgICAgLy8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG4gICAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUpKSB7XG4gICAgICAgICAgICBtYXRjaGVkSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgIG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBoYW5kbGVPYmogPSBoYW5kbGVyc1tpXTsgLy8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblxuICAgICAgICAgICAgICBzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuICAgICAgICAgICAgICBpZiAobWF0Y2hlZFNlbGVjdG9yc1tzZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzW3NlbF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID8galF1ZXJ5KHNlbCwgdGhpcykuaW5kZXgoY3VyKSA+IC0xIDogalF1ZXJ5LmZpbmQoc2VsLCB0aGlzLCBudWxsLCBbY3VyXSkubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1hdGNoZWRTZWxlY3RvcnNbc2VsXSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycy5wdXNoKGhhbmRsZU9iaik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoZWRIYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIGVsZW06IGN1cixcbiAgICAgICAgICAgICAgICBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cblxuICAgICAgY3VyID0gdGhpcztcblxuICAgICAgaWYgKGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goe1xuICAgICAgICAgIGVsZW06IGN1cixcbiAgICAgICAgICBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoZGVsZWdhdGVDb3VudClcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVyUXVldWU7XG4gICAgfSxcbiAgICBhZGRQcm9wOiBmdW5jdGlvbiAobmFtZSwgaG9vaykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGlzRnVuY3Rpb24oaG9vaykgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2sodGhpcy5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFtuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZpeDogZnVuY3Rpb24gKG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgIHJldHVybiBvcmlnaW5hbEV2ZW50W2pRdWVyeS5leHBhbmRvXSA/IG9yaWdpbmFsRXZlbnQgOiBuZXcgalF1ZXJ5LkV2ZW50KG9yaWdpbmFsRXZlbnQpO1xuICAgIH0sXG4gICAgc3BlY2lhbDoge1xuICAgICAgbG9hZDoge1xuICAgICAgICAvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG4gICAgICAgIG5vQnViYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgY2xpY2s6IHtcbiAgICAgICAgLy8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcbiAgICAgICAgc2V0dXA6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgLy8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG4gICAgICAgICAgLy8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cbiAgICAgICAgICB2YXIgZWwgPSB0aGlzIHx8IGRhdGE7IC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cbiAgICAgICAgICBpZiAocmNoZWNrYWJsZVR5cGUudGVzdChlbC50eXBlKSAmJiBlbC5jbGljayAmJiBub2RlTmFtZShlbCwgXCJpbnB1dFwiKSkge1xuICAgICAgICAgICAgLy8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuICAgICAgICAgICAgbGV2ZXJhZ2VOYXRpdmUoZWwsIFwiY2xpY2tcIiwgcmV0dXJuVHJ1ZSk7XG4gICAgICAgICAgfSAvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgLy8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG4gICAgICAgICAgLy8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cbiAgICAgICAgICB2YXIgZWwgPSB0aGlzIHx8IGRhdGE7IC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyaW5nIGEgY2xpY2tcblxuICAgICAgICAgIGlmIChyY2hlY2thYmxlVHlwZS50ZXN0KGVsLnR5cGUpICYmIGVsLmNsaWNrICYmIG5vZGVOYW1lKGVsLCBcImlucHV0XCIpKSB7XG4gICAgICAgICAgICBsZXZlcmFnZU5hdGl2ZShlbCwgXCJjbGlja1wiKTtcbiAgICAgICAgICB9IC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3NcbiAgICAgICAgLy8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG4gICAgICAgIF9kZWZhdWx0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIHJldHVybiByY2hlY2thYmxlVHlwZS50ZXN0KHRhcmdldC50eXBlKSAmJiB0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUodGFyZ2V0LCBcImlucHV0XCIpICYmIGRhdGFQcml2LmdldCh0YXJnZXQsIFwiY2xpY2tcIikgfHwgbm9kZU5hbWUodGFyZ2V0LCBcImFcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBiZWZvcmV1bmxvYWQ6IHtcbiAgICAgICAgcG9zdERpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuICAgICAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cbiAgICAgICAgICBpZiAoZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuICAvLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbiAgLy8gKm5hdGl2ZSogZXZlbnRzIHRoYXQgaXQgZmlyZXMgZGlyZWN0bHksIGVuc3VyaW5nIHRoYXQgc3RhdGUgY2hhbmdlcyBoYXZlXG4gIC8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cblxuICBmdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZShlbCwgdHlwZSwgZXhwZWN0U3luYykge1xuICAgIC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG4gICAgaWYgKCFleHBlY3RTeW5jKSB7XG4gICAgICBpZiAoZGF0YVByaXYuZ2V0KGVsLCB0eXBlKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGpRdWVyeS5ldmVudC5hZGQoZWwsIHR5cGUsIHJldHVyblRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cblxuICAgIGRhdGFQcml2LnNldChlbCwgdHlwZSwgZmFsc2UpO1xuICAgIGpRdWVyeS5ldmVudC5hZGQoZWwsIHR5cGUsIHtcbiAgICAgIG5hbWVzcGFjZTogZmFsc2UsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5vdEFzeW5jLFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgc2F2ZWQgPSBkYXRhUHJpdi5nZXQodGhpcywgdHlwZSk7XG5cbiAgICAgICAgaWYgKGV2ZW50LmlzVHJpZ2dlciAmIDEgJiYgdGhpc1t0eXBlXSkge1xuICAgICAgICAgIC8vIEludGVycnVwdCBwcm9jZXNzaW5nIG9mIHRoZSBvdXRlciBzeW50aGV0aWMgLnRyaWdnZXIoKWVkIGV2ZW50XG4gICAgICAgICAgLy8gU2F2ZWQgZGF0YSBzaG91bGQgYmUgZmFsc2UgaW4gc3VjaCBjYXNlcywgYnV0IG1pZ2h0IGJlIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3RcbiAgICAgICAgICAvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuICAgICAgICAgIGlmICghc2F2ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcbiAgICAgICAgICAgIC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBhcmd1bWVudCAoYW4gZXZlbnQgb2JqZWN0KSwgc28gdGhpcyBhcnJheVxuICAgICAgICAgICAgLy8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuICAgICAgICAgICAgc2F2ZWQgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBkYXRhUHJpdi5zZXQodGhpcywgdHlwZSwgc2F2ZWQpOyAvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4gICAgICAgICAgICAvLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91c1xuXG4gICAgICAgICAgICBub3RBc3luYyA9IGV4cGVjdFN5bmModGhpcywgdHlwZSk7XG4gICAgICAgICAgICB0aGlzW3R5cGVdKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBkYXRhUHJpdi5nZXQodGhpcywgdHlwZSk7XG5cbiAgICAgICAgICAgIGlmIChzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jKSB7XG4gICAgICAgICAgICAgIGRhdGFQcml2LnNldCh0aGlzLCB0eXBlLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNhdmVkICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgLy8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcbiAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICB9IC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG4gICAgICAgICAgICAvLyAoZm9jdXMgb3IgYmx1ciksIGFzc3VtZSB0aGF0IHRoZSBzdXJyb2dhdGUgYWxyZWFkeSBwcm9wYWdhdGVkIGZyb20gdHJpZ2dlcmluZyB0aGVcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG4gICAgICAgICAgICAvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuICAgICAgICAgICAgLy8gYnViYmxpbmcgc3Vycm9nYXRlIHByb3BhZ2F0ZXMgKmFmdGVyKiB0aGUgbm9uLWJ1YmJsaW5nIGJhc2UpLCBidXQgdGhhdCBzZWVtc1xuICAgICAgICAgICAgLy8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblxuICAgICAgICAgIH0gZWxzZSBpZiAoKGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9KS5kZWxlZ2F0ZVR5cGUpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG4gICAgICAgICAgLy8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cbiAgICAgICAgfSBlbHNlIGlmIChzYXZlZC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XG4gICAgICAgICAgZGF0YVByaXYuc2V0KHRoaXMsIHR5cGUsIHtcbiAgICAgICAgICAgIHZhbHVlOiBqUXVlcnkuZXZlbnQudHJpZ2dlciggLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4gICAgICAgICAgICAvLyBFeHRlbmQgd2l0aCB0aGUgcHJvdG90eXBlIHRvIHJlc2V0IHRoZSBhYm92ZSBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZChzYXZlZFswXSwgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSksIHNhdmVkLnNsaWNlKDEpLCB0aGlzKVxuICAgICAgICAgIH0pOyAvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50XG5cbiAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgalF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGhhbmRsZSkge1xuICAgIC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGUpO1xuICAgIH1cbiAgfTtcblxuICBqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiAoc3JjLCBwcm9wcykge1xuICAgIC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpKSB7XG4gICAgICByZXR1cm4gbmV3IGpRdWVyeS5FdmVudChzcmMsIHByb3BzKTtcbiAgICB9IC8vIEV2ZW50IG9iamVjdFxuXG5cbiAgICBpZiAoc3JjICYmIHNyYy50eXBlKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG4gICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTsgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8IHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiYgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG4gICAgICBzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID8gcmV0dXJuVHJ1ZSA6IHJldHVybkZhbHNlOyAvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcbiAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcbiAgICAgIC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cbiAgICAgIHRoaXMudGFyZ2V0ID0gc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gc3JjLnRhcmdldC5wYXJlbnROb2RlIDogc3JjLnRhcmdldDtcbiAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7IC8vIEV2ZW50IHR5cGVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgIH0gLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcblxuXG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBqUXVlcnkuZXh0ZW5kKHRoaXMsIHByb3BzKTtcbiAgICB9IC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cblxuICAgIHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTsgLy8gTWFyayBpdCBhcyBmaXhlZFxuXG4gICAgdGhpc1tqUXVlcnkuZXhwYW5kb10gPSB0cnVlO1xuICB9OyAvLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuXG5cbiAgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuICAgIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICBpc1NpbXVsYXRlZDogZmFsc2UsXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICBpZiAoZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICAgIGlmIChlICYmICF0aGlzLmlzU2ltdWxhdGVkKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICAgIGlmIChlICYmICF0aGlzLmlzU2ltdWxhdGVkKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9OyAvLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xuXG4gIGpRdWVyeS5lYWNoKHtcbiAgICBhbHRLZXk6IHRydWUsXG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuICAgIGN0cmxLZXk6IHRydWUsXG4gICAgZGV0YWlsOiB0cnVlLFxuICAgIGV2ZW50UGhhc2U6IHRydWUsXG4gICAgbWV0YUtleTogdHJ1ZSxcbiAgICBwYWdlWDogdHJ1ZSxcbiAgICBwYWdlWTogdHJ1ZSxcbiAgICBzaGlmdEtleTogdHJ1ZSxcbiAgICB2aWV3OiB0cnVlLFxuICAgIFwiY2hhclwiOiB0cnVlLFxuICAgIGNvZGU6IHRydWUsXG4gICAgY2hhckNvZGU6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIGtleUNvZGU6IHRydWUsXG4gICAgYnV0dG9uOiB0cnVlLFxuICAgIGJ1dHRvbnM6IHRydWUsXG4gICAgY2xpZW50WDogdHJ1ZSxcbiAgICBjbGllbnRZOiB0cnVlLFxuICAgIG9mZnNldFg6IHRydWUsXG4gICAgb2Zmc2V0WTogdHJ1ZSxcbiAgICBwb2ludGVySWQ6IHRydWUsXG4gICAgcG9pbnRlclR5cGU6IHRydWUsXG4gICAgc2NyZWVuWDogdHJ1ZSxcbiAgICBzY3JlZW5ZOiB0cnVlLFxuICAgIHRhcmdldFRvdWNoZXM6IHRydWUsXG4gICAgdG9FbGVtZW50OiB0cnVlLFxuICAgIHRvdWNoZXM6IHRydWUsXG4gICAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjsgLy8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cbiAgICAgIGlmIChldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KGV2ZW50LnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuICAgICAgfSAvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cblxuICAgICAgaWYgKCFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KGV2ZW50LnR5cGUpKSB7XG4gICAgICAgIGlmIChidXR0b24gJiAxKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnV0dG9uICYgMikge1xuICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1dHRvbiAmIDQpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnQud2hpY2g7XG4gICAgfVxuICB9LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCk7XG4gIGpRdWVyeS5lYWNoKHtcbiAgICBmb2N1czogXCJmb2N1c2luXCIsXG4gICAgYmx1cjogXCJmb2N1c291dFwiXG4gIH0sIGZ1bmN0aW9uICh0eXBlLCBkZWxlZ2F0ZVR5cGUpIHtcbiAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSA9IHtcbiAgICAgIC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuICAgICAgc2V0dXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcbiAgICAgICAgLy8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG4gICAgICAgIC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG4gICAgICAgIGxldmVyYWdlTmF0aXZlKHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMpOyAvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG4gICAgICAgIGxldmVyYWdlTmF0aXZlKHRoaXMsIHR5cGUpOyAvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcbiAgICB9O1xuICB9KTsgLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4gIC8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4gIC8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4gIC8vXG4gIC8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbiAgLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuICAvLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxuXG4gIGpRdWVyeS5lYWNoKHtcbiAgICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcbiAgICBwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcbiAgICBwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG4gIH0sIGZ1bmN0aW9uIChvcmlnLCBmaXgpIHtcbiAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtvcmlnXSA9IHtcbiAgICAgIGRlbGVnYXRlVHlwZTogZml4LFxuICAgICAgYmluZFR5cGU6IGZpeCxcbiAgICAgIGhhbmRsZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciByZXQsXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLFxuICAgICAgICAgICAgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG4gICAgICAgICAgICBoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7IC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG4gICAgICAgIC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cbiAgICAgICAgaWYgKCFyZWxhdGVkIHx8IHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKHRhcmdldCwgcmVsYXRlZCkpIHtcbiAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuICAgICAgICAgIHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZXZlbnQudHlwZSA9IGZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIG9uOiBmdW5jdGlvbiAodHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbikge1xuICAgICAgcmV0dXJuIG9uKHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pO1xuICAgIH0sXG4gICAgb25lOiBmdW5jdGlvbiAodHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbikge1xuICAgICAgcmV0dXJuIG9uKHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEpO1xuICAgIH0sXG4gICAgb2ZmOiBmdW5jdGlvbiAodHlwZXMsIHNlbGVjdG9yLCBmbikge1xuICAgICAgdmFyIGhhbmRsZU9iaiwgdHlwZTtcblxuICAgICAgaWYgKHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaikge1xuICAgICAgICAvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG4gICAgICAgIGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcbiAgICAgICAgalF1ZXJ5KHR5cGVzLmRlbGVnYXRlVGFyZ2V0KS5vZmYoaGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSwgaGFuZGxlT2JqLnNlbGVjdG9yLCBoYW5kbGVPYmouaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG4gICAgICAgIGZvciAodHlwZSBpbiB0eXBlcykge1xuICAgICAgICAgIHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCB0eXBlc1t0eXBlXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyAoIHR5cGVzIFssIGZuXSApXG4gICAgICAgIGZuID0gc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm4gPT09IGZhbHNlKSB7XG4gICAgICAgIGZuID0gcmV0dXJuRmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcbiAgLy8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cbiAgLy8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cbiAgcm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG4gICAgICAvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcbiAgcmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuICAgICAgcmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nOyAvLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcblxuICBmdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoZWxlbSwgY29udGVudCkge1xuICAgIGlmIChub2RlTmFtZShlbGVtLCBcInRhYmxlXCIpICYmIG5vZGVOYW1lKGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiKSkge1xuICAgICAgcmV0dXJuIGpRdWVyeShlbGVtKS5jaGlsZHJlbihcInRib2R5XCIpWzBdIHx8IGVsZW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW07XG4gIH0gLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuXG5cbiAgZnVuY3Rpb24gZGlzYWJsZVNjcmlwdChlbGVtKSB7XG4gICAgZWxlbS50eXBlID0gKGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSAhPT0gbnVsbCkgKyBcIi9cIiArIGVsZW0udHlwZTtcbiAgICByZXR1cm4gZWxlbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoZWxlbSkge1xuICAgIGlmICgoZWxlbS50eXBlIHx8IFwiXCIpLnNsaWNlKDAsIDUpID09PSBcInRydWUvXCIpIHtcbiAgICAgIGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSg1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoc3JjLCBkZXN0KSB7XG4gICAgdmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuICAgIGlmIChkZXN0Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXG5cbiAgICBpZiAoZGF0YVByaXYuaGFzRGF0YShzcmMpKSB7XG4gICAgICBwZGF0YU9sZCA9IGRhdGFQcml2LmdldChzcmMpO1xuICAgICAgZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG4gICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgIGRhdGFQcml2LnJlbW92ZShkZXN0LCBcImhhbmRsZSBldmVudHNcIik7XG5cbiAgICAgICAgZm9yICh0eXBlIGluIGV2ZW50cykge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBldmVudHNbdHlwZV0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKGRlc3QsIHR5cGUsIGV2ZW50c1t0eXBlXVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXG5cbiAgICBpZiAoZGF0YVVzZXIuaGFzRGF0YShzcmMpKSB7XG4gICAgICB1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2VzcyhzcmMpO1xuICAgICAgdWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKHt9LCB1ZGF0YU9sZCk7XG4gICAgICBkYXRhVXNlci5zZXQoZGVzdCwgdWRhdGFDdXIpO1xuICAgIH1cbiAgfSAvLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcblxuXG4gIGZ1bmN0aW9uIGZpeElucHV0KHNyYywgZGVzdCkge1xuICAgIHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsgLy8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cbiAgICBpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KHNyYy50eXBlKSkge1xuICAgICAgZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7IC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG4gICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgICAgIGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb21NYW5pcChjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCkge1xuICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcbiAgICBhcmdzID0gZmxhdChhcmdzKTtcbiAgICB2YXIgZnJhZ21lbnQsXG4gICAgICAgIGZpcnN0LFxuICAgICAgICBzY3JpcHRzLFxuICAgICAgICBoYXNTY3JpcHRzLFxuICAgICAgICBub2RlLFxuICAgICAgICBkb2MsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBsID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGlOb0Nsb25lID0gbCAtIDEsXG4gICAgICAgIHZhbHVlID0gYXJnc1swXSxcbiAgICAgICAgdmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbih2YWx1ZSk7IC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXG4gICAgaWYgKHZhbHVlSXNGdW5jdGlvbiB8fCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKGluZGV4KTtcblxuICAgICAgICBpZiAodmFsdWVJc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgYXJnc1swXSA9IHZhbHVlLmNhbGwodGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbU1hbmlwKHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsKSB7XG4gICAgICBmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoYXJncywgY29sbGVjdGlvblswXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCk7XG4gICAgICBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICAgIGlmIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBmcmFnbWVudCA9IGZpcnN0O1xuICAgICAgfSAvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblxuXG4gICAgICBpZiAoZmlyc3QgfHwgaWdub3JlZCkge1xuICAgICAgICBzY3JpcHRzID0galF1ZXJ5Lm1hcChnZXRBbGwoZnJhZ21lbnQsIFwic2NyaXB0XCIpLCBkaXNhYmxlU2NyaXB0KTtcbiAgICAgICAgaGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoOyAvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG4gICAgICAgIC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuICAgICAgICAvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXG4gICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IGZyYWdtZW50O1xuXG4gICAgICAgICAgaWYgKGkgIT09IGlOb0Nsb25lKSB7XG4gICAgICAgICAgICBub2RlID0galF1ZXJ5LmNsb25lKG5vZGUsIHRydWUsIHRydWUpOyAvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cbiAgICAgICAgICAgIGlmIChoYXNTY3JpcHRzKSB7XG4gICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShzY3JpcHRzLCBnZXRBbGwobm9kZSwgXCJzY3JpcHRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29sbGVjdGlvbltpXSwgbm9kZSwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xuICAgICAgICAgIGRvYyA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5vd25lckRvY3VtZW50OyAvLyBSZWVuYWJsZSBzY3JpcHRzXG5cbiAgICAgICAgICBqUXVlcnkubWFwKHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQpOyAvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0gc2NyaXB0c1tpXTtcblxuICAgICAgICAgICAgaWYgKHJzY3JpcHRUeXBlLnRlc3Qobm9kZS50eXBlIHx8IFwiXCIpICYmICFkYXRhUHJpdi5hY2Nlc3Mobm9kZSwgXCJnbG9iYWxFdmFsXCIpICYmIGpRdWVyeS5jb250YWlucyhkb2MsIG5vZGUpKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLnNyYyAmJiAobm9kZS50eXBlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgIT09IFwibW9kdWxlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZXZhbFVybChub2RlLnNyYywge1xuICAgICAgICAgICAgICAgICAgICBub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpXG4gICAgICAgICAgICAgICAgICB9LCBkb2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBET01FdmFsKG5vZGUudGV4dENvbnRlbnQucmVwbGFjZShyY2xlYW5TY3JpcHQsIFwiXCIpLCBub2RlLCBkb2MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUoZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhKSB7XG4gICAgdmFyIG5vZGUsXG4gICAgICAgIG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKHNlbGVjdG9yLCBlbGVtKSA6IGVsZW0sXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZm9yICg7IChub2RlID0gbm9kZXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgaWYgKCFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKG5vZGUpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoa2VlcERhdGEgJiYgaXNBdHRhY2hlZChub2RlKSkge1xuICAgICAgICAgIHNldEdsb2JhbEV2YWwoZ2V0QWxsKG5vZGUsIFwic2NyaXB0XCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbTtcbiAgfVxuXG4gIGpRdWVyeS5leHRlbmQoe1xuICAgIGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICByZXR1cm4gaHRtbDtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAoZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgc3JjRWxlbWVudHMsXG4gICAgICAgICAgZGVzdEVsZW1lbnRzLFxuICAgICAgICAgIGNsb25lID0gZWxlbS5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgaW5QYWdlID0gaXNBdHRhY2hlZChlbGVtKTsgLy8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cbiAgICAgIGlmICghc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSkgJiYgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSkge1xuICAgICAgICAvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcbiAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lKTtcbiAgICAgICAgc3JjRWxlbWVudHMgPSBnZXRBbGwoZWxlbSk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGZpeElucHV0KHNyY0VsZW1lbnRzW2ldLCBkZXN0RWxlbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblxuXG4gICAgICBpZiAoZGF0YUFuZEV2ZW50cykge1xuICAgICAgICBpZiAoZGVlcERhdGFBbmRFdmVudHMpIHtcbiAgICAgICAgICBzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbChlbGVtKTtcbiAgICAgICAgICBkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKGNsb25lKTtcblxuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNsb25lQ29weUV2ZW50KHNyY0VsZW1lbnRzW2ldLCBkZXN0RWxlbWVudHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZUNvcHlFdmVudChlbGVtLCBjbG9uZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXG5cbiAgICAgIGRlc3RFbGVtZW50cyA9IGdldEFsbChjbG9uZSwgXCJzY3JpcHRcIik7XG5cbiAgICAgIGlmIChkZXN0RWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZXRHbG9iYWxFdmFsKGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoZWxlbSwgXCJzY3JpcHRcIikpO1xuICAgICAgfSAvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblxuXG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSxcbiAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uIChlbGVtcykge1xuICAgICAgdmFyIGRhdGEsXG4gICAgICAgICAgZWxlbSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IChlbGVtID0gZWxlbXNbaV0pICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICBpZiAoYWNjZXB0RGF0YShlbGVtKSkge1xuICAgICAgICAgIGlmIChkYXRhID0gZWxlbVtkYXRhUHJpdi5leHBhbmRvXSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuZXZlbnRzKSB7XG4gICAgICAgICAgICAgIGZvciAodHlwZSBpbiBkYXRhLmV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKGVsZW0sIHR5cGUpOyAvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG4gICAgICAgICAgICAvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblxuXG4gICAgICAgICAgICBlbGVtW2RhdGFQcml2LmV4cGFuZG9dID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtW2RhdGFVc2VyLmV4cGFuZG9dKSB7XG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuICAgICAgICAgICAgLy8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG4gICAgICAgICAgICBlbGVtW2RhdGFVc2VyLmV4cGFuZG9dID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIGRldGFjaDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlKHRoaXMsIHNlbGVjdG9yLCB0cnVlKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlKHRoaXMsIHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIHRleHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBqUXVlcnkudGV4dCh0aGlzKSA6IHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB9LFxuICAgIGFwcGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQodGhpcywgZWxlbSk7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByZXBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KHRoaXMsIGVsZW0pO1xuICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJlZm9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW0sIHRoaXMubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWxlbSxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrKSB7XG4gICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgLy8gUHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChlbGVtLCBmYWxzZSkpOyAvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXG4gICAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzKSB7XG4gICAgICBkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuICAgICAgZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5jbG9uZSh0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGh0bWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdIHx8IHt9LFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBlbGVtLmlubmVySFRNTDtcbiAgICAgICAgfSAvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCh2YWx1ZSkgJiYgIXdyYXBNYXBbKHJ0YWdOYW1lLmV4ZWModmFsdWUpIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKHZhbHVlKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICBlbGVtID0gdGhpc1tpXSB8fCB7fTsgLy8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cbiAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChlbGVtLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbSA9IDA7IC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgIHRoaXMuZW1wdHkoKS5hcHBlbmQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgfSxcbiAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlnbm9yZWQgPSBbXTsgLy8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cbiAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYgKGpRdWVyeS5pbkFycmF5KHRoaXMsIGlnbm9yZWQpIDwgMCkge1xuICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKHRoaXMpKTtcblxuICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWxlbSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblxuICAgICAgfSwgaWdub3JlZCk7XG4gICAgfVxuICB9KTtcbiAgalF1ZXJ5LmVhY2goe1xuICAgIGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuICAgIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG4gICAgaW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuICAgIGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG4gICAgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG4gIH0sIGZ1bmN0aW9uIChuYW1lLCBvcmlnaW5hbCkge1xuICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZW1zLFxuICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgIGluc2VydCA9IGpRdWVyeShzZWxlY3RvciksXG4gICAgICAgICAgbGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8PSBsYXN0OyBpKyspIHtcbiAgICAgICAgZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUodHJ1ZSk7XG4gICAgICAgIGpRdWVyeShpbnNlcnRbaV0pW29yaWdpbmFsXShlbGVtcyk7IC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cbiAgICAgICAgcHVzaC5hcHBseShyZXQsIGVsZW1zLmdldCgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHJldCk7XG4gICAgfTtcbiAgfSk7XG4gIHZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIik7XG5cbiAgdmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuICAgIC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuICAgIC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuICAgIHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG4gICAgaWYgKCF2aWV3IHx8ICF2aWV3Lm9wZW5lcikge1xuICAgICAgdmlldyA9IHdpbmRvdztcbiAgICB9XG5cbiAgICByZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICB9O1xuXG4gIHZhciBzd2FwID0gZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJldCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb2xkID0ge307IC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXG4gICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgIG9sZFtuYW1lXSA9IGVsZW0uc3R5bGVbbmFtZV07XG4gICAgICBlbGVtLnN0eWxlW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICB9XG5cbiAgICByZXQgPSBjYWxsYmFjay5jYWxsKGVsZW0pOyAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblxuICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICBlbGVtLnN0eWxlW25hbWVdID0gb2xkW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoY3NzRXhwYW5kLmpvaW4oXCJ8XCIpLCBcImlcIik7XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcbiAgICAvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuICAgICAgaWYgKCFkaXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICsgXCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcbiAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgKyBcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgKyBcIndpZHRoOjYwJTt0b3A6MSVcIjtcbiAgICAgIGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChjb250YWluZXIpLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICB2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkaXYpO1xuICAgICAgcGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiOyAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cbiAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXZTdHlsZS5tYXJnaW5MZWZ0KSA9PT0gMTI7IC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuICAgICAgLy8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cbiAgICAgIGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG4gICAgICBwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXZTdHlsZS5yaWdodCkgPT09IDM2OyAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuICAgICAgLy8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXG4gICAgICBib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXZTdHlsZS53aWR0aCkgPT09IDM2OyAvLyBTdXBwb3J0OiBJRSA5IG9ubHlcbiAgICAgIC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG4gICAgICAvLyBEb24ndCBnZXQgdHJpY2tlZCB3aGVuIHpvb20gYWZmZWN0cyBvZmZzZXRXaWR0aCAoZ2gtNDAyOSlcblxuICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgc2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXYub2Zmc2V0V2lkdGggLyAzKSA9PT0gMTI7XG4gICAgICBkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTsgLy8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuICAgICAgLy8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXG4gICAgICBkaXYgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyhtZWFzdXJlKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChwYXJzZUZsb2F0KG1lYXN1cmUpKTtcbiAgICB9XG5cbiAgICB2YXIgcGl4ZWxQb3NpdGlvblZhbCxcbiAgICAgICAgYm94U2l6aW5nUmVsaWFibGVWYWwsXG4gICAgICAgIHNjcm9sbGJveFNpemVWYWwsXG4gICAgICAgIHBpeGVsQm94U3R5bGVzVmFsLFxuICAgICAgICByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCxcbiAgICAgICAgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpOyAvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXG4gICAgaWYgKCFkaXYuc3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcbiAgICAvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cblxuICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcbiAgICBkaXYuY2xvbmVOb2RlKHRydWUpLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcbiAgICBzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuICAgIGpRdWVyeS5leHRlbmQoc3VwcG9ydCwge1xuICAgICAgYm94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgcmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuICAgICAgfSxcbiAgICAgIHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgIHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcbiAgICAgIH0sXG4gICAgICBwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgIHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuICAgICAgfSxcbiAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICByZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuICAgICAgfSxcbiAgICAgIHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG4gICAgICB9LFxuICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxNSAtIDE4K1xuICAgICAgLy8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcbiAgICAgIC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuICAgICAgLy8gQmVoYXZpb3IgaW4gSUUgOSBpcyBtb3JlIHN1YnRsZSB0aGFuIGluIG5ld2VyIHZlcnNpb25zICYgaXQgcGFzc2VzXG4gICAgICAvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG4gICAgICByZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xuXG4gICAgICAgIGlmIChyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGFibGVcIik7XG4gICAgICAgICAgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidHJcIik7XG4gICAgICAgICAgdHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgdGFibGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweFwiO1xuICAgICAgICAgIHRyLnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG4gICAgICAgICAgdHJDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjlweFwiO1xuICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0YWJsZSkuYXBwZW5kQ2hpbGQodHIpLmFwcGVuZENoaWxkKHRyQ2hpbGQpO1xuICAgICAgICAgIHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0cik7XG4gICAgICAgICAgcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSBwYXJzZUludCh0clN0eWxlLmhlaWdodCkgPiAzO1xuICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0YWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVsaWFibGVUckRpbWVuc2lvbnNWYWw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gY3VyQ1NTKGVsZW0sIG5hbWUsIGNvbXB1dGVkKSB7XG4gICAgdmFyIHdpZHRoLFxuICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgIHJldCxcbiAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA1MStcbiAgICAvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG4gICAgLy8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuICAgIC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG4gICAgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICAgIGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKGVsZW0pOyAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG4gICAgLy8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG4gICAgLy8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUobmFtZSkgfHwgY29tcHV0ZWRbbmFtZV07XG5cbiAgICAgIGlmIChyZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoZWxlbSkpIHtcbiAgICAgICAgcmV0ID0galF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUpO1xuICAgICAgfSAvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG4gICAgICAvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcbiAgICAgIC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG4gICAgICAvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG4gICAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXG5cbiAgICAgIGlmICghc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KHJldCkgJiYgcmJveFN0eWxlLnRlc3QobmFtZSkpIHtcbiAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICB3aWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuICAgICAgICBtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoOyAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cbiAgICAgICAgc3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuICAgICAgICByZXQgPSBjb21wdXRlZC53aWR0aDsgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXG4gICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG4gICAgICAgIHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID8gLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgIC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG4gICAgcmV0ICsgXCJcIiA6IHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEdldEhvb2tJZihjb25kaXRpb25GbiwgaG9va0ZuKSB7XG4gICAgLy8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjb25kaXRpb25GbigpKSB7XG4gICAgICAgICAgLy8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG4gICAgICAgICAgLy8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuICAgICAgICAgIGRlbGV0ZSB0aGlzLmdldDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cblxuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0ID0gaG9va0ZuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgY3NzUHJlZml4ZXMgPSBbXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiXSxcbiAgICAgIGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFxuICAgICAgdmVuZG9yUHJvcHMgPSB7fTsgLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuXG4gIGZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKG5hbWUpIHtcbiAgICAvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG4gICAgdmFyIGNhcE5hbWUgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuICAgICAgICBpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgbmFtZSA9IGNzc1ByZWZpeGVzW2ldICsgY2FwTmFtZTtcblxuICAgICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcblxuXG4gIGZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUobmFtZSkge1xuICAgIHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1tuYW1lXSB8fCB2ZW5kb3JQcm9wc1tuYW1lXTtcblxuICAgIGlmIChmaW5hbCkge1xuICAgICAgcmV0dXJuIGZpbmFsO1xuICAgIH1cblxuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiB2ZW5kb3JQcm9wc1tuYW1lXSA9IHZlbmRvclByb3BOYW1lKG5hbWUpIHx8IG5hbWU7XG4gIH1cblxuICB2YXIgLy8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuICAvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcbiAgLy8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG4gIHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcbiAgICAgIHJjdXN0b21Qcm9wID0gL14tLS8sXG4gICAgICBjc3NTaG93ID0ge1xuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcbiAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgfSxcbiAgICAgIGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcbiAgICBsZXR0ZXJTcGFjaW5nOiBcIjBcIixcbiAgICBmb250V2VpZ2h0OiBcIjQwMFwiXG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCkge1xuICAgIC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgICAvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcbiAgICB2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyh2YWx1ZSk7XG4gICAgcmV0dXJuIG1hdGNoZXMgPyAvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuICAgIE1hdGgubWF4KDAsIG1hdGNoZXNbMl0gLSAoc3VidHJhY3QgfHwgMCkpICsgKG1hdGNoZXNbM10gfHwgXCJweFwiKSA6IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCkge1xuICAgIHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcbiAgICAgICAgZXh0cmEgPSAwLFxuICAgICAgICBkZWx0YSA9IDA7IC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3NhcnlcblxuICAgIGlmIChib3ggPT09IChpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZvciAoOyBpIDwgNDsgaSArPSAyKSB7XG4gICAgICAvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cbiAgICAgIGlmIChib3ggPT09IFwibWFyZ2luXCIpIHtcbiAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyhlbGVtLCBib3ggKyBjc3NFeHBhbmRbaV0sIHRydWUsIHN0eWxlcyk7XG4gICAgICB9IC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblxuXG4gICAgICBpZiAoIWlzQm9yZGVyQm94KSB7XG4gICAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICAgIGRlbHRhICs9IGpRdWVyeS5jc3MoZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbaV0sIHRydWUsIHN0eWxlcyk7IC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblxuICAgICAgICBpZiAoYm94ICE9PSBcInBhZGRpbmdcIikge1xuICAgICAgICAgIGRlbHRhICs9IGpRdWVyeS5jc3MoZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFtpXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzKTsgLy8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0cmEgKz0galF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICB9IC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3JcbiAgICAgICAgLy8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcbiAgICAgICAgaWYgKGJveCA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgICAgICBkZWx0YSAtPSBqUXVlcnkuY3NzKGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICB9IC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cblxuICAgICAgICBpZiAoYm94ICE9PSBcIm1hcmdpblwiKSB7XG4gICAgICAgICAgZGVsdGEgLT0galF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXG5cbiAgICBpZiAoIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDApIHtcbiAgICAgIC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcbiAgICAgIC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cbiAgICAgIGRlbHRhICs9IE1hdGgubWF4KDAsIE1hdGguY2VpbChlbGVtW1wib2Zmc2V0XCIgKyBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKV0gLSBjb21wdXRlZFZhbCAtIGRlbHRhIC0gZXh0cmEgLSAwLjUgLy8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcbiAgICAgIC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcbiAgICAgICkpIHx8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbHRhO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodChlbGVtLCBkaW1lbnNpb24sIGV4dHJhKSB7XG4gICAgLy8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoZWxlbSksXG4gICAgICAgIC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuICAgIC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuICAgIGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG4gICAgICAgIGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmIGpRdWVyeS5jc3MoZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcykgPT09IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICB2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG4gICAgICAgIHZhbCA9IGN1ckNTUyhlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyksXG4gICAgICAgIG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSk7IC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuICAgIC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXG4gICAgaWYgKHJudW1ub25weC50ZXN0KHZhbCkpIHtcbiAgICAgIGlmICghZXh0cmEpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cblxuICAgICAgdmFsID0gXCJhdXRvXCI7XG4gICAgfSAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuICAgIC8vIFVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlLlxuICAgIC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cblxuXG4gICAgaWYgKCghc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8IC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG4gICAgLy8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcbiAgICAvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cbiAgICAvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuICAgICFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoZWxlbSwgXCJ0clwiKSB8fCAvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcbiAgICAvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG4gICAgdmFsID09PSBcImF1dG9cIiB8fCAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcbiAgICAvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuICAgICFwYXJzZUZsb2F0KHZhbCkgJiYgalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcykgPT09IFwiaW5saW5lXCIpICYmIC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXG4gICAgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkge1xuICAgICAgaXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImJvcmRlci1ib3hcIjsgLy8gV2hlcmUgYXZhaWxhYmxlLCBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgYXBwcm94aW1hdGUgYm9yZGVyIGJveCBkaW1lbnNpb25zLlxuICAgICAgLy8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuICAgICAgLy8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXG4gICAgICB2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXG4gICAgICBpZiAodmFsdWVJc0JvcmRlckJveCkge1xuICAgICAgICB2YWwgPSBlbGVtW29mZnNldFByb3BdO1xuICAgICAgfVxuICAgIH0gLy8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblxuXG4gICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpIHx8IDA7IC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblxuICAgIHJldHVybiB2YWwgKyBib3hNb2RlbEFkanVzdG1lbnQoZWxlbSwgZGltZW5zaW9uLCBleHRyYSB8fCAoaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpLCB2YWx1ZUlzQm9yZGVyQm94LCBzdHlsZXMsIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG4gICAgdmFsKSArIFwicHhcIjtcbiAgfVxuXG4gIGpRdWVyeS5leHRlbmQoe1xuICAgIC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuICAgIC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuICAgIGNzc0hvb2tzOiB7XG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkKSB7XG4gICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuICAgICAgICAgICAgdmFyIHJldCA9IGN1ckNTUyhlbGVtLCBcIm9wYWNpdHlcIik7XG4gICAgICAgICAgICByZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuICAgIGNzc051bWJlcjoge1xuICAgICAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuICAgICAgXCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuICAgICAgXCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuICAgICAgXCJmbGV4R3Jvd1wiOiB0cnVlLFxuICAgICAgXCJmbGV4U2hyaW5rXCI6IHRydWUsXG4gICAgICBcImZvbnRXZWlnaHRcIjogdHJ1ZSxcbiAgICAgIFwiZ3JpZEFyZWFcIjogdHJ1ZSxcbiAgICAgIFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuICAgICAgXCJncmlkQ29sdW1uRW5kXCI6IHRydWUsXG4gICAgICBcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuICAgICAgXCJncmlkUm93XCI6IHRydWUsXG4gICAgICBcImdyaWRSb3dFbmRcIjogdHJ1ZSxcbiAgICAgIFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG4gICAgICBcImxpbmVIZWlnaHRcIjogdHJ1ZSxcbiAgICAgIFwib3BhY2l0eVwiOiB0cnVlLFxuICAgICAgXCJvcmRlclwiOiB0cnVlLFxuICAgICAgXCJvcnBoYW5zXCI6IHRydWUsXG4gICAgICBcIndpZG93c1wiOiB0cnVlLFxuICAgICAgXCJ6SW5kZXhcIjogdHJ1ZSxcbiAgICAgIFwiem9vbVwiOiB0cnVlXG4gICAgfSxcbiAgICAvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG4gICAgLy8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuICAgIGNzc1Byb3BzOiB7fSxcbiAgICAvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuICAgIHN0eWxlOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhKSB7XG4gICAgICAvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcbiAgICAgIGlmICghZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblxuXG4gICAgICB2YXIgcmV0LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaG9va3MsXG4gICAgICAgICAgb3JpZ05hbWUgPSBjYW1lbENhc2UobmFtZSksXG4gICAgICAgICAgaXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdChuYW1lKSxcbiAgICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGU7IC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3RcbiAgICAgIC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuICAgICAgLy8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcCkge1xuICAgICAgICBuYW1lID0gZmluYWxQcm9wTmFtZShvcmlnTmFtZSk7XG4gICAgICB9IC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cblxuICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbbmFtZV0gfHwgalF1ZXJ5LmNzc0hvb2tzW29yaWdOYW1lXTsgLy8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7IC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAocmV0ID0gcmNzc051bS5leGVjKHZhbHVlKSkgJiYgcmV0WzFdKSB7XG4gICAgICAgICAgdmFsdWUgPSBhZGp1c3RDU1MoZWxlbSwgbmFtZSwgcmV0KTsgLy8gRml4ZXMgYnVnICM5MjM3XG5cbiAgICAgICAgICB0eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgfSAvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXG5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuICAgICAgICAvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG4gICAgICAgIC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCkge1xuICAgICAgICAgIHZhbHVlICs9IHJldCAmJiByZXRbM10gfHwgKGpRdWVyeS5jc3NOdW1iZXJbb3JpZ05hbWVdID8gXCJcIiA6IFwicHhcIik7XG4gICAgICAgIH0gLy8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXG5cbiAgICAgICAgaWYgKCFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoXCJiYWNrZ3JvdW5kXCIpID09PSAwKSB7XG4gICAgICAgICAgc3R5bGVbbmFtZV0gPSBcImluaGVyaXRcIjtcbiAgICAgICAgfSAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblxuXG4gICAgICAgIGlmICghaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUsIGV4dHJhKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChpc0N1c3RvbVByb3ApIHtcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuICAgICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIGZhbHNlLCBleHRyYSkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9IC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cblxuICAgICAgICByZXR1cm4gc3R5bGVbbmFtZV07XG4gICAgICB9XG4gICAgfSxcbiAgICBjc3M6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzKSB7XG4gICAgICB2YXIgdmFsLFxuICAgICAgICAgIG51bSxcbiAgICAgICAgICBob29rcyxcbiAgICAgICAgICBvcmlnTmFtZSA9IGNhbWVsQ2FzZShuYW1lKSxcbiAgICAgICAgICBpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KG5hbWUpOyAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG4gICAgICAvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cbiAgICAgIGlmICghaXNDdXN0b21Qcm9wKSB7XG4gICAgICAgIG5hbWUgPSBmaW5hbFByb3BOYW1lKG9yaWdOYW1lKTtcbiAgICAgIH0gLy8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXG5cbiAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdIHx8IGpRdWVyeS5jc3NIb29rc1tvcmlnTmFtZV07IC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cbiAgICAgIGlmIChob29rcyAmJiBcImdldFwiIGluIGhvb2tzKSB7XG4gICAgICAgIHZhbCA9IGhvb2tzLmdldChlbGVtLCB0cnVlLCBleHRyYSk7XG4gICAgICB9IC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cblxuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xuICAgICAgfSAvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblxuXG4gICAgICBpZiAodmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtKSB7XG4gICAgICAgIHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVtuYW1lXTtcbiAgICAgIH0gLy8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cblxuICAgICAgaWYgKGV4dHJhID09PSBcIlwiIHx8IGV4dHJhKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgcmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKG51bSkgPyBudW0gfHwgMCA6IHZhbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0pO1xuICBqUXVlcnkuZWFjaChbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiXSwgZnVuY3Rpb24gKF9pLCBkaW1lbnNpb24pIHtcbiAgICBqUXVlcnkuY3NzSG9va3NbZGltZW5zaW9uXSA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkLCBleHRyYSkge1xuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cbiAgICAgICAgICAvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuICAgICAgICAgIHJldHVybiByZGlzcGxheXN3YXAudGVzdChqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiKSkgJiYgKCAvLyBTdXBwb3J0OiBTYWZhcmkgOCtcbiAgICAgICAgICAvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuICAgICAgICAgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG4gICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAgICAgLy8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuICAgICAgICAgIC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkgPyBzd2FwKGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEpO1xuICAgICAgICAgIH0pIDogZ2V0V2lkdGhPckhlaWdodChlbGVtLCBkaW1lbnNpb24sIGV4dHJhKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0sIHZhbHVlLCBleHRyYSkge1xuICAgICAgICB2YXIgbWF0Y2hlcyxcbiAgICAgICAgICAgIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKSxcbiAgICAgICAgICAgIC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcbiAgICAgICAgLy8gdG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdy5cbiAgICAgICAgc2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmIHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgLy8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtMzk5MSlcbiAgICAgICAgYm94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuICAgICAgICAgICAgaXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiYgalF1ZXJ5LmNzcyhlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCIsXG4gICAgICAgICAgICBzdWJ0cmFjdCA9IGV4dHJhID8gYm94TW9kZWxBZGp1c3RtZW50KGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMpIDogMDsgLy8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG4gICAgICAgIC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cbiAgICAgICAgaWYgKGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSkge1xuICAgICAgICAgIHN1YnRyYWN0IC09IE1hdGguY2VpbChlbGVtW1wib2Zmc2V0XCIgKyBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKV0gLSBwYXJzZUZsb2F0KHN0eWxlc1tkaW1lbnNpb25dKSAtIGJveE1vZGVsQWRqdXN0bWVudChlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMpIC0gMC41KTtcbiAgICAgICAgfSAvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXG5cbiAgICAgICAgaWYgKHN1YnRyYWN0ICYmIChtYXRjaGVzID0gcmNzc051bS5leGVjKHZhbHVlKSkgJiYgKG1hdGNoZXNbM10gfHwgXCJweFwiKSAhPT0gXCJweFwiKSB7XG4gICAgICAgICAgZWxlbS5zdHlsZVtkaW1lbnNpb25dID0gdmFsdWU7XG4gICAgICAgICAgdmFsdWUgPSBqUXVlcnkuY3NzKGVsZW0sIGRpbWVuc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoZWxlbSwgdmFsdWUsIHN1YnRyYWN0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgalF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsIGZ1bmN0aW9uIChlbGVtLCBjb21wdXRlZCkge1xuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgcmV0dXJuIChwYXJzZUZsb2F0KGN1ckNTUyhlbGVtLCBcIm1hcmdpbkxlZnRcIikpIHx8IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIHN3YXAoZWxlbSwge1xuICAgICAgICBtYXJnaW5MZWZ0OiAwXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICB9KSkgKyBcInB4XCI7XG4gICAgfVxuICB9KTsgLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xuXG4gIGpRdWVyeS5lYWNoKHtcbiAgICBtYXJnaW46IFwiXCIsXG4gICAgcGFkZGluZzogXCJcIixcbiAgICBib3JkZXI6IFwiV2lkdGhcIlxuICB9LCBmdW5jdGlvbiAocHJlZml4LCBzdWZmaXgpIHtcbiAgICBqUXVlcnkuY3NzSG9va3NbcHJlZml4ICsgc3VmZml4XSA9IHtcbiAgICAgIGV4cGFuZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGV4cGFuZGVkID0ge30sXG4gICAgICAgICAgICAvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcbiAgICAgICAgcGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdChcIiBcIikgOiBbdmFsdWVdO1xuXG4gICAgICAgIGZvciAoOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgZXhwYW5kZWRbcHJlZml4ICsgY3NzRXhwYW5kW2ldICsgc3VmZml4XSA9IHBhcnRzW2ldIHx8IHBhcnRzW2kgLSAyXSB8fCBwYXJ0c1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHByZWZpeCAhPT0gXCJtYXJnaW5cIikge1xuICAgICAgalF1ZXJ5LmNzc0hvb2tzW3ByZWZpeCArIHN1ZmZpeF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG4gICAgfVxuICB9KTtcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgY3NzOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdHlsZXMsXG4gICAgICAgICAgICBsZW4sXG4gICAgICAgICAgICBtYXAgPSB7fSxcbiAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pO1xuICAgICAgICAgIGxlbiA9IG5hbWUubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbWFwW25hbWVbaV1dID0galF1ZXJ5LmNzcyhlbGVtLCBuYW1lW2ldLCBmYWxzZSwgc3R5bGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSwgdmFsdWUpIDogalF1ZXJ5LmNzcyhlbGVtLCBuYW1lKTtcbiAgICAgIH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBUd2VlbihlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZykge1xuICAgIHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcpO1xuICB9XG5cbiAgalF1ZXJ5LlR3ZWVuID0gVHdlZW47XG4gIFR3ZWVuLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogVHdlZW4sXG4gICAgaW5pdDogZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0KSB7XG4gICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgdGhpcy5wcm9wID0gcHJvcDtcbiAgICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcbiAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgdGhpcy51bml0ID0gdW5pdCB8fCAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSA/IFwiXCIgOiBcInB4XCIpO1xuICAgIH0sXG4gICAgY3VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtcbiAgICAgIHJldHVybiBob29rcyAmJiBob29rcy5nZXQgPyBob29rcy5nZXQodGhpcykgOiBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpO1xuICAgIH0sXG4gICAgcnVuOiBmdW5jdGlvbiAocGVyY2VudCkge1xuICAgICAgdmFyIGVhc2VkLFxuICAgICAgICAgIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzW3RoaXMucHJvcF07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbdGhpcy5lYXNpbmddKHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGVwKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChob29rcyAmJiBob29rcy5zZXQpIHtcbiAgICAgICAgaG9va3Muc2V0KHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBUd2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG4gIFR3ZWVuLnByb3BIb29rcyA9IHtcbiAgICBfZGVmYXVsdDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDsgLy8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcbiAgICAgICAgLy8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblxuICAgICAgICBpZiAodHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fCB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVt0d2Vlbi5wcm9wXSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF07XG4gICAgICAgIH0gLy8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG4gICAgICAgIC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuICAgICAgICAvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXG5cbiAgICAgICAgcmVzdWx0ID0galF1ZXJ5LmNzcyh0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiKTsgLy8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cbiAgICAgICAgcmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgLy8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG4gICAgICAgIC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cbiAgICAgICAgLy8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKGpRdWVyeS5meC5zdGVwW3R3ZWVuLnByb3BdKSB7XG4gICAgICAgICAgalF1ZXJ5LmZ4LnN0ZXBbdHdlZW4ucHJvcF0odHdlZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKGpRdWVyeS5jc3NIb29rc1t0d2Vlbi5wcm9wXSB8fCB0d2Vlbi5lbGVtLnN0eWxlW2ZpbmFsUHJvcE5hbWUodHdlZW4ucHJvcCldICE9IG51bGwpKSB7XG4gICAgICAgICAgalF1ZXJ5LnN0eWxlKHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gPSB0d2Vlbi5ub3c7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gIC8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXG4gIFR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gPSB0d2Vlbi5ub3c7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBqUXVlcnkuZWFzaW5nID0ge1xuICAgIGxpbmVhcjogZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgc3dpbmc6IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gMC41IC0gTWF0aC5jb3MocCAqIE1hdGguUEkpIC8gMjtcbiAgICB9LFxuICAgIF9kZWZhdWx0OiBcInN3aW5nXCJcbiAgfTtcbiAgalF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7IC8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5cbiAgalF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcbiAgdmFyIGZ4Tm93LFxuICAgICAgaW5Qcm9ncmVzcyxcbiAgICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuICAgICAgcnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gICAgaWYgKGluUHJvZ3Jlc3MpIHtcbiAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgalF1ZXJ5LmZ4LnRpY2soKTtcbiAgICB9XG4gIH0gLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuXG5cbiAgZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ4Tm93ID0gRGF0ZS5ub3coKTtcbiAgfSAvLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuXG5cbiAgZnVuY3Rpb24gZ2VuRngodHlwZSwgaW5jbHVkZVdpZHRoKSB7XG4gICAgdmFyIHdoaWNoLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgYXR0cnMgPSB7XG4gICAgICBoZWlnaHQ6IHR5cGVcbiAgICB9OyAvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG4gICAgLy8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblxuICAgIGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXG4gICAgZm9yICg7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGgpIHtcbiAgICAgIHdoaWNoID0gY3NzRXhwYW5kW2ldO1xuICAgICAgYXR0cnNbXCJtYXJnaW5cIiArIHdoaWNoXSA9IGF0dHJzW1wicGFkZGluZ1wiICsgd2hpY2hdID0gdHlwZTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZVdpZHRoKSB7XG4gICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKHZhbHVlLCBwcm9wLCBhbmltYXRpb24pIHtcbiAgICB2YXIgdHdlZW4sXG4gICAgICAgIGNvbGxlY3Rpb24gPSAoQW5pbWF0aW9uLnR3ZWVuZXJzW3Byb3BdIHx8IFtdKS5jb25jYXQoQW5pbWF0aW9uLnR3ZWVuZXJzW1wiKlwiXSksXG4gICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmICh0d2VlbiA9IGNvbGxlY3Rpb25baW5kZXhdLmNhbGwoYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSkpIHtcbiAgICAgICAgLy8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcbiAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoZWxlbSwgcHJvcHMsIG9wdHMpIHtcbiAgICB2YXIgcHJvcCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHRvZ2dsZSxcbiAgICAgICAgaG9va3MsXG4gICAgICAgIG9sZGZpcmUsXG4gICAgICAgIHByb3BUd2VlbixcbiAgICAgICAgcmVzdG9yZURpc3BsYXksXG4gICAgICAgIGRpc3BsYXksXG4gICAgICAgIGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG4gICAgICAgIGFuaW0gPSB0aGlzLFxuICAgICAgICBvcmlnID0ge30sXG4gICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZSxcbiAgICAgICAgaGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoZWxlbSksXG4gICAgICAgIGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KGVsZW0sIFwiZnhzaG93XCIpOyAvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3NcblxuICAgIGlmICghb3B0cy5xdWV1ZSkge1xuICAgICAgaG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoZWxlbSwgXCJmeFwiKTtcblxuICAgICAgaWYgKGhvb2tzLnVucXVldWVkID09IG51bGwpIHtcbiAgICAgICAgaG9va3MudW5xdWV1ZWQgPSAwO1xuICAgICAgICBvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblxuICAgICAgICBob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaG9va3MudW5xdWV1ZWQpIHtcbiAgICAgICAgICAgIG9sZGZpcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGhvb2tzLnVucXVldWVkKys7XG4gICAgICBhbmltLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG4gICAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBob29rcy51bnF1ZXVlZC0tO1xuXG4gICAgICAgICAgaWYgKCFqUXVlcnkucXVldWUoZWxlbSwgXCJmeFwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblxuXG4gICAgZm9yIChwcm9wIGluIHByb3BzKSB7XG4gICAgICB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuXG4gICAgICBpZiAocmZ4dHlwZXMudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BdO1xuICAgICAgICB0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAoaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIikpIHtcbiAgICAgICAgICAvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG4gICAgICAgICAgLy8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcbiAgICAgICAgICBpZiAodmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93W3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhpZGRlbiA9IHRydWU7IC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3JpZ1twcm9wXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93W3Byb3BdIHx8IGpRdWVyeS5zdHlsZShlbGVtLCBwcm9wKTtcbiAgICAgIH1cbiAgICB9IC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cblxuICAgIHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdChwcm9wcyk7XG5cbiAgICBpZiAoIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdChvcmlnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cblxuICAgIGlmIChpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4gICAgICAvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcbiAgICAgIC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuICAgICAgLy8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cbiAgICAgIG9wdHMub3ZlcmZsb3cgPSBbc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZXTsgLy8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cbiAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblxuICAgICAgaWYgKHJlc3RvcmVEaXNwbGF5ID09IG51bGwpIHtcbiAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoZWxlbSwgXCJkaXNwbGF5XCIpO1xuICAgICAgfVxuXG4gICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIik7XG5cbiAgICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICBpZiAocmVzdG9yZURpc3BsYXkpIHtcbiAgICAgICAgICBkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSwgdHJ1ZSk7XG4gICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG4gICAgICAgICAgZGlzcGxheSA9IGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpO1xuICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cblxuICAgICAgaWYgKGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChqUXVlcnkuY3NzKGVsZW0sIFwiZmxvYXRcIikgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcbiAgICAgICAgICBpZiAoIXByb3BUd2Vlbikge1xuICAgICAgICAgICAgYW5pbS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZXN0b3JlRGlzcGxheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgICByZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0cy5vdmVyZmxvdykge1xuICAgICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbMF07XG4gICAgICAgIHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbMV07XG4gICAgICAgIHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbMl07XG4gICAgICB9KTtcbiAgICB9IC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXG5cbiAgICBwcm9wVHdlZW4gPSBmYWxzZTtcblxuICAgIGZvciAocHJvcCBpbiBvcmlnKSB7XG4gICAgICAvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuICAgICAgaWYgKCFwcm9wVHdlZW4pIHtcbiAgICAgICAgaWYgKGRhdGFTaG93KSB7XG4gICAgICAgICAgaWYgKFwiaGlkZGVuXCIgaW4gZGF0YVNob3cpIHtcbiAgICAgICAgICAgIGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoZWxlbSwgXCJmeHNob3dcIiwge1xuICAgICAgICAgICAgZGlzcGxheTogcmVzdG9yZURpc3BsYXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblxuXG4gICAgICAgIGlmICh0b2dnbGUpIHtcbiAgICAgICAgICBkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuICAgICAgICB9IC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cblxuICAgICAgICBpZiAoaGlkZGVuKSB7XG4gICAgICAgICAgc2hvd0hpZGUoW2VsZW1dLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXG4gICAgICAgIGFuaW0uZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcbiAgICAgICAgICBpZiAoIWhpZGRlbikge1xuICAgICAgICAgICAgc2hvd0hpZGUoW2VsZW1dKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgXCJmeHNob3dcIik7XG5cbiAgICAgICAgICBmb3IgKHByb3AgaW4gb3JpZykge1xuICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIHByb3AsIG9yaWdbcHJvcF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXG5cbiAgICAgIHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKGhpZGRlbiA/IGRhdGFTaG93W3Byb3BdIDogMCwgcHJvcCwgYW5pbSk7XG5cbiAgICAgIGlmICghKHByb3AgaW4gZGF0YVNob3cpKSB7XG4gICAgICAgIGRhdGFTaG93W3Byb3BdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXG4gICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICBwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuICAgICAgICAgIHByb3BUd2Vlbi5zdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wRmlsdGVyKHByb3BzLCBzcGVjaWFsRWFzaW5nKSB7XG4gICAgdmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rczsgLy8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cbiAgICBmb3IgKGluZGV4IGluIHByb3BzKSB7XG4gICAgICBuYW1lID0gY2FtZWxDYXNlKGluZGV4KTtcbiAgICAgIGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbbmFtZV07XG4gICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGVhc2luZyA9IHZhbHVlWzFdO1xuICAgICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XSA9IHZhbHVlWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggIT09IG5hbWUpIHtcbiAgICAgICAgcHJvcHNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgZGVsZXRlIHByb3BzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbbmFtZV07XG5cbiAgICAgIGlmIChob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzKSB7XG4gICAgICAgIHZhbHVlID0gaG9va3MuZXhwYW5kKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHByb3BzW25hbWVdOyAvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG4gICAgICAgIC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblxuICAgICAgICBmb3IgKGluZGV4IGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCEoaW5kZXggaW4gcHJvcHMpKSB7XG4gICAgICAgICAgICBwcm9wc1tpbmRleF0gPSB2YWx1ZVtpbmRleF07XG4gICAgICAgICAgICBzcGVjaWFsRWFzaW5nW2luZGV4XSA9IGVhc2luZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwZWNpYWxFYXNpbmdbbmFtZV0gPSBlYXNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQW5pbWF0aW9uKGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBzdG9wcGVkLFxuICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgIGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcbiAgICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG4gICAgICBkZWxldGUgdGljay5lbGVtO1xuICAgIH0pLFxuICAgICAgICB0aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuICAgICAgICAgIHJlbWFpbmluZyA9IE1hdGgubWF4KDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSksXG4gICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuICAgICAgLy8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuICAgICAgdGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuICAgICAgICAgIHBlcmNlbnQgPSAxIC0gdGVtcCxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBhbmltYXRpb24udHdlZW5zW2luZGV4XS5ydW4ocGVyY2VudCk7XG4gICAgICB9XG5cbiAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nXSk7IC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblxuICAgICAgaWYgKHBlcmNlbnQgPCAxICYmIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgICAgfSAvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblxuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKGVsZW0sIFthbmltYXRpb24sIDEsIDBdKTtcbiAgICAgIH0gLy8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblxuXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChlbGVtLCBbYW5pbWF0aW9uXSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAgICAgYW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG4gICAgICBlbGVtOiBlbGVtLFxuICAgICAgcHJvcHM6IGpRdWVyeS5leHRlbmQoe30sIHByb3BlcnRpZXMpLFxuICAgICAgb3B0czogalF1ZXJ5LmV4dGVuZCh0cnVlLCB7XG4gICAgICAgIHNwZWNpYWxFYXNpbmc6IHt9LFxuICAgICAgICBlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcbiAgICAgIH0sIG9wdGlvbnMpLFxuICAgICAgb3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgb3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuICAgICAgc3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICB0d2VlbnM6IFtdLFxuICAgICAgY3JlYXRlVHdlZW46IGZ1bmN0aW9uIChwcm9wLCBlbmQpIHtcbiAgICAgICAgdmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbcHJvcF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nKTtcbiAgICAgICAgYW5pbWF0aW9uLnR3ZWVucy5wdXNoKHR3ZWVuKTtcbiAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgICAgfSxcbiAgICAgIHN0b3A6IGZ1bmN0aW9uIChnb3RvRW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG4gICAgICAgIGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnNbaW5kZXhdLnJ1bigxKTtcbiAgICAgICAgfSAvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXG5cbiAgICAgICAgaWYgKGdvdG9FbmQpIHtcbiAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKGVsZW0sIFthbmltYXRpb24sIDEsIDBdKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChlbGVtLCBbYW5pbWF0aW9uLCBnb3RvRW5kXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0V2l0aChlbGVtLCBbYW5pbWF0aW9uLCBnb3RvRW5kXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9KSxcbiAgICAgICAgcHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cbiAgICBwcm9wRmlsdGVyKHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nKTtcblxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbaW5kZXhdLmNhbGwoYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMpO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHJlc3VsdC5zdG9wKSkge1xuICAgICAgICAgIGpRdWVyeS5fcXVldWVIb29rcyhhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUpLnN0b3AgPSByZXN1bHQuc3RvcC5iaW5kKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGpRdWVyeS5tYXAocHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24pO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oYW5pbWF0aW9uLm9wdHMuc3RhcnQpKSB7XG4gICAgICBhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKGVsZW0sIGFuaW1hdGlvbik7XG4gICAgfSAvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXG5cbiAgICBhbmltYXRpb24ucHJvZ3Jlc3MoYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MpLmRvbmUoYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUpLmZhaWwoYW5pbWF0aW9uLm9wdHMuZmFpbCkuYWx3YXlzKGFuaW1hdGlvbi5vcHRzLmFsd2F5cyk7XG4gICAgalF1ZXJ5LmZ4LnRpbWVyKGpRdWVyeS5leHRlbmQodGljaywge1xuICAgICAgZWxlbTogZWxlbSxcbiAgICAgIGFuaW06IGFuaW1hdGlvbixcbiAgICAgIHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuICAgIH0pKTtcbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9XG5cbiAgalF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoQW5pbWF0aW9uLCB7XG4gICAgdHdlZW5lcnM6IHtcbiAgICAgIFwiKlwiOiBbZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4ocHJvcCwgdmFsdWUpO1xuICAgICAgICBhZGp1c3RDU1ModHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKHZhbHVlKSwgdHdlZW4pO1xuICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICB9XVxuICAgIH0sXG4gICAgdHdlZW5lcjogZnVuY3Rpb24gKHByb3BzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcHMpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gcHJvcHM7XG4gICAgICAgIHByb3BzID0gW1wiKlwiXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BzID0gcHJvcHMubWF0Y2gocm5vdGh0bWx3aGl0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBwcm9wID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbcHJvcF0gPSBBbmltYXRpb24udHdlZW5lcnNbcHJvcF0gfHwgW107XG4gICAgICAgIEFuaW1hdGlvbi50d2VlbmVyc1twcm9wXS51bnNoaWZ0KGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByZWZpbHRlcnM6IFtkZWZhdWx0UHJlZmlsdGVyXSxcbiAgICBwcmVmaWx0ZXI6IGZ1bmN0aW9uIChjYWxsYmFjaywgcHJlcGVuZCkge1xuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgQW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdChjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBmbikge1xuICAgIHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKHt9LCBzcGVlZCkgOiB7XG4gICAgICBjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fCBpc0Z1bmN0aW9uKHNwZWVkKSAmJiBzcGVlZCxcbiAgICAgIGR1cmF0aW9uOiBzcGVlZCxcbiAgICAgIGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbihlYXNpbmcpICYmIGVhc2luZ1xuICAgIH07IC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXG4gICAgaWYgKGpRdWVyeS5meC5vZmYpIHtcbiAgICAgIG9wdC5kdXJhdGlvbiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcykge1xuICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbb3B0LmR1cmF0aW9uXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblxuXG4gICAgaWYgKG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSkge1xuICAgICAgb3B0LnF1ZXVlID0gXCJmeFwiO1xuICAgIH0gLy8gUXVldWVpbmdcblxuXG4gICAgb3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuICAgIG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdC5vbGQpKSB7XG4gICAgICAgIG9wdC5vbGQuY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdC5xdWV1ZSkge1xuICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCBvcHQucXVldWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gb3B0O1xuICB9O1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIGZhZGVUbzogZnVuY3Rpb24gKHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgLy8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaXNIaWRkZW5XaXRoaW5UcmVlKS5jc3MoXCJvcGFjaXR5XCIsIDApLnNob3coKSAvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgIC5lbmQoKS5hbmltYXRlKHtcbiAgICAgICAgb3BhY2l0eTogdG9cbiAgICAgIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QocHJvcCksXG4gICAgICAgICAgb3B0YWxsID0galF1ZXJ5LnNwZWVkKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSxcbiAgICAgICAgICBkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3RcbiAgICAgICAgdmFyIGFuaW0gPSBBbmltYXRpb24odGhpcywgalF1ZXJ5LmV4dGVuZCh7fSwgcHJvcCksIG9wdGFsbCk7IC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXG4gICAgICAgIGlmIChlbXB0eSB8fCBkYXRhUHJpdi5nZXQodGhpcywgXCJmaW5pc2hcIikpIHtcbiAgICAgICAgICBhbmltLnN0b3AodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuICAgICAgcmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgPyB0aGlzLmVhY2goZG9BbmltYXRpb24pIDogdGhpcy5xdWV1ZShvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uKTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uICh0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kKSB7XG4gICAgICB2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24gKGhvb2tzKSB7XG4gICAgICAgIHZhciBzdG9wID0gaG9va3Muc3RvcDtcbiAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XG4gICAgICAgIHN0b3AoZ290b0VuZCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZ290b0VuZCA9IGNsZWFyUXVldWU7XG4gICAgICAgIGNsZWFyUXVldWUgPSB0eXBlO1xuICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xlYXJRdWV1ZSkge1xuICAgICAgICB0aGlzLnF1ZXVlKHR5cGUgfHwgXCJmeFwiLCBbXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVxdWV1ZSA9IHRydWUsXG4gICAgICAgICAgICBpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG4gICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuICAgICAgICAgICAgZGF0YSA9IGRhdGFQcml2LmdldCh0aGlzKTtcblxuICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICBpZiAoZGF0YVtpbmRleF0gJiYgZGF0YVtpbmRleF0uc3RvcCkge1xuICAgICAgICAgICAgc3RvcFF1ZXVlKGRhdGFbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpbmRleCBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtpbmRleF0gJiYgZGF0YVtpbmRleF0uc3RvcCAmJiBycnVuLnRlc3QoaW5kZXgpKSB7XG4gICAgICAgICAgICAgIHN0b3BRdWV1ZShkYXRhW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07KSB7XG4gICAgICAgICAgaWYgKHRpbWVyc1tpbmRleF0uZWxlbSA9PT0gdGhpcyAmJiAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1tpbmRleF0ucXVldWUgPT09IHR5cGUpKSB7XG4gICAgICAgICAgICB0aW1lcnNbaW5kZXhdLmFuaW0uc3RvcChnb3RvRW5kKTtcbiAgICAgICAgICAgIGRlcXVldWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuICAgICAgICAvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG4gICAgICAgIC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblxuXG4gICAgICAgIGlmIChkZXF1ZXVlIHx8ICFnb3RvRW5kKSB7XG4gICAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZmluaXNoOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgIT09IGZhbHNlKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhUHJpdi5nZXQodGhpcyksXG4gICAgICAgICAgICBxdWV1ZSA9IGRhdGFbdHlwZSArIFwicXVldWVcIl0sXG4gICAgICAgICAgICBob29rcyA9IGRhdGFbdHlwZSArIFwicXVldWVIb29rc1wiXSxcbiAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG4gICAgICAgICAgICBsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7IC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblxuICAgICAgICBkYXRhLmZpbmlzaCA9IHRydWU7IC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXG4gICAgICAgIGpRdWVyeS5xdWV1ZSh0aGlzLCB0eXBlLCBbXSk7XG5cbiAgICAgICAgaWYgKGhvb2tzICYmIGhvb2tzLnN0b3ApIHtcbiAgICAgICAgICBob29rcy5zdG9wLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgICAgIH0gLy8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblxuXG4gICAgICAgIGZvciAoaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOykge1xuICAgICAgICAgIGlmICh0aW1lcnNbaW5kZXhdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzW2luZGV4XS5xdWV1ZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgdGltZXJzW2luZGV4XS5hbmltLnN0b3AodHJ1ZSk7XG4gICAgICAgICAgICB0aW1lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblxuXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChxdWV1ZVtpbmRleF0gJiYgcXVldWVbaW5kZXhdLmZpbmlzaCkge1xuICAgICAgICAgICAgcXVldWVbaW5kZXhdLmZpbmlzaC5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXG5cbiAgICAgICAgZGVsZXRlIGRhdGEuZmluaXNoO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgalF1ZXJ5LmVhY2goW1widG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIl0sIGZ1bmN0aW9uIChfaSwgbmFtZSkge1xuICAgIHZhciBjc3NGbiA9IGpRdWVyeS5mbltuYW1lXTtcblxuICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/IGNzc0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzLmFuaW1hdGUoZ2VuRngobmFtZSwgdHJ1ZSksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9KTsgLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xuXG4gIGpRdWVyeS5lYWNoKHtcbiAgICBzbGlkZURvd246IGdlbkZ4KFwic2hvd1wiKSxcbiAgICBzbGlkZVVwOiBnZW5GeChcImhpZGVcIiksXG4gICAgc2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIpLFxuICAgIGZhZGVJbjoge1xuICAgICAgb3BhY2l0eTogXCJzaG93XCJcbiAgICB9LFxuICAgIGZhZGVPdXQ6IHtcbiAgICAgIG9wYWNpdHk6IFwiaGlkZVwiXG4gICAgfSxcbiAgICBmYWRlVG9nZ2xlOiB7XG4gICAgICBvcGFjaXR5OiBcInRvZ2dsZVwiXG4gICAgfVxuICB9LCBmdW5jdGlvbiAobmFtZSwgcHJvcHMpIHtcbiAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAoc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUocHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9KTtcbiAgalF1ZXJ5LnRpbWVycyA9IFtdO1xuXG4gIGpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aW1lcixcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG4gICAgZnhOb3cgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yICg7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRpbWVyID0gdGltZXJzW2ldOyAvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cbiAgICAgIGlmICghdGltZXIoKSAmJiB0aW1lcnNbaV0gPT09IHRpbWVyKSB7XG4gICAgICAgIHRpbWVycy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRpbWVycy5sZW5ndGgpIHtcbiAgICAgIGpRdWVyeS5meC5zdG9wKCk7XG4gICAgfVxuXG4gICAgZnhOb3cgPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgalF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgalF1ZXJ5LnRpbWVycy5wdXNoKHRpbWVyKTtcbiAgICBqUXVlcnkuZnguc3RhcnQoKTtcbiAgfTtcblxuICBqUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcblxuICBqUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGluUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpblByb2dyZXNzID0gdHJ1ZTtcbiAgICBzY2hlZHVsZSgpO1xuICB9O1xuXG4gIGpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGluUHJvZ3Jlc3MgPSBudWxsO1xuICB9O1xuXG4gIGpRdWVyeS5meC5zcGVlZHMgPSB7XG4gICAgc2xvdzogNjAwLFxuICAgIGZhc3Q6IDIwMCxcbiAgICAvLyBEZWZhdWx0IHNwZWVkXG4gICAgX2RlZmF1bHQ6IDQwMFxuICB9OyAvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4gIC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5cbiAgalF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWUsIHR5cGUpIHtcbiAgICB0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1t0aW1lXSB8fCB0aW1lIDogdGltZTtcbiAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG4gICAgcmV0dXJuIHRoaXMucXVldWUodHlwZSwgZnVuY3Rpb24gKG5leHQsIGhvb2tzKSB7XG4gICAgICB2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KG5leHQsIHRpbWUpO1xuXG4gICAgICBob29rcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxcbiAgICAgICAgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKSxcbiAgICAgICAgb3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpO1xuICAgIGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7IC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuICAgIC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXG4gICAgc3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7IC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgIC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cbiAgICBzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkOyAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbiAgICAvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXG4gICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudmFsdWUgPSBcInRcIjtcbiAgICBpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuICAgIHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbiAgfSkoKTtcblxuICB2YXIgYm9vbEhvb2ssXG4gICAgICBhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgYXR0cjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xuICAgIH0sXG4gICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cih0aGlzLCBuYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGpRdWVyeS5leHRlbmQoe1xuICAgIGF0dHI6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHJldCxcbiAgICAgICAgICBob29rcyxcbiAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7IC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblxuICAgICAgaWYgKG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblxuXG4gICAgICBpZiAodHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkucHJvcChlbGVtLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9IC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICAgIC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblxuXG4gICAgICBpZiAoblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSkge1xuICAgICAgICBob29rcyA9IGpRdWVyeS5hdHRySG9va3NbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCAoalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KG5hbWUpID8gYm9vbEhvb2sgOiB1bmRlZmluZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cihlbGVtLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBuYW1lKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSArIFwiXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoZWxlbSwgbmFtZSkpICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldCA9IGpRdWVyeS5maW5kLmF0dHIoZWxlbSwgbmFtZSk7IC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cbiAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcbiAgICB9LFxuICAgIGF0dHJIb29rczoge1xuICAgICAgdHlwZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICAgICAgICAgIGlmICghc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiYgbm9kZU5hbWUoZWxlbSwgXCJpbnB1dFwiKSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGVsZW0udmFsdWU7XG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgIGVsZW0udmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICAgICAgdmFyIG5hbWUsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgLy8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4gICAgICBhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaChybm90aHRtbHdoaXRlKTtcblxuICAgICAgaWYgKGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHdoaWxlIChuYW1lID0gYXR0ck5hbWVzW2krK10pIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcblxuICBib29sSG9vayA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSwgbmFtZSkge1xuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG4gICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKGVsZW0sIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfTtcbiAgalF1ZXJ5LmVhY2goalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksIGZ1bmN0aW9uIChfaSwgbmFtZSkge1xuICAgIHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlW25hbWVdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cbiAgICBhdHRySGFuZGxlW25hbWVdID0gZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XG4gICAgICB2YXIgcmV0LFxuICAgICAgICAgIGhhbmRsZSxcbiAgICAgICAgICBsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoIWlzWE1MKSB7XG4gICAgICAgIC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcbiAgICAgICAgaGFuZGxlID0gYXR0ckhhbmRsZVtsb3dlcmNhc2VOYW1lXTtcbiAgICAgICAgYXR0ckhhbmRsZVtsb3dlcmNhc2VOYW1lXSA9IHJldDtcbiAgICAgICAgcmV0ID0gZ2V0dGVyKGVsZW0sIG5hbWUsIGlzWE1MKSAhPSBudWxsID8gbG93ZXJjYXNlTmFtZSA6IG51bGw7XG4gICAgICAgIGF0dHJIYW5kbGVbbG93ZXJjYXNlTmFtZV0gPSBoYW5kbGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfSk7XG4gIHZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICAgIHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIHByb3A6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcbiAgICB9LFxuICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbalF1ZXJ5LnByb3BGaXhbbmFtZV0gfHwgbmFtZV07XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBqUXVlcnkuZXh0ZW5kKHtcbiAgICBwcm9wOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciByZXQsXG4gICAgICAgICAgaG9va3MsXG4gICAgICAgICAgblR5cGUgPSBlbGVtLm5vZGVUeXBlOyAvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cbiAgICAgIGlmIChuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pKSB7XG4gICAgICAgIC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcbiAgICAgICAgbmFtZSA9IGpRdWVyeS5wcm9wRml4W25hbWVdIHx8IG5hbWU7XG4gICAgICAgIGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldChlbGVtLCB2YWx1ZSwgbmFtZSkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBuYW1lKSkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1bbmFtZV07XG4gICAgfSxcbiAgICBwcm9wSG9va3M6IHtcbiAgICAgIHRhYkluZGV4OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG4gICAgICAgICAgLy8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG4gICAgICAgICAgLy8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG4gICAgICAgICAgLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG4gICAgICAgICAgLy8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3MilcbiAgICAgICAgICB2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKGVsZW0sIFwidGFiaW5kZXhcIik7XG5cbiAgICAgICAgICBpZiAodGFiaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0YWJpbmRleCwgMTApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZm9jdXNhYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkgfHwgcmNsaWNrYWJsZS50ZXN0KGVsZW0ubm9kZU5hbWUpICYmIGVsZW0uaHJlZikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wRml4OiB7XG4gICAgICBcImZvclwiOiBcImh0bWxGb3JcIixcbiAgICAgIFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuICAgIH1cbiAgfSk7IC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAvLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbiAgLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuICAvLyBvbiB0aGUgb3B0aW9uXG4gIC8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4gIC8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbiAgLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4gIC8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuXG4gIGlmICghc3VwcG9ydC5vcHRTZWxlY3RlZCkge1xuICAgIGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cbiAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblxuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgcGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgLyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuICAgICAgICAgIGlmIChwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgalF1ZXJ5LmVhY2goW1widGFiSW5kZXhcIiwgXCJyZWFkT25seVwiLCBcIm1heExlbmd0aFwiLCBcImNlbGxTcGFjaW5nXCIsIFwiY2VsbFBhZGRpbmdcIiwgXCJyb3dTcGFuXCIsIFwiY29sU3BhblwiLCBcInVzZU1hcFwiLCBcImZyYW1lQm9yZGVyXCIsIFwiY29udGVudEVkaXRhYmxlXCJdLCBmdW5jdGlvbiAoKSB7XG4gICAgalF1ZXJ5LnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XG4gIH0pOyAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG4gIC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXG4gIGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UodmFsdWUpIHtcbiAgICB2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XG4gICAgcmV0dXJuIHRva2Vucy5qb2luKFwiIFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIGNsYXNzZXMsXG4gICAgICAgICAgZWxlbSxcbiAgICAgICAgICBjdXIsXG4gICAgICAgICAgY3VyVmFsdWUsXG4gICAgICAgICAgY2xhenosXG4gICAgICAgICAgaixcbiAgICAgICAgICBmaW5hbFZhbHVlLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaikge1xuICAgICAgICAgIGpRdWVyeSh0aGlzKS5hZGRDbGFzcyh2YWx1ZS5jYWxsKHRoaXMsIGosIGdldENsYXNzKHRoaXMpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkodmFsdWUpO1xuXG4gICAgICBpZiAoY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKGVsZW0gPSB0aGlzW2krK10pIHtcbiAgICAgICAgICBjdXJWYWx1ZSA9IGdldENsYXNzKGVsZW0pO1xuICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKGN1clZhbHVlKSArIFwiIFwiO1xuXG4gICAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChjbGF6eiA9IGNsYXNzZXNbaisrXSkge1xuICAgICAgICAgICAgICBpZiAoY3VyLmluZGV4T2YoXCIgXCIgKyBjbGF6eiArIFwiIFwiKSA8IDApIHtcbiAgICAgICAgICAgICAgICBjdXIgKz0gY2xhenogKyBcIiBcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXG5cbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKGN1cik7XG5cbiAgICAgICAgICAgIGlmIChjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSkge1xuICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGZpbmFsVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBjbGFzc2VzLFxuICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgY3VyLFxuICAgICAgICAgIGN1clZhbHVlLFxuICAgICAgICAgIGNsYXp6LFxuICAgICAgICAgIGosXG4gICAgICAgICAgZmluYWxWYWx1ZSxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGopIHtcbiAgICAgICAgICBqUXVlcnkodGhpcykucmVtb3ZlQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBqLCBnZXRDbGFzcyh0aGlzKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoXCJjbGFzc1wiLCBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgY2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KHZhbHVlKTtcblxuICAgICAgaWYgKGNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChlbGVtID0gdGhpc1tpKytdKSB7XG4gICAgICAgICAgY3VyVmFsdWUgPSBnZXRDbGFzcyhlbGVtKTsgLy8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblxuICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKGN1clZhbHVlKSArIFwiIFwiO1xuXG4gICAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChjbGF6eiA9IGNsYXNzZXNbaisrXSkge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG4gICAgICAgICAgICAgIHdoaWxlIChjdXIuaW5kZXhPZihcIiBcIiArIGNsYXp6ICsgXCIgXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIucmVwbGFjZShcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXG5cbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKGN1cik7XG5cbiAgICAgICAgICAgIGlmIChjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSkge1xuICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGZpbmFsVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiAodmFsdWUsIHN0YXRlVmFsKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcbiAgICAgICAgICBpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4gICAgICBpZiAodHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyh2YWx1ZSkgOiB0aGlzLnJlbW92ZUNsYXNzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICBqUXVlcnkodGhpcykudG9nZ2xlQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBpLCBnZXRDbGFzcyh0aGlzKSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuICAgICAgICBpZiAoaXNWYWxpZFZhbHVlKSB7XG4gICAgICAgICAgLy8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICBzZWxmID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgICB3aGlsZSAoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpKytdKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3RcbiAgICAgICAgICAgIGlmIChzZWxmLmhhc0NsYXNzKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcyh0aGlzKTtcblxuICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcbiAgICAgICAgICAgIGRhdGFQcml2LnNldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lKTtcbiAgICAgICAgICB9IC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG4gICAgICAgICAgLy8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cbiAgICAgICAgICAvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuICAgICAgICAgIC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblxuXG4gICAgICAgICAgaWYgKHRoaXMuc2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogZGF0YVByaXYuZ2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiKSB8fCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGNsYXNzTmFtZSxcbiAgICAgICAgICBlbGVtLFxuICAgICAgICAgIGkgPSAwO1xuICAgICAgY2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXG4gICAgICB3aGlsZSAoZWxlbSA9IHRoaXNbaSsrXSkge1xuICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKGdldENsYXNzKGVsZW0pKSArIFwiIFwiKS5pbmRleE9mKGNsYXNzTmFtZSkgPiAtMSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgcnJldHVybiA9IC9cXHIvZztcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgdmFsOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBob29rcyxcbiAgICAgICAgICByZXQsXG4gICAgICAgICAgdmFsdWVJc0Z1bmN0aW9uLFxuICAgICAgICAgIGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICBob29rcyA9IGpRdWVyeS52YWxIb29rc1tlbGVtLnR5cGVdIHx8IGpRdWVyeS52YWxIb29rc1tlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBcInZhbHVlXCIpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldCA9IGVsZW0udmFsdWU7IC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblxuICAgICAgICAgIGlmICh0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0LnJlcGxhY2UocnJldHVybiwgXCJcIik7XG4gICAgICAgICAgfSAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblxuXG4gICAgICAgICAgcmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciB2YWw7XG5cbiAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVJc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgdmFsID0gdmFsdWUuY2FsbCh0aGlzLCBpLCBqUXVlcnkodGhpcykudmFsKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgICB9IC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblxuXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgIHZhbCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHZhbCArPSBcIlwiO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgIHZhbCA9IGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzW3RoaXMudHlwZV0gfHwgalF1ZXJ5LnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07IC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cbiAgICAgICAgaWYgKCFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8IGhvb2tzLnNldCh0aGlzLCB2YWwsIFwidmFsdWVcIikgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGpRdWVyeS5leHRlbmQoe1xuICAgIHZhbEhvb2tzOiB7XG4gICAgICBvcHRpb246IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgIHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKGVsZW0sIFwidmFsdWVcIik7XG4gICAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsID8gdmFsIDogLy8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcbiAgICAgICAgICAvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG4gICAgICAgICAgLy8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2VcbiAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuICAgICAgICAgIHN0cmlwQW5kQ29sbGFwc2UoalF1ZXJ5LnRleHQoZWxlbSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2VsZWN0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgICAgIG9wdGlvbixcbiAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgICAgaW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICAgIG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcbiAgICAgICAgICAgICAgbWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBpID0gbWF4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpID0gb25lID8gaW5kZXggOiAwO1xuICAgICAgICAgIH0gLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXG5cbiAgICAgICAgICBmb3IgKDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldOyAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgLy8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cbiAgICAgICAgICAgIGlmICgob3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4KSAmJiAvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG4gICAgICAgICAgICAhb3B0aW9uLmRpc2FibGVkICYmICghb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIW5vZGVOYW1lKG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIpKSkge1xuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG4gICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5KG9wdGlvbikudmFsKCk7IC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cbiAgICAgICAgICAgICAgaWYgKG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfSAvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXG5cbiAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG9wdGlvblNldCxcbiAgICAgICAgICAgICAgb3B0aW9uLFxuICAgICAgICAgICAgICBvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuICAgICAgICAgICAgICB2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KHZhbHVlKSxcbiAgICAgICAgICAgICAgaSA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cbiAgICAgICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgPSBqUXVlcnkuaW5BcnJheShqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldChvcHRpb24pLCB2YWx1ZXMpID4gLTEpIHtcbiAgICAgICAgICAgICAgb3B0aW9uU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuICAgICAgICAgIH0gLy8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblxuXG4gICAgICAgICAgaWYgKCFvcHRpb25TZXQpIHtcbiAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxuXG4gIGpRdWVyeS5lYWNoKFtcInJhZGlvXCIsIFwiY2hlY2tib3hcIl0sIGZ1bmN0aW9uICgpIHtcbiAgICBqUXVlcnkudmFsSG9va3NbdGhpc10gPSB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoalF1ZXJ5KGVsZW0pLnZhbCgpLCB2YWx1ZSkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIXN1cHBvcnQuY2hlY2tPbikge1xuICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuICB9KTsgLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG4gIHN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG4gIHZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcbiAgICAgIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuXG4gIGpRdWVyeS5leHRlbmQoalF1ZXJ5LmV2ZW50LCB7XG4gICAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGN1cixcbiAgICAgICAgICB0bXAsXG4gICAgICAgICAgYnViYmxlVHlwZSxcbiAgICAgICAgICBvbnR5cGUsXG4gICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgIHNwZWNpYWwsXG4gICAgICAgICAgbGFzdEVsZW1lbnQsXG4gICAgICAgICAgZXZlbnRQYXRoID0gW2VsZW0gfHwgZG9jdW1lbnRdLFxuICAgICAgICAgIHR5cGUgPSBoYXNPd24uY2FsbChldmVudCwgXCJ0eXBlXCIpID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuICAgICAgICAgIG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbChldmVudCwgXCJuYW1lc3BhY2VcIikgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpIDogW107XG4gICAgICBjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50OyAvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXG4gICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cblxuICAgICAgaWYgKHJmb2N1c01vcnBoLnRlc3QodHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUuaW5kZXhPZihcIi5cIikgPiAtMSkge1xuICAgICAgICAvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG4gICAgICAgIG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcbiAgICAgICAgbmFtZXNwYWNlcy5zb3J0KCk7XG4gICAgICB9XG5cbiAgICAgIG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7IC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXG4gICAgICBldmVudCA9IGV2ZW50W2pRdWVyeS5leHBhbmRvXSA/IGV2ZW50IDogbmV3IGpRdWVyeS5FdmVudCh0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQpOyAvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cbiAgICAgIGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuICAgICAgZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKFwiLlwiKTtcbiAgICAgIGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgPyBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIpIDogbnVsbDsgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cbiAgICAgIGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgICAgZXZlbnQudGFyZ2V0ID0gZWxlbTtcbiAgICAgIH0gLy8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXG5cbiAgICAgIGRhdGEgPSBkYXRhID09IG51bGwgPyBbZXZlbnRdIDogalF1ZXJ5Lm1ha2VBcnJheShkYXRhLCBbZXZlbnRdKTsgLy8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXG4gICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XG5cbiAgICAgIGlmICghb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoZWxlbSwgZGF0YSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG4gICAgICAvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXG5cbiAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyhlbGVtKSkge1xuICAgICAgICBidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblxuICAgICAgICBpZiAoIXJmb2N1c01vcnBoLnRlc3QoYnViYmxlVHlwZSArIHR5cGUpKSB7XG4gICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGV2ZW50UGF0aC5wdXNoKGN1cik7XG4gICAgICAgICAgdG1wID0gY3VyO1xuICAgICAgICB9IC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXG5cbiAgICAgICAgaWYgKHRtcCA9PT0gKGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkpIHtcbiAgICAgICAgICBldmVudFBhdGgucHVzaCh0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblxuXG4gICAgICBpID0gMDtcblxuICAgICAgd2hpbGUgKChjdXIgPSBldmVudFBhdGhbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgbGFzdEVsZW1lbnQgPSBjdXI7XG4gICAgICAgIGV2ZW50LnR5cGUgPSBpID4gMSA/IGJ1YmJsZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7IC8vIGpRdWVyeSBoYW5kbGVyXG5cbiAgICAgICAgaGFuZGxlID0gKGRhdGFQcml2LmdldChjdXIsIFwiZXZlbnRzXCIpIHx8IE9iamVjdC5jcmVhdGUobnVsbCkpW2V2ZW50LnR5cGVdICYmIGRhdGFQcml2LmdldChjdXIsIFwiaGFuZGxlXCIpO1xuXG4gICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICBoYW5kbGUuYXBwbHkoY3VyLCBkYXRhKTtcbiAgICAgICAgfSAvLyBOYXRpdmUgaGFuZGxlclxuXG5cbiAgICAgICAgaGFuZGxlID0gb250eXBlICYmIGN1cltvbnR5cGVdO1xuXG4gICAgICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoY3VyKSkge1xuICAgICAgICAgIGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseShjdXIsIGRhdGEpO1xuXG4gICAgICAgICAgaWYgKGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnR5cGUgPSB0eXBlOyAvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cbiAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICBpZiAoKCFzcGVjaWFsLl9kZWZhdWx0IHx8IHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoZXZlbnRQYXRoLnBvcCgpLCBkYXRhKSA9PT0gZmFsc2UpICYmIGFjY2VwdERhdGEoZWxlbSkpIHtcbiAgICAgICAgICAvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuICAgICAgICAgIC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcbiAgICAgICAgICBpZiAob250eXBlICYmIGlzRnVuY3Rpb24oZWxlbVt0eXBlXSkgJiYgIWlzV2luZG93KGVsZW0pKSB7XG4gICAgICAgICAgICAvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG4gICAgICAgICAgICB0bXAgPSBlbGVtW29udHlwZV07XG5cbiAgICAgICAgICAgIGlmICh0bXApIHtcbiAgICAgICAgICAgICAgZWxlbVtvbnR5cGVdID0gbnVsbDtcbiAgICAgICAgICAgIH0gLy8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblxuXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgbGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1bdHlwZV0oKTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgbGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmICh0bXApIHtcbiAgICAgICAgICAgICAgZWxlbVtvbnR5cGVdID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgIH0sXG4gICAgLy8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG4gICAgLy8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcbiAgICBzaW11bGF0ZTogZnVuY3Rpb24gKHR5cGUsIGVsZW0sIGV2ZW50KSB7XG4gICAgICB2YXIgZSA9IGpRdWVyeS5leHRlbmQobmV3IGpRdWVyeS5FdmVudCgpLCBldmVudCwge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBpc1NpbXVsYXRlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihlLCBudWxsLCBlbGVtKTtcbiAgICB9XG4gIH0pO1xuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgIHZhciBlbGVtID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIGVsZW0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuICAvLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4gIC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4gIC8vXG4gIC8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuICAvLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbiAgLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4gIC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5cbiAgaWYgKCFzdXBwb3J0LmZvY3VzaW4pIHtcbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICBmb2N1czogXCJmb2N1c2luXCIsXG4gICAgICBibHVyOiBcImZvY3Vzb3V0XCJcbiAgICB9LCBmdW5jdGlvbiAob3JpZywgZml4KSB7XG4gICAgICAvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KGV2ZW50KSk7XG4gICAgICB9O1xuXG4gICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtmaXhdID0ge1xuICAgICAgICBzZXR1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIEhhbmRsZTogcmVndWxhciBub2RlcyAodmlhIGB0aGlzLm93bmVyRG9jdW1lbnRgKSwgd2luZG93XG4gICAgICAgICAgLy8gKHZpYSBgdGhpcy5kb2N1bWVudGApICYgZG9jdW1lbnQgKHZpYSBgdGhpc2ApLlxuICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2Vzcyhkb2MsIGZpeCk7XG5cbiAgICAgICAgICBpZiAoIWF0dGFjaGVzKSB7XG4gICAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvcmlnLCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhUHJpdi5hY2Nlc3MoZG9jLCBmaXgsIChhdHRhY2hlcyB8fCAwKSArIDEpO1xuICAgICAgICB9LFxuICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2Vzcyhkb2MsIGZpeCkgLSAxO1xuXG4gICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIob3JpZywgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZG9jLCBmaXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhUHJpdi5hY2Nlc3MoZG9jLCBmaXgsIGF0dGFjaGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG4gIHZhciBub25jZSA9IHtcbiAgICBndWlkOiBEYXRlLm5vdygpXG4gIH07XG4gIHZhciBycXVlcnkgPSAvXFw/LzsgLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xuXG4gIGpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHhtbDtcblxuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuICAgIC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXG5cbiAgICB0cnkge1xuICAgICAgeG1sID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZGF0YSwgXCJ0ZXh0L3htbFwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB4bWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RoKSB7XG4gICAgICBqUXVlcnkuZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4geG1sO1xuICB9O1xuXG4gIHZhciByYnJhY2tldCA9IC9cXFtcXF0kLyxcbiAgICAgIHJDUkxGID0gL1xccj9cXG4vZyxcbiAgICAgIHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcbiAgICAgIHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xuICAgIHZhciBuYW1lO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgLy8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG4gICAgICBqUXVlcnkuZWFjaChvYmosIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIGlmICh0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KHByZWZpeCkpIHtcbiAgICAgICAgICAvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG4gICAgICAgICAgYWRkKHByZWZpeCwgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG4gICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgXCJbXCIgKyAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIpICsgXCJdXCIsIHYsIHRyYWRpdGlvbmFsLCBhZGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCF0cmFkaXRpb25hbCAmJiB0b1R5cGUob2JqKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgLy8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuICAgICAgZm9yIChuYW1lIGluIG9iaikge1xuICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqW25hbWVdLCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuICAgICAgYWRkKHByZWZpeCwgb2JqKTtcbiAgICB9XG4gIH0gLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2ZcbiAgLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5cblxuICBqUXVlcnkucGFyYW0gPSBmdW5jdGlvbiAoYSwgdHJhZGl0aW9uYWwpIHtcbiAgICB2YXIgcHJlZml4LFxuICAgICAgICBzID0gW10sXG4gICAgICAgIGFkZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlT3JGdW5jdGlvbikge1xuICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuICAgICAgdmFyIHZhbHVlID0gaXNGdW5jdGlvbih2YWx1ZU9yRnVuY3Rpb24pID8gdmFsdWVPckZ1bmN0aW9uKCkgOiB2YWx1ZU9yRnVuY3Rpb247XG4gICAgICBzW3MubGVuZ3RoXSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSk7XG4gICAgfTtcblxuICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0gLy8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgfHwgYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KGEpKSB7XG4gICAgICAvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcbiAgICAgIGpRdWVyeS5lYWNoKGEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkKHRoaXMubmFtZSwgdGhpcy52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcbiAgICAgIC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuICAgICAgZm9yIChwcmVmaXggaW4gYSkge1xuICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXgsIGFbcHJlZml4XSwgdHJhZGl0aW9uYWwsIGFkZCk7XG4gICAgICB9XG4gICAgfSAvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cblxuICAgIHJldHVybiBzLmpvaW4oXCImXCIpO1xuICB9O1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGpRdWVyeS5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpO1xuICAgIH0sXG4gICAgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcbiAgICAgICAgdmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AodGhpcywgXCJlbGVtZW50c1wiKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheShlbGVtZW50cykgOiB0aGlzO1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7IC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSh0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSAmJiByc3VibWl0dGFibGUudGVzdCh0aGlzLm5vZGVOYW1lKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QodHlwZSkgJiYgKHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCh0eXBlKSk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKF9pLCBlbGVtKSB7XG4gICAgICAgIHZhciB2YWwgPSBqUXVlcnkodGhpcykudmFsKCk7XG5cbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lOiBlbGVtLm5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWwucmVwbGFjZShyQ1JMRiwgXCJcXHJcXG5cIilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGVsZW0ubmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsLnJlcGxhY2UockNSTEYsIFwiXFxyXFxuXCIpXG4gICAgICAgIH07XG4gICAgICB9KS5nZXQoKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgcjIwID0gLyUyMC9nLFxuICAgICAgcmhhc2ggPSAvIy4qJC8sXG4gICAgICByYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuICAgICAgcmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuICAgICAgLy8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG4gIHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG4gICAgICBybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcbiAgICAgIHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuICAvKiBQcmVmaWx0ZXJzXG4gICAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG4gICAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG4gICAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcbiAgICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuICAgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG4gICAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcbiAgICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcbiAgICovXG4gIHByZWZpbHRlcnMgPSB7fSxcblxuICAvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG4gICAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcbiAgICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuICAgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcbiAgICovXG4gIHRyYW5zcG9ydHMgPSB7fSxcbiAgICAgIC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuICBhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoXCIqXCIpLFxuICAgICAgLy8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG4gIG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICBvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7IC8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcblxuICBmdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoc3RydWN0dXJlKSB7XG4gICAgLy8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuICAgICAgICBkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGFUeXBlLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICAvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG4gICAgICAgIHdoaWxlIChkYXRhVHlwZSA9IGRhdGFUeXBlc1tpKytdKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICBpZiAoZGF0YVR5cGVbMF0gPT09IFwiK1wiKSB7XG4gICAgICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKDEpIHx8IFwiKlwiO1xuICAgICAgICAgICAgKHN0cnVjdHVyZVtkYXRhVHlwZV0gPSBzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdKS51bnNoaWZ0KGZ1bmMpOyAvLyBPdGhlcndpc2UgYXBwZW5kXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIChzdHJ1Y3R1cmVbZGF0YVR5cGVdID0gc3RydWN0dXJlW2RhdGFUeXBlXSB8fCBbXSkucHVzaChmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9IC8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuXG5cbiAgZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSKSB7XG4gICAgdmFyIGluc3BlY3RlZCA9IHt9LFxuICAgICAgICBzZWVraW5nVHJhbnNwb3J0ID0gc3RydWN0dXJlID09PSB0cmFuc3BvcnRzO1xuXG4gICAgZnVuY3Rpb24gaW5zcGVjdChkYXRhVHlwZSkge1xuICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgaW5zcGVjdGVkW2RhdGFUeXBlXSA9IHRydWU7XG4gICAgICBqUXVlcnkuZWFjaChzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdLCBmdW5jdGlvbiAoXywgcHJlZmlsdGVyT3JGYWN0b3J5KSB7XG4gICAgICAgIHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJiAhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkW2RhdGFUeXBlT3JUcmFuc3BvcnRdKSB7XG4gICAgICAgICAgb3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdChkYXRhVHlwZU9yVHJhbnNwb3J0KTtcbiAgICAgICAgICBpbnNwZWN0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWVraW5nVHJhbnNwb3J0KSB7XG4gICAgICAgICAgcmV0dXJuICEoc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3BlY3Qob3B0aW9ucy5kYXRhVHlwZXNbMF0pIHx8ICFpbnNwZWN0ZWRbXCIqXCJdICYmIGluc3BlY3QoXCIqXCIpO1xuICB9IC8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuICAvLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuICAvLyBGaXhlcyAjOTg4N1xuXG5cbiAgZnVuY3Rpb24gYWpheEV4dGVuZCh0YXJnZXQsIHNyYykge1xuICAgIHZhciBrZXksXG4gICAgICAgIGRlZXAsXG4gICAgICAgIGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuICAgIGZvciAoa2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyY1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgKGZsYXRPcHRpb25zW2tleV0gPyB0YXJnZXQgOiBkZWVwIHx8IChkZWVwID0ge30pKVtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgdGFyZ2V0LCBkZWVwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIC8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAgICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAgICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyhzLCBqcVhIUiwgcmVzcG9uc2VzKSB7XG4gICAgdmFyIGN0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBmaW5hbERhdGFUeXBlLFxuICAgICAgICBmaXJzdERhdGFUeXBlLFxuICAgICAgICBjb250ZW50cyA9IHMuY29udGVudHMsXG4gICAgICAgIGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzOyAvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXG4gICAgd2hpbGUgKGRhdGFUeXBlc1swXSA9PT0gXCIqXCIpIHtcbiAgICAgIGRhdGFUeXBlcy5zaGlmdCgpO1xuXG4gICAgICBpZiAoY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICB9XG4gICAgfSAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblxuXG4gICAgaWYgKGN0KSB7XG4gICAgICBmb3IgKHR5cGUgaW4gY29udGVudHMpIHtcbiAgICAgICAgaWYgKGNvbnRlbnRzW3R5cGVdICYmIGNvbnRlbnRzW3R5cGVdLnRlc3QoY3QpKSB7XG4gICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQodHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXG5cbiAgICBpZiAoZGF0YVR5cGVzWzBdIGluIHJlc3BvbnNlcykge1xuICAgICAgZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuICAgICAgZm9yICh0eXBlIGluIHJlc3BvbnNlcykge1xuICAgICAgICBpZiAoIWRhdGFUeXBlc1swXSB8fCBzLmNvbnZlcnRlcnNbdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdXSkge1xuICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmaXJzdERhdGFUeXBlKSB7XG4gICAgICAgICAgZmlyc3REYXRhVHlwZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cblxuICAgICAgZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcbiAgICB9IC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcbiAgICAvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuICAgIC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcblxuXG4gICAgaWYgKGZpbmFsRGF0YVR5cGUpIHtcbiAgICAgIGlmIChmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbMF0pIHtcbiAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoZmluYWxEYXRhVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZXNbZmluYWxEYXRhVHlwZV07XG4gICAgfVxuICB9XG4gIC8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAgICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYWpheENvbnZlcnQocywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MpIHtcbiAgICB2YXIgY29udjIsXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIGNvbnYsXG4gICAgICAgIHRtcCxcbiAgICAgICAgcHJldixcbiAgICAgICAgY29udmVydGVycyA9IHt9LFxuICAgICAgICAvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG4gICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTsgLy8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cbiAgICBpZiAoZGF0YVR5cGVzWzFdKSB7XG4gICAgICBmb3IgKGNvbnYgaW4gcy5jb252ZXJ0ZXJzKSB7XG4gICAgICAgIGNvbnZlcnRlcnNbY29udi50b0xvd2VyQ2FzZSgpXSA9IHMuY29udmVydGVyc1tjb252XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7IC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgaWYgKHMucmVzcG9uc2VGaWVsZHNbY3VycmVudF0pIHtcbiAgICAgICAganFYSFJbcy5yZXNwb25zZUZpZWxkc1tjdXJyZW50XV0gPSByZXNwb25zZTtcbiAgICAgIH0gLy8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblxuXG4gICAgICBpZiAoIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlcikge1xuICAgICAgICByZXNwb25zZSA9IHMuZGF0YUZpbHRlcihyZXNwb25zZSwgcy5kYXRhVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXYgPSBjdXJyZW50O1xuICAgICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBcIipcIikge1xuICAgICAgICAgIGN1cnJlbnQgPSBwcmV2OyAvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG4gICAgICAgIH0gZWxzZSBpZiAocHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCkge1xuICAgICAgICAgIC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG4gICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbcHJldiArIFwiIFwiICsgY3VycmVudF0gfHwgY29udmVydGVyc1tcIiogXCIgKyBjdXJyZW50XTsgLy8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblxuICAgICAgICAgIGlmICghY29udikge1xuICAgICAgICAgICAgZm9yIChjb252MiBpbiBjb252ZXJ0ZXJzKSB7XG4gICAgICAgICAgICAgIC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuICAgICAgICAgICAgICB0bXAgPSBjb252Mi5zcGxpdChcIiBcIik7XG5cbiAgICAgICAgICAgICAgaWYgKHRtcFsxXSA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzW3ByZXYgKyBcIiBcIiArIHRtcFswXV0gfHwgY29udmVydGVyc1tcIiogXCIgKyB0bXBbMF1dO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcbiAgICAgICAgICAgICAgICAgIGlmIChjb252ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzW2NvbnYyXTsgLy8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb252ZXJ0ZXJzW2NvbnYyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdG1wWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCh0bXBbMV0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXG5cbiAgICAgICAgICBpZiAoY29udiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuICAgICAgICAgICAgaWYgKGNvbnYgJiYgcy50aHJvd3MpIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZTogXCJzdWNjZXNzXCIsXG4gICAgICBkYXRhOiByZXNwb25zZVxuICAgIH07XG4gIH1cblxuICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcbiAgICBhY3RpdmU6IDAsXG4gICAgLy8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuICAgIGxhc3RNb2RpZmllZDoge30sXG4gICAgZXRhZzoge30sXG4gICAgYWpheFNldHRpbmdzOiB7XG4gICAgICB1cmw6IGxvY2F0aW9uLmhyZWYsXG4gICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgaXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdChsb2NhdGlvbi5wcm90b2NvbCksXG4gICAgICBnbG9iYWw6IHRydWUsXG4gICAgICBwcm9jZXNzRGF0YTogdHJ1ZSxcbiAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cbiAgICAgIC8qXG4gICAgICB0aW1lb3V0OiAwLFxuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGRhdGFUeXBlOiBudWxsLFxuICAgICAgdXNlcm5hbWU6IG51bGwsXG4gICAgICBwYXNzd29yZDogbnVsbCxcbiAgICAgIGNhY2hlOiBudWxsLFxuICAgICAgdGhyb3dzOiBmYWxzZSxcbiAgICAgIHRyYWRpdGlvbmFsOiBmYWxzZSxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgKi9cbiAgICAgIGFjY2VwdHM6IHtcbiAgICAgICAgXCIqXCI6IGFsbFR5cGVzLFxuICAgICAgICB0ZXh0OiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgaHRtbDogXCJ0ZXh0L2h0bWxcIixcbiAgICAgICAgeG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcbiAgICAgICAganNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuICAgICAgfSxcbiAgICAgIGNvbnRlbnRzOiB7XG4gICAgICAgIHhtbDogL1xcYnhtbFxcYi8sXG4gICAgICAgIGh0bWw6IC9cXGJodG1sLyxcbiAgICAgICAganNvbjogL1xcYmpzb25cXGIvXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VGaWVsZHM6IHtcbiAgICAgICAgeG1sOiBcInJlc3BvbnNlWE1MXCIsXG4gICAgICAgIHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG4gICAgICAgIGpzb246IFwicmVzcG9uc2VKU09OXCJcbiAgICAgIH0sXG4gICAgICAvLyBEYXRhIGNvbnZlcnRlcnNcbiAgICAgIC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgIGNvbnZlcnRlcnM6IHtcbiAgICAgICAgLy8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG4gICAgICAgIFwiKiB0ZXh0XCI6IFN0cmluZyxcbiAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG4gICAgICAgIFwidGV4dCBodG1sXCI6IHRydWUsXG4gICAgICAgIC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cbiAgICAgICAgXCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcbiAgICAgICAgLy8gUGFyc2UgdGV4dCBhcyB4bWxcbiAgICAgICAgXCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcbiAgICAgIH0sXG4gICAgICAvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuICAgICAgLy8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuICAgICAgLy8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcbiAgICAgIC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuICAgICAgZmxhdE9wdGlvbnM6IHtcbiAgICAgICAgdXJsOiB0cnVlLFxuICAgICAgICBjb250ZXh0OiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuICAgIC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cbiAgICAvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuICAgIGFqYXhTZXR1cDogZnVuY3Rpb24gKHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgIHJldHVybiBzZXR0aW5ncyA/IC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICBhamF4RXh0ZW5kKGFqYXhFeHRlbmQodGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzKSwgc2V0dGluZ3MpIDogLy8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuICAgICAgYWpheEV4dGVuZChqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQpO1xuICAgIH0sXG4gICAgYWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHByZWZpbHRlcnMpLFxuICAgIGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyh0cmFuc3BvcnRzKSxcbiAgICAvLyBNYWluIG1ldGhvZFxuICAgIGFqYXg6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgIC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvcHRpb25zID0gdXJsO1xuICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICB9IC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgdHJhbnNwb3J0LFxuICAgICAgICAgIC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cbiAgICAgIGNhY2hlVVJMLFxuICAgICAgICAgIC8vIFJlc3BvbnNlIGhlYWRlcnNcbiAgICAgIHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgLy8gdGltZW91dCBoYW5kbGVcbiAgICAgIHRpbWVvdXRUaW1lcixcbiAgICAgICAgICAvLyBVcmwgY2xlYW51cCB2YXJcbiAgICAgIHVybEFuY2hvcixcbiAgICAgICAgICAvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG4gICAgICBjb21wbGV0ZWQsXG4gICAgICAgICAgLy8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG4gICAgICBmaXJlR2xvYmFscyxcbiAgICAgICAgICAvLyBMb29wIHZhcmlhYmxlXG4gICAgICBpLFxuICAgICAgICAgIC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuICAgICAgdW5jYWNoZWQsXG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuICAgICAgcyA9IGpRdWVyeS5hamF4U2V0dXAoe30sIG9wdGlvbnMpLFxuICAgICAgICAgIC8vIENhbGxiYWNrcyBjb250ZXh0XG4gICAgICBjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcbiAgICAgICAgICAvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG4gICAgICBnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiYgKGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5KSA/IGpRdWVyeShjYWxsYmFja0NvbnRleHQpIDogalF1ZXJ5LmV2ZW50LFxuICAgICAgICAgIC8vIERlZmVycmVkc1xuICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcbiAgICAgICAgICBjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICBzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuICAgICAgICAgIC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG4gICAgICByZXF1ZXN0SGVhZGVycyA9IHt9LFxuICAgICAgICAgIHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcbiAgICAgICAgICAvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcbiAgICAgIHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuICAgICAgICAgIC8vIEZha2UgeGhyXG4gICAgICBqcVhIUiA9IHtcbiAgICAgICAgcmVhZHlTdGF0ZTogMCxcbiAgICAgICAgLy8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuICAgICAgICBnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHZhciBtYXRjaDtcblxuICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXG4gICAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHJoZWFkZXJzLmV4ZWMocmVzcG9uc2VIZWFkZXJzU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1ttYXRjaFsxXS50b0xvd2VyQ2FzZSgpICsgXCIgXCJdID0gKHJlc3BvbnNlSGVhZGVyc1ttYXRjaFsxXS50b0xvd2VyQ2FzZSgpICsgXCIgXCJdIHx8IFtdKS5jb25jYXQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpICsgXCIgXCJdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmF3IHN0cmluZ1xuICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2FjaGVzIHRoZSBoZWFkZXJcbiAgICAgICAgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGNvbXBsZXRlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gcmVxdWVzdEhlYWRlcnNOYW1lc1tuYW1lLnRvTG93ZXJDYXNlKCldIHx8IG5hbWU7XG4gICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuICAgICAgICBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIGlmIChjb21wbGV0ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcy5taW1lVHlwZSA9IHR5cGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICAgIHN0YXR1c0NvZGU6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICB2YXIgY29kZTtcblxuICAgICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG4gICAgICAgICAgICAgIGpxWEhSLmFsd2F5cyhtYXBbanFYSFIuc3RhdHVzXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuICAgICAgICAgICAgICBmb3IgKGNvZGUgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZVtjb2RlXSA9IFtzdGF0dXNDb2RlW2NvZGVdLCBtYXBbY29kZV1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24gKHN0YXR1c1RleHQpIHtcbiAgICAgICAgICB2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblxuICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5hYm9ydChmaW5hbFRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvbmUoMCwgZmluYWxUZXh0KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfTsgLy8gQXR0YWNoIGRlZmVycmVkc1xuXG4gICAgICBkZWZlcnJlZC5wcm9taXNlKGpxWEhSKTsgLy8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG4gICAgICAvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuICAgICAgLy8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cbiAgICAgIHMudXJsID0gKCh1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZikgKyBcIlwiKS5yZXBsYWNlKHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIpOyAvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblxuICAgICAgcy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTsgLy8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXG4gICAgICBzLmRhdGFUeXBlcyA9IChzLmRhdGFUeXBlIHx8IFwiKlwiKS50b0xvd2VyQ2FzZSgpLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtcIlwiXTsgLy8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cbiAgICAgIGlmIChzLmNyb3NzRG9tYWluID09IG51bGwpIHtcbiAgICAgICAgdXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7IC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcbiAgICAgICAgLy8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcbiAgICAgICAgLy8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsQW5jaG9yLmhyZWYgPSBzLnVybDsgLy8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuICAgICAgICAgIC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cbiAgICAgICAgICB1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuICAgICAgICAgIHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT0gdXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcbiAgICAgICAgICAvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG4gICAgICAgICAgcy5jcm9zc0RvbWFpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cblxuICAgICAgaWYgKHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcy5kYXRhID0galF1ZXJ5LnBhcmFtKHMuZGF0YSwgcy50cmFkaXRpb25hbCk7XG4gICAgICB9IC8vIEFwcGx5IHByZWZpbHRlcnNcblxuXG4gICAgICBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUik7IC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cbiAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgfSAvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuICAgICAgLy8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblxuXG4gICAgICBmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDsgLy8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXG4gICAgICBpZiAoZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwKSB7XG4gICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpO1xuICAgICAgfSAvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblxuXG4gICAgICBzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTsgLy8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblxuICAgICAgcy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdChzLnR5cGUpOyAvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2VcbiAgICAgIC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuICAgICAgLy8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXG4gICAgICBjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2Uocmhhc2gsIFwiXCIpOyAvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXG4gICAgICBpZiAoIXMuaGFzQ29udGVudCkge1xuICAgICAgICAvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcbiAgICAgICAgdW5jYWNoZWQgPSBzLnVybC5zbGljZShjYWNoZVVSTC5sZW5ndGgpOyAvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cbiAgICAgICAgaWYgKHMuZGF0YSAmJiAocy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgIGNhY2hlVVJMICs9IChycXVlcnkudGVzdChjYWNoZVVSTCkgPyBcIiZcIiA6IFwiP1wiKSArIHMuZGF0YTsgLy8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXG4gICAgICAgICAgZGVsZXRlIHMuZGF0YTtcbiAgICAgICAgfSAvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cblxuICAgICAgICBpZiAocy5jYWNoZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UocmFudGlDYWNoZSwgXCIkMVwiKTtcbiAgICAgICAgICB1bmNhY2hlZCA9IChycXVlcnkudGVzdChjYWNoZVVSTCkgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIG5vbmNlLmd1aWQrKyArIHVuY2FjaGVkO1xuICAgICAgICB9IC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblxuXG4gICAgICAgIHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDsgLy8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG4gICAgICB9IGVsc2UgaWYgKHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIChzLmNvbnRlbnRUeXBlIHx8IFwiXCIpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikgPT09IDApIHtcbiAgICAgICAgcy5kYXRhID0gcy5kYXRhLnJlcGxhY2UocjIwLCBcIitcIik7XG4gICAgICB9IC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cblxuICAgICAgaWYgKHMuaWZNb2RpZmllZCkge1xuICAgICAgICBpZiAoalF1ZXJ5Lmxhc3RNb2RpZmllZFtjYWNoZVVSTF0pIHtcbiAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFtjYWNoZVVSTF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGpRdWVyeS5ldGFnW2NhY2hlVVJMXSkge1xuICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnW2NhY2hlVVJMXSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cblxuICAgICAgaWYgKHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSkge1xuICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUpO1xuICAgICAgfSAvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cblxuICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBzLmRhdGFUeXBlc1swXSAmJiBzLmFjY2VwdHNbcy5kYXRhVHlwZXNbMF1dID8gcy5hY2NlcHRzW3MuZGF0YVR5cGVzWzBdXSArIChzLmRhdGFUeXBlc1swXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIpIDogcy5hY2NlcHRzW1wiKlwiXSk7IC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXG4gICAgICBmb3IgKGkgaW4gcy5oZWFkZXJzKSB7XG4gICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoaSwgcy5oZWFkZXJzW2ldKTtcbiAgICAgIH0gLy8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXG5cbiAgICAgIGlmIChzLmJlZm9yZVNlbmQgJiYgKHMuYmVmb3JlU2VuZC5jYWxsKGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMpID09PSBmYWxzZSB8fCBjb21wbGV0ZWQpKSB7XG4gICAgICAgIC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgIH0gLy8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cblxuICAgICAgc3RyQWJvcnQgPSBcImFib3J0XCI7IC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXG4gICAgICBjb21wbGV0ZURlZmVycmVkLmFkZChzLmNvbXBsZXRlKTtcbiAgICAgIGpxWEhSLmRvbmUocy5zdWNjZXNzKTtcbiAgICAgIGpxWEhSLmZhaWwocy5lcnJvcik7IC8vIEdldCB0cmFuc3BvcnRcblxuICAgICAgdHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHModHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIpOyAvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblxuICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgZG9uZSgtMSwgXCJObyBUcmFuc3BvcnRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gMTsgLy8gU2VuZCBnbG9iYWwgZXZlbnRcblxuICAgICAgICBpZiAoZmlyZUdsb2JhbHMpIHtcbiAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihcImFqYXhTZW5kXCIsIFtqcVhIUiwgc10pO1xuICAgICAgICB9IC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cblxuICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICB9IC8vIFRpbWVvdXRcblxuXG4gICAgICAgIGlmIChzLmFzeW5jICYmIHMudGltZW91dCA+IDApIHtcbiAgICAgICAgICB0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBqcVhIUi5hYm9ydChcInRpbWVvdXRcIik7XG4gICAgICAgICAgfSwgcy50aW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQocmVxdWVzdEhlYWRlcnMsIGRvbmUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfSAvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblxuXG4gICAgICAgICAgZG9uZSgtMSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cblxuICAgICAgZnVuY3Rpb24gZG9uZShzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycykge1xuICAgICAgICB2YXIgaXNTdWNjZXNzLFxuICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBtb2RpZmllZCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0OyAvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cbiAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7IC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cbiAgICAgICAgaWYgKHRpbWVvdXRUaW1lcikge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFRpbWVyKTtcbiAgICAgICAgfSAvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgICAvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXG5cbiAgICAgICAgdHJhbnNwb3J0ID0gdW5kZWZpbmVkOyAvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiOyAvLyBTZXQgcmVhZHlTdGF0ZVxuXG4gICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7IC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cbiAgICAgICAgaXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7IC8vIEdldCByZXNwb25zZSBkYXRhXG5cbiAgICAgICAgaWYgKHJlc3BvbnNlcykge1xuICAgICAgICAgIHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyhzLCBqcVhIUiwgcmVzcG9uc2VzKTtcbiAgICAgICAgfSAvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHRcblxuXG4gICAgICAgIGlmICghaXNTdWNjZXNzICYmIGpRdWVyeS5pbkFycmF5KFwic2NyaXB0XCIsIHMuZGF0YVR5cGVzKSA+IC0xKSB7XG4gICAgICAgICAgcy5jb252ZXJ0ZXJzW1widGV4dCBzY3JpcHRcIl0gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfSAvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cblxuICAgICAgICByZXNwb25zZSA9IGFqYXhDb252ZXJ0KHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzKTsgLy8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblxuICAgICAgICBpZiAoaXNTdWNjZXNzKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cbiAgICAgICAgICBpZiAocy5pZk1vZGlmaWVkKSB7XG4gICAgICAgICAgICBtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcblxuICAgICAgICAgICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpO1xuXG4gICAgICAgICAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgalF1ZXJ5LmV0YWdbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBpZiBubyBjb250ZW50XG5cblxuICAgICAgICAgIGlmIChzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjsgLy8gaWYgbm90IG1vZGlmaWVkXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjsgLy8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgIGlzU3VjY2VzcyA9ICFlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuICAgICAgICAgIGVycm9yID0gc3RhdHVzVGV4dDtcblxuICAgICAgICAgIGlmIChzdGF0dXMgfHwgIXN0YXR1c1RleHQpIHtcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cbiAgICAgICAgICAgIGlmIChzdGF0dXMgPCAwKSB7XG4gICAgICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cblxuICAgICAgICBqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIGpxWEhSLnN0YXR1c1RleHQgPSAobmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0KSArIFwiXCI7IC8vIFN1Y2Nlc3MvRXJyb3JcblxuICAgICAgICBpZiAoaXNTdWNjZXNzKSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoY2FsbGJhY2tDb250ZXh0LCBbc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKGNhbGxiYWNrQ29udGV4dCwgW2pxWEhSLCBzdGF0dXNUZXh0LCBlcnJvcl0pO1xuICAgICAgICB9IC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cblxuICAgICAgICBqcVhIUi5zdGF0dXNDb2RlKHN0YXR1c0NvZGUpO1xuICAgICAgICBzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChmaXJlR2xvYmFscykge1xuICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsIFtqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yXSk7XG4gICAgICAgIH0gLy8gQ29tcGxldGVcblxuXG4gICAgICAgIGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoY2FsbGJhY2tDb250ZXh0LCBbanFYSFIsIHN0YXR1c1RleHRdKTtcblxuICAgICAgICBpZiAoZmlyZUdsb2JhbHMpIHtcbiAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLCBbanFYSFIsIHNdKTsgLy8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cbiAgICAgICAgICBpZiAoISAtLWpRdWVyeS5hY3RpdmUpIHtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqcVhIUjtcbiAgICB9LFxuICAgIGdldEpTT046IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4galF1ZXJ5LmdldCh1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIik7XG4gICAgfSxcbiAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4galF1ZXJ5LmdldCh1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIpO1xuICAgIH1cbiAgfSk7XG4gIGpRdWVyeS5lYWNoKFtcImdldFwiLCBcInBvc3RcIl0sIGZ1bmN0aW9uIChfaSwgbWV0aG9kKSB7XG4gICAgalF1ZXJ5W21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSkge1xuICAgICAgLy8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9IC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXG5cbiAgICAgIHJldHVybiBqUXVlcnkuYWpheChqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHR5cGU6IG1ldGhvZCxcbiAgICAgICAgZGF0YVR5cGU6IHR5cGUsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHN1Y2Nlc3M6IGNhbGxiYWNrXG4gICAgICB9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCh1cmwpICYmIHVybCkpO1xuICAgIH07XG4gIH0pO1xuICBqUXVlcnkuYWpheFByZWZpbHRlcihmdW5jdGlvbiAocykge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpIGluIHMuaGVhZGVycykge1xuICAgICAgaWYgKGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIikge1xuICAgICAgICBzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzW2ldIHx8IFwiXCI7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBqUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBkb2MpIHtcbiAgICByZXR1cm4galF1ZXJ5LmFqYXgoe1xuICAgICAgdXJsOiB1cmwsXG4gICAgICAvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcbiAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICBkYXRhVHlwZTogXCJzY3JpcHRcIixcbiAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAgIC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG4gICAgICAvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuICAgICAgLy8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG4gICAgICBjb252ZXJ0ZXJzOiB7XG4gICAgICAgIFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24gKCkge31cbiAgICAgIH0sXG4gICAgICBkYXRhRmlsdGVyOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgalF1ZXJ5Lmdsb2JhbEV2YWwocmVzcG9uc2UsIG9wdGlvbnMsIGRvYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgd3JhcEFsbDogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgIHZhciB3cmFwO1xuXG4gICAgICBpZiAodGhpc1swXSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihodG1sKSkge1xuICAgICAgICAgIGh0bWwgPSBodG1sLmNhbGwodGhpc1swXSk7XG4gICAgICAgIH0gLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblxuXG4gICAgICAgIHdyYXAgPSBqUXVlcnkoaHRtbCwgdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSh0cnVlKTtcblxuICAgICAgICBpZiAodGhpc1swXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgd3JhcC5pbnNlcnRCZWZvcmUodGhpc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICB3cmFwLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSB0aGlzO1xuXG4gICAgICAgICAgd2hpbGUgKGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICB9KS5hcHBlbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgd3JhcElubmVyOiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oaHRtbCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIGpRdWVyeSh0aGlzKS53cmFwSW5uZXIoaHRtbC5jYWxsKHRoaXMsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKSxcbiAgICAgICAgICAgIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG4gICAgICAgIGlmIChjb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZW50cy53cmFwQWxsKGh0bWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuYXBwZW5kKGh0bWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHdyYXA6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICB2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKGh0bWwpO1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICBqUXVlcnkodGhpcykud3JhcEFsbChodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB1bndyYXA6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdGhpcy5wYXJlbnQoc2VsZWN0b3IpLm5vdChcImJvZHlcIikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGpRdWVyeSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuXG4gIGpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZShlbGVtKTtcbiAgfTtcblxuICBqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHJldHVybiAhIShlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuICB9O1xuXG4gIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH07XG5cbiAgdmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG4gICAgLy8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcbiAgICAwOiAyMDAsXG4gICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcbiAgICAxMjIzOiAyMDRcbiAgfSxcbiAgICAgIHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG4gIHN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkO1xuICBzdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcbiAgalF1ZXJ5LmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7IC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcblxuICAgIGlmIChzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZW5kOiBmdW5jdGlvbiAoaGVhZGVycywgY29tcGxldGUpIHtcbiAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgeGhyID0gb3B0aW9ucy54aHIoKTtcbiAgICAgICAgICB4aHIub3BlbihvcHRpb25zLnR5cGUsIG9wdGlvbnMudXJsLCBvcHRpb25zLmFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkKTsgLy8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMueGhyRmllbGRzKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gb3B0aW9ucy54aHJGaWVsZHMpIHtcbiAgICAgICAgICAgICAgeGhyW2ldID0gb3B0aW9ucy54aHJGaWVsZHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cblxuICAgICAgICAgIGlmIChvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XG4gICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShvcHRpb25zLm1pbWVUeXBlKTtcbiAgICAgICAgICB9IC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG4gICAgICAgICAgLy8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuICAgICAgICAgIC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG4gICAgICAgICAgLy8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG4gICAgICAgICAgLy8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cblxuICAgICAgICAgIGlmICghb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuICAgICAgICAgIH0gLy8gU2V0IGhlYWRlcnNcblxuXG4gICAgICAgICAgZm9yIChpIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIGhlYWRlcnNbaV0pO1xuICAgICAgICAgIH0gLy8gQ2FsbGJhY2tcblxuXG4gICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9IHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhYm9ydFwiKSB7XG4gICAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAgICAgICAgICAgICAgIC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuICAgICAgICAgICAgICAgICAgLy8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKDAsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSggLy8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcbiAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb21wbGV0ZSh4aHJTdWNjZXNzU3RhdHVzW3hoci5zdGF0dXNdIHx8IHhoci5zdGF0dXMsIHhoci5zdGF0dXNUZXh0LCAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgICAgICAgLy8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuICAgICAgICAgICAgICAgICAgLy8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcbiAgICAgICAgICAgICAgICAgICh4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiKSAhPT0gXCJ0ZXh0XCIgfHwgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeTogeGhyLnJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgICAgICAgICAgICB9LCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9OyAvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cblxuICAgICAgICAgIHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuICAgICAgICAgIGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayhcImVycm9yXCIpOyAvLyBTdXBwb3J0OiBJRSA5IG9ubHlcbiAgICAgICAgICAvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuICAgICAgICAgIC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblxuICAgICAgICAgIGlmICh4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcbiAgICAgICAgICAgICAgICAvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSAvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cblxuICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soXCJhYm9ydFwiKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG4gICAgICAgICAgICB4aHIuc2VuZChvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pOyAvLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxuXG4gIGpRdWVyeS5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMuY3Jvc3NEb21haW4pIHtcbiAgICAgIHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG4gICAgfVxuICB9KTsgLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcblxuICBqUXVlcnkuYWpheFNldHVwKHtcbiAgICBhY2NlcHRzOiB7XG4gICAgICBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArIFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcbiAgICB9LFxuICAgIGNvbnRlbnRzOiB7XG4gICAgICBzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuICAgIH0sXG4gICAgY29udmVydGVyczoge1xuICAgICAgXCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9KTsgLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxuXG4gIGpRdWVyeS5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsIGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMuY2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcy5jYWNoZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzLmNyb3NzRG9tYWluKSB7XG4gICAgICBzLnR5cGUgPSBcIkdFVFwiO1xuICAgIH1cbiAgfSk7IC8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxuXG4gIGpRdWVyeS5hamF4VHJhbnNwb3J0KFwic2NyaXB0XCIsIGZ1bmN0aW9uIChzKSB7XG4gICAgLy8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcbiAgICBpZiAocy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzKSB7XG4gICAgICB2YXIgc2NyaXB0LCBjYWxsYmFjaztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uIChfLCBjb21wbGV0ZSkge1xuICAgICAgICAgIHNjcmlwdCA9IGpRdWVyeShcIjxzY3JpcHQ+XCIpLmF0dHIocy5zY3JpcHRBdHRycyB8fCB7fSkucHJvcCh7XG4gICAgICAgICAgICBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG4gICAgICAgICAgICBzcmM6IHMudXJsXG4gICAgICAgICAgfSkub24oXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgICAgIGNvbXBsZXRlKGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTsgLy8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cbiAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdFswXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICB2YXIgb2xkQ2FsbGJhY2tzID0gW10sXG4gICAgICByanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vOyAvLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5cbiAgalF1ZXJ5LmFqYXhTZXR1cCh7XG4gICAganNvbnA6IFwiY2FsbGJhY2tcIixcbiAgICBqc29ucENhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArIG5vbmNlLmd1aWQrKztcbiAgICAgIHRoaXNbY2FsbGJhY2tdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gIH0pOyAvLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcblxuICBqUXVlcnkuYWpheFByZWZpbHRlcihcImpzb24ganNvbnBcIiwgZnVuY3Rpb24gKHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSKSB7XG4gICAgdmFyIGNhbGxiYWNrTmFtZSxcbiAgICAgICAgb3ZlcndyaXR0ZW4sXG4gICAgICAgIHJlc3BvbnNlQ29udGFpbmVyLFxuICAgICAgICBqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmIChyanNvbnAudGVzdChzLnVybCkgPyBcInVybFwiIDogdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAocy5jb250ZW50VHlwZSB8fCBcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpID09PSAwICYmIHJqc29ucC50ZXN0KHMuZGF0YSkgJiYgXCJkYXRhXCIpOyAvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cbiAgICBpZiAoanNvblByb3AgfHwgcy5kYXRhVHlwZXNbMF0gPT09IFwianNvbnBcIikge1xuICAgICAgLy8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuICAgICAgY2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbihzLmpzb25wQ2FsbGJhY2spID8gcy5qc29ucENhbGxiYWNrKCkgOiBzLmpzb25wQ2FsbGJhY2s7IC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblxuICAgICAgaWYgKGpzb25Qcm9wKSB7XG4gICAgICAgIHNbanNvblByb3BdID0gc1tqc29uUHJvcF0ucmVwbGFjZShyanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHMuanNvbnAgIT09IGZhbHNlKSB7XG4gICAgICAgIHMudXJsICs9IChycXVlcnkudGVzdChzLnVybCkgPyBcIiZcIiA6IFwiP1wiKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcbiAgICAgIH0gLy8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXG5cbiAgICAgIHMuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlQ29udGFpbmVyKSB7XG4gICAgICAgICAgalF1ZXJ5LmVycm9yKGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWzBdO1xuICAgICAgfTsgLy8gRm9yY2UganNvbiBkYXRhVHlwZVxuXG5cbiAgICAgIHMuZGF0YVR5cGVzWzBdID0gXCJqc29uXCI7IC8vIEluc3RhbGwgY2FsbGJhY2tcblxuICAgICAgb3ZlcndyaXR0ZW4gPSB3aW5kb3dbY2FsbGJhY2tOYW1lXTtcblxuICAgICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuICAgICAgfTsgLy8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cblxuICAgICAganFYSFIuYWx3YXlzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG4gICAgICAgIGlmIChvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgalF1ZXJ5KHdpbmRvdykucmVtb3ZlUHJvcChjYWxsYmFja05hbWUpOyAvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gb3ZlcndyaXR0ZW47XG4gICAgICAgIH0gLy8gU2F2ZSBiYWNrIGFzIGZyZWVcblxuXG4gICAgICAgIGlmIChzW2NhbGxiYWNrTmFtZV0pIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcbiAgICAgICAgICBzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7IC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2VcblxuICAgICAgICAgIG9sZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrTmFtZSk7XG4gICAgICAgIH0gLy8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cblxuICAgICAgICBpZiAocmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbihvdmVyd3JpdHRlbikpIHtcbiAgICAgICAgICBvdmVyd3JpdHRlbihyZXNwb25zZUNvbnRhaW5lclswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuICAgICAgfSk7IC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXG4gICAgICByZXR1cm4gXCJzY3JpcHRcIjtcbiAgICB9XG4gIH0pOyAvLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4gIC8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbiAgLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4gIC8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbiAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuXG4gIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpLmJvZHk7XG4gICAgYm9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG4gICAgcmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG4gIH0oKTsgLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4gIC8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbiAgLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbiAgLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xuXG5cbiAgalF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uIChkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cykge1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGtlZXBTY3JpcHRzID0gY29udGV4dDtcbiAgICAgIGNvbnRleHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcbiAgICAgIC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG4gICAgICBpZiAoc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQpIHtcbiAgICAgICAgY29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKTsgLy8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG4gICAgICAgIC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG4gICAgICAgIC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cbiAgICAgICAgYmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImJhc2VcIik7XG4gICAgICAgIGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgIGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZChiYXNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQgPSBkb2N1bWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoZGF0YSk7XG4gICAgc2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTsgLy8gU2luZ2xlIHRhZ1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIFtjb250ZXh0LmNyZWF0ZUVsZW1lbnQocGFyc2VkWzFdKV07XG4gICAgfVxuXG4gICAgcGFyc2VkID0gYnVpbGRGcmFnbWVudChbZGF0YV0sIGNvbnRleHQsIHNjcmlwdHMpO1xuXG4gICAgaWYgKHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgIGpRdWVyeShzY3JpcHRzKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKFtdLCBwYXJzZWQuY2hpbGROb2Rlcyk7XG4gIH07XG4gIC8qKlxuICAgKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gICAqL1xuXG5cbiAgalF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGVjdG9yLFxuICAgICAgICB0eXBlLFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIG9mZiA9IHVybC5pbmRleE9mKFwiIFwiKTtcblxuICAgIGlmIChvZmYgPiAtMSkge1xuICAgICAgc2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKHVybC5zbGljZShvZmYpKTtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBvZmYpO1xuICAgIH0gLy8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cblxuICAgIGlmIChpc0Z1bmN0aW9uKHBhcmFtcykpIHtcbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDsgLy8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHR5cGUgPSBcIlBPU1RcIjtcbiAgICB9IC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cblxuICAgIGlmIChzZWxmLmxlbmd0aCA+IDApIHtcbiAgICAgIGpRdWVyeS5hamF4KHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG4gICAgICAgIC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuICAgICAgICAvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2RcbiAgICAgICAgdHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgIGRhdGE6IHBhcmFtc1xuICAgICAgfSkuZG9uZShmdW5jdGlvbiAocmVzcG9uc2VUZXh0KSB7XG4gICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuICAgICAgICByZXNwb25zZSA9IGFyZ3VtZW50cztcbiAgICAgICAgc2VsZi5odG1sKHNlbGVjdG9yID8gLy8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG4gICAgICAgIC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuICAgICAgICBqUXVlcnkoXCI8ZGl2PlwiKS5hcHBlbmQoalF1ZXJ5LnBhcnNlSFRNTChyZXNwb25zZVRleHQpKS5maW5kKHNlbGVjdG9yKSA6IC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG4gICAgICAgIHJlc3BvbnNlVGV4dCk7IC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuICAgICAgICAvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG4gICAgICAgIC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcbiAgICAgIH0pLmFsd2F5cyhjYWxsYmFjayAmJiBmdW5jdGlvbiAoanFYSFIsIHN0YXR1cykge1xuICAgICAgICBzZWxmLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIHJlc3BvbnNlIHx8IFtqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFJdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBqUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcbiAgICB9KS5sZW5ndGg7XG4gIH07XG5cbiAgalF1ZXJ5Lm9mZnNldCA9IHtcbiAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uIChlbGVtLCBvcHRpb25zLCBpKSB7XG4gICAgICB2YXIgY3VyUG9zaXRpb24sXG4gICAgICAgICAgY3VyTGVmdCxcbiAgICAgICAgICBjdXJDU1NUb3AsXG4gICAgICAgICAgY3VyVG9wLFxuICAgICAgICAgIGN1ck9mZnNldCxcbiAgICAgICAgICBjdXJDU1NMZWZ0LFxuICAgICAgICAgIGNhbGN1bGF0ZVBvc2l0aW9uLFxuICAgICAgICAgIHBvc2l0aW9uID0galF1ZXJ5LmNzcyhlbGVtLCBcInBvc2l0aW9uXCIpLFxuICAgICAgICAgIGN1ckVsZW0gPSBqUXVlcnkoZWxlbSksXG4gICAgICAgICAgcHJvcHMgPSB7fTsgLy8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXG4gICAgICBpZiAocG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIH1cblxuICAgICAgY3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcbiAgICAgIGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoZWxlbSwgXCJ0b3BcIik7XG4gICAgICBjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyhlbGVtLCBcImxlZnRcIik7XG4gICAgICBjYWxjdWxhdGVQb3NpdGlvbiA9IChwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIpICYmIChjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0KS5pbmRleE9mKFwiYXV0b1wiKSA+IC0xOyAvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuICAgICAgLy8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cbiAgICAgIGlmIChjYWxjdWxhdGVQb3NpdGlvbikge1xuICAgICAgICBjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcbiAgICAgICAgY3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuICAgICAgICBjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1clRvcCA9IHBhcnNlRmxvYXQoY3VyQ1NTVG9wKSB8fCAwO1xuICAgICAgICBjdXJMZWZ0ID0gcGFyc2VGbG9hdChjdXJDU1NMZWZ0KSB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICAvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY2FsbChlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKHt9LCBjdXJPZmZzZXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudG9wICE9IG51bGwpIHtcbiAgICAgICAgcHJvcHMudG9wID0gb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICsgY3VyVG9wO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcHMubGVmdCA9IG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICsgY3VyTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKFwidXNpbmdcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMudXNpbmcuY2FsbChlbGVtLCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHByb3BzLnRvcCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHByb3BzLnRvcCArPSBcInB4XCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3BzLmxlZnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBwcm9wcy5sZWZ0ICs9IFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1ckVsZW0uY3NzKHByb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuICAgIG9mZnNldDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgPyB0aGlzIDogdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgalF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQodGhpcywgb3B0aW9ucywgaSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjdCxcbiAgICAgICAgICB3aW4sXG4gICAgICAgICAgZWxlbSA9IHRoaXNbMF07XG5cbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG4gICAgICAvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3JcblxuXG4gICAgICBpZiAoIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9O1xuICAgICAgfSAvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cblxuICAgICAgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuICAgIC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXNbMF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0UGFyZW50LFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBkb2MsXG4gICAgICAgICAgZWxlbSA9IHRoaXNbMF0sXG4gICAgICAgICAgcGFyZW50T2Zmc2V0ID0ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH07IC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cbiAgICAgIGlmIChqUXVlcnkuY3NzKGVsZW0sIFwicG9zaXRpb25cIikgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgIG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCgpOyAvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuICAgICAgICAvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXG4gICAgICAgIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIChvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCkgJiYgalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIikgPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuICAgICAgICAgIHBhcmVudE9mZnNldCA9IGpRdWVyeShvZmZzZXRQYXJlbnQpLm9mZnNldCgpO1xuICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSk7XG4gICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyhlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlKSxcbiAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUpXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgLy8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuICAgIC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuICAgIC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcbiAgICAvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG4gICAgLy9cbiAgICAvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcbiAgICAvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cbiAgICAvL1xuICAgIC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG4gICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7IC8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xuXG4gIGpRdWVyeS5lYWNoKHtcbiAgICBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsXG4gICAgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCJcbiAgfSwgZnVuY3Rpb24gKG1ldGhvZCwgcHJvcCkge1xuICAgIHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cbiAgICBqUXVlcnkuZm5bbWV0aG9kXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKGVsZW0sIG1ldGhvZCwgdmFsKSB7XG4gICAgICAgIC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuICAgICAgICB2YXIgd2luO1xuXG4gICAgICAgIGlmIChpc1dpbmRvdyhlbGVtKSkge1xuICAgICAgICAgIHdpbiA9IGVsZW07XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgIHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gd2luID8gd2luW3Byb3BdIDogZWxlbVttZXRob2RdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpbikge1xuICAgICAgICAgIHdpbi5zY3JvbGxUbyghdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LCB0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1bbWV0aG9kXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIH07XG4gIH0pOyAvLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4gIC8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4gIC8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuICAvLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuICAvLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuICAvLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxuXG4gIGpRdWVyeS5lYWNoKFtcInRvcFwiLCBcImxlZnRcIl0sIGZ1bmN0aW9uIChfaSwgcHJvcCkge1xuICAgIGpRdWVyeS5jc3NIb29rc1twcm9wXSA9IGFkZEdldEhvb2tJZihzdXBwb3J0LnBpeGVsUG9zaXRpb24sIGZ1bmN0aW9uIChlbGVtLCBjb21wdXRlZCkge1xuICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgIGNvbXB1dGVkID0gY3VyQ1NTKGVsZW0sIHByb3ApOyAvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblxuICAgICAgICByZXR1cm4gcm51bW5vbnB4LnRlc3QoY29tcHV0ZWQpID8galF1ZXJ5KGVsZW0pLnBvc2l0aW9uKClbcHJvcF0gKyBcInB4XCIgOiBjb21wdXRlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xuXG4gIGpRdWVyeS5lYWNoKHtcbiAgICBIZWlnaHQ6IFwiaGVpZ2h0XCIsXG4gICAgV2lkdGg6IFwid2lkdGhcIlxuICB9LCBmdW5jdGlvbiAobmFtZSwgdHlwZSkge1xuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgIHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsXG4gICAgICBjb250ZW50OiB0eXBlLFxuICAgICAgXCJcIjogXCJvdXRlclwiICsgbmFtZVxuICAgIH0sIGZ1bmN0aW9uIChkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lKSB7XG4gICAgICAvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcbiAgICAgIGpRdWVyeS5mbltmdW5jTmFtZV0gPSBmdW5jdGlvbiAobWFyZ2luLCB2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiKSxcbiAgICAgICAgICAgIGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8IChtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIik7XG4gICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKGVsZW0sIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRvYztcblxuICAgICAgICAgIGlmIChpc1dpbmRvdyhlbGVtKSkge1xuICAgICAgICAgICAgLy8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcbiAgICAgICAgICAgIHJldHVybiBmdW5jTmFtZS5pbmRleE9mKFwib3V0ZXJcIikgPT09IDAgPyBlbGVtW1wiaW5uZXJcIiArIG5hbWVdIDogZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIiArIG5hbWVdO1xuICAgICAgICAgIH0gLy8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXG5cbiAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7IC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcbiAgICAgICAgICAgIC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoZWxlbS5ib2R5W1wic2Nyb2xsXCIgKyBuYW1lXSwgZG9jW1wic2Nyb2xsXCIgKyBuYW1lXSwgZWxlbS5ib2R5W1wib2Zmc2V0XCIgKyBuYW1lXSwgZG9jW1wib2Zmc2V0XCIgKyBuYW1lXSwgZG9jW1wiY2xpZW50XCIgKyBuYW1lXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyAvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG4gICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCB0eXBlLCBleHRyYSkgOiAvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSk7XG4gICAgICAgIH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xuICBqUXVlcnkuZWFjaChbXCJhamF4U3RhcnRcIiwgXCJhamF4U3RvcFwiLCBcImFqYXhDb21wbGV0ZVwiLCBcImFqYXhFcnJvclwiLCBcImFqYXhTdWNjZXNzXCIsIFwiYWpheFNlbmRcIl0sIGZ1bmN0aW9uIChfaSwgdHlwZSkge1xuICAgIGpRdWVyeS5mblt0eXBlXSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIHRoaXMub24odHlwZSwgZm4pO1xuICAgIH07XG4gIH0pO1xuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICBiaW5kOiBmdW5jdGlvbiAodHlwZXMsIGRhdGEsIGZuKSB7XG4gICAgICByZXR1cm4gdGhpcy5vbih0eXBlcywgbnVsbCwgZGF0YSwgZm4pO1xuICAgIH0sXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAodHlwZXMsIGZuKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmYodHlwZXMsIG51bGwsIGZuKTtcbiAgICB9LFxuICAgIGRlbGVnYXRlOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbikge1xuICAgICAgcmV0dXJuIHRoaXMub24odHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbik7XG4gICAgfSxcbiAgICB1bmRlbGVnYXRlOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHR5cGVzLCBmbikge1xuICAgICAgLy8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0aGlzLm9mZihzZWxlY3RvciwgXCIqKlwiKSA6IHRoaXMub2ZmKHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuKTtcbiAgICB9LFxuICAgIGhvdmVyOiBmdW5jdGlvbiAoZm5PdmVyLCBmbk91dCkge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2VlbnRlcihmbk92ZXIpLm1vdXNlbGVhdmUoZm5PdXQgfHwgZm5PdmVyKTtcbiAgICB9XG4gIH0pO1xuICBqUXVlcnkuZWFjaCgoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArIFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgKyBcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIikuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiAoX2ksIG5hbWUpIHtcbiAgICAvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gdGhpcy5vbihuYW1lLCBudWxsLCBkYXRhLCBmbikgOiB0aGlzLnRyaWdnZXIobmFtZSk7XG4gICAgfTtcbiAgfSk7IC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuICAvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1BcblxuICB2YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7IC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuICAvLyBhcmd1bWVudHMuXG4gIC8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbiAgLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5cbiAgalF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24gKGZuLCBjb250ZXh0KSB7XG4gICAgdmFyIHRtcCwgYXJncywgcHJveHk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRtcCA9IGZuW2NvbnRleHRdO1xuICAgICAgY29udGV4dCA9IGZuO1xuICAgICAgZm4gPSB0bXA7XG4gICAgfSAvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuICAgIC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cblxuICAgIGlmICghaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSAvLyBTaW11bGF0ZWQgYmluZFxuXG5cbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXG4gICAgcHJveHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9OyAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblxuXG4gICAgcHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuXG4gIGpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiAoaG9sZCkge1xuICAgIGlmIChob2xkKSB7XG4gICAgICBqUXVlcnkucmVhZHlXYWl0Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGpRdWVyeS5yZWFkeSh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgalF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICBqUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbiAgalF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG4gIGpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgalF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG4gIGpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gIGpRdWVyeS50eXBlID0gdG9UeXBlO1xuICBqUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbiAgalF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcbiAgICAvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuICAgIHZhciB0eXBlID0galF1ZXJ5LnR5cGUob2JqKTtcbiAgICByZXR1cm4gKHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIikgJiYgLy8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG4gICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuICAgIC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuICAgICFpc05hTihvYmogLSBwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIGpRdWVyeS50cmltID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dCA9PSBudWxsID8gXCJcIiA6ICh0ZXh0ICsgXCJcIikucmVwbGFjZShydHJpbSwgXCJcIik7XG4gIH07IC8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuICAvLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4gIC8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuICAvLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4gIC8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuICAvLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbiAgLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuICAvLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuICAvLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4gIC8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGpRdWVyeTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciAvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgX2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG4gICAgICAvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICBfJCA9IHdpbmRvdy4kO1xuXG4gIGpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKGRlZXApIHtcbiAgICBpZiAod2luZG93LiQgPT09IGpRdWVyeSkge1xuICAgICAgd2luZG93LiQgPSBfJDtcbiAgICB9XG5cbiAgICBpZiAoZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkpIHtcbiAgICAgIHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuICAgIH1cblxuICAgIHJldHVybiBqUXVlcnk7XG4gIH07IC8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4gIC8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1NylcbiAgLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuXG5cbiAgaWYgKHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbiAgfVxuXG4gIHJldHVybiBqUXVlcnk7XG59KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jquery/dist/jquery.js\n");

/***/ }),

/***/ "./src/customizer.js":
/*!***************************!*\
  !*** ./src/customizer.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {/**\n * File customizer.js.\n *\n * Theme Customizer enhancements for a better user experience.\n *\n * Contains handlers to make Theme Customizer preview reload changes asynchronously.\n */\n(function ($) {\n  // Site title and description.\n  wp.customize('blogname', function (value) {\n    value.bind(function (to) {\n      $('.site-title a').text(to);\n    });\n  });\n  wp.customize('blogdescription', function (value) {\n    value.bind(function (to) {\n      $('.site-description').text(to);\n    });\n  }); // Header text color.\n\n  wp.customize('header_textcolor', function (value) {\n    value.bind(function (to) {\n      if ('blank' === to) {\n        $('.site-title, .site-description').css({\n          clip: 'rect(1px, 1px, 1px, 1px)',\n          position: 'absolute'\n        });\n      } else {\n        $('.site-title, .site-description').css({\n          clip: 'auto',\n          position: 'relative'\n        });\n        $('.site-title a, .site-description').css({\n          color: to\n        });\n      }\n    });\n  });\n})(jQuery);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3VzdG9taXplci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jdXN0b21pemVyLmpzPzA2ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGaWxlIGN1c3RvbWl6ZXIuanMuXG4gKlxuICogVGhlbWUgQ3VzdG9taXplciBlbmhhbmNlbWVudHMgZm9yIGEgYmV0dGVyIHVzZXIgZXhwZXJpZW5jZS5cbiAqXG4gKiBDb250YWlucyBoYW5kbGVycyB0byBtYWtlIFRoZW1lIEN1c3RvbWl6ZXIgcHJldmlldyByZWxvYWQgY2hhbmdlcyBhc3luY2hyb25vdXNseS5cbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG4gIC8vIFNpdGUgdGl0bGUgYW5kIGRlc2NyaXB0aW9uLlxuICB3cC5jdXN0b21pemUoJ2Jsb2duYW1lJywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUuYmluZChmdW5jdGlvbiAodG8pIHtcbiAgICAgICQoJy5zaXRlLXRpdGxlIGEnKS50ZXh0KHRvKTtcbiAgICB9KTtcbiAgfSk7XG4gIHdwLmN1c3RvbWl6ZSgnYmxvZ2Rlc2NyaXB0aW9uJywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUuYmluZChmdW5jdGlvbiAodG8pIHtcbiAgICAgICQoJy5zaXRlLWRlc2NyaXB0aW9uJykudGV4dCh0byk7XG4gICAgfSk7XG4gIH0pOyAvLyBIZWFkZXIgdGV4dCBjb2xvci5cblxuICB3cC5jdXN0b21pemUoJ2hlYWRlcl90ZXh0Y29sb3InLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YWx1ZS5iaW5kKGZ1bmN0aW9uICh0bykge1xuICAgICAgaWYgKCdibGFuaycgPT09IHRvKSB7XG4gICAgICAgICQoJy5zaXRlLXRpdGxlLCAuc2l0ZS1kZXNjcmlwdGlvbicpLmNzcyh7XG4gICAgICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKCcuc2l0ZS10aXRsZSwgLnNpdGUtZGVzY3JpcHRpb24nKS5jc3Moe1xuICAgICAgICAgIGNsaXA6ICdhdXRvJyxcbiAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgICB9KTtcbiAgICAgICAgJCgnLnNpdGUtdGl0bGUgYSwgLnNpdGUtZGVzY3JpcHRpb24nKS5jc3Moe1xuICAgICAgICAgIGNvbG9yOiB0b1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KShqUXVlcnkpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/customizer.js\n");

/***/ })

/******/ });